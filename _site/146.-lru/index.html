<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>2025-05-23 Leetcode 146.LRU 5433字记录思考的过程 _ Chia-ch’i‘s Web page</title>
<meta name="description" content="使用 GPT refine 了文章">


  <meta name="author" content="Chia-ch'i">
  
  <meta property="article:author" content="Chia-ch'i">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_GB">
<meta property="og:site_name" content="Chia-ch'i‘s Web page">
<meta property="og:title" content="2025-05-23 Leetcode 146.LRU 5433字记录思考的过程">
<meta property="og:url" content="http://localhost:4000/146.-lru/">


  <meta property="og:description" content="使用 GPT refine 了文章">







  <meta property="article:published_time" content="2025-05-23T00:00:00+08:00">





  

  


<link rel="canonical" href="http://localhost:4000/146.-lru/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Chia-ch'i",
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Chia-ch'i‘s Web page Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--post">

    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Chia-ch'i‘s Web page
          <span class="site-subtitle"> </span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/post/">All Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/collection-archive/">Collections</a>
            </li><li class="masthead__menu-item">
              <a href="https://chat.openai.com/">Google</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="/" itemprop="item"><span itemprop="name">Home</span></a>

          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">2025-05-23 Leetcode 146.LRU 5433字记录思考的过程</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person" class="h-card">

  
    <div class="author__avatar">
      <a href="http://localhost:4000/">
        <img src="/assets/images/88x88.png" alt="Chia-ch'i" itemprop="image" class="u-photo">
      </a>
    </div>
  

  <div class="author__content">
    <h3 class="author__name p-name" itemprop="name">
      <a class="u-url" rel="me" href="http://localhost:4000/" itemprop="url">Chia-ch'i</a>
    </h3>
    
      <div class="author__bio p-note" itemprop="description">
        <p>The primary purpose of this website is to motivate me to write about life, thoughts, and learning observations.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name" class="p-locality">Atlanta.US</span>
        </li>
      

      
        
          
            <li><a href="mailto:notmyemailcode@gmail.com" rel="nofollow noopener noreferrer me"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://bokehforu.github.io/" rel="nofollow noopener noreferrer me" itemprop="sameAs"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Website</span></a></li>
          
        
          
        
          
        
          
        
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer me">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <div class="archive">
    
      <h1 id="page-title" class="page__title">2025-05-23 Leetcode 146.LRU 5433字记录思考的过程</h1>
    
    <p><em>使用 GPT refine 了文章</em></p>

<p>2025-05-25</p>

<p>读完题目, 我们需要设计一个支持以下操作的数据结构：<code class="language-plaintext highlighter-rouge">get</code> 和 <code class="language-plaintext highlighter-rouge">put</code>，并且这两个操作都要在 $O(1)$ 时间内完成。为了实现这一点，我们结合使用了 <strong>哈希表（dict）</strong> 和 <strong>双向链表（Doubly Linked List, DLList）</strong>, 这里补充的时候, 刚做这个题目的难点的, 这两个操作同时还要实现在时序上的 order.</p>

<p><strong>为什么需要链表, 而且是 DDList</strong>？单用 Python 中的 <code class="language-plaintext highlighter-rouge">dict</code> 虽然查找快，但无法保持数据的访问顺序；而使用 <code class="language-plaintext highlighter-rouge">list</code> 虽然可以维护顺序，却无法在 $O(1)$ 时间内删除任意节点。而另外一个基础结构, 链表, 实现一个 stack 的时候, 我们在头结尾上添加和删除, 这就都是 O1 的,但是这个时候我们想到了, 我们这个题的逻辑在删除上是也是要 O1 的, 而且应该是从 tail 上删除, 这相当于实现了一个可以前进后出的队列, 但是链表的尾部删除是是 On 的, 就算我们有一个 tail 指针也是一样, 因为我们不知道 tail 这个 node 的前面是什么位置是哪个 node, tail 在被删除之后, 要重新遍历一遍找到新的 tail, , 除非我们在访问的一个节点的时候, 我们可以知道这个 node 的前面是是哪个节点, 方法呼之欲出了—- 使用 <strong>双向链表</strong> 来存储所有的缓存节点，并维护最近访问的顺序。最近使用的节点放在链表头部，最久未使用的节点在链表尾部；当容量超限时，我们就移除尾部节点。</p>

<p>然后, 我们想一下如何建立链表, 简单, 使用一个 node class 就行了, 于是我们开了一个新的 class, 如下</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># why? 
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>这里的关键点是：<strong>为什么节点中还要记录 <code class="language-plaintext highlighter-rouge">self.key</code>？</strong>
这是因为我们在删除最久未使用节点的时候（也就是链表尾部节点），需要从哈希表中同步删除对应的项。我们能通过链表找到这个节点 <code class="language-plaintext highlighter-rouge">node</code>，但要从哈希表中 <code class="language-plaintext highlighter-rouge">O(1)</code> 时间地删除 <code class="language-plaintext highlighter-rouge">table[key]</code>，就必须知道它对应的 key。</p>

<blockquote>
  <p>你可能会问，为什么不能直接使用这个 node 本身作为哈希表的 key 呢？这是 Python 和 Java 的一个差异。在 Python 中，字典的 key 默认是通过对象的 id（即地址）来计算的 hash 值，除非手动重写 <code class="language-plaintext highlighter-rouge">__hash__</code> 和 <code class="language-plaintext highlighter-rouge">__eq__</code> 方法。而且即使两个节点 <code class="language-plaintext highlighter-rouge">Node(key=1, val=100)</code> 看起来值一样，它们的实例地址是不同的。因此不能指望用节点本身作为哈希表的 key 来查找。</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># False
</span></code></pre></div></div>

<blockquote>
  <p>这意味着，即使两个 node 的内容一样，它们不是同一个 key。所以我们不能用 node 当 key，只能用原始输入的 <code class="language-plaintext highlighter-rouge">key</code>。</p>
</blockquote>

<p>从功能逻辑上再解释一次：</p>

<ul>
  <li>哈希表 <code class="language-plaintext highlighter-rouge">table</code> 提供 $O(1)$ 的 key 到节点的映射。</li>
  <li>双向链表记录访问顺序，支持 $O(1)$ 的插入和删除操作。</li>
  <li>当我们访问一个 key（<code class="language-plaintext highlighter-rouge">get</code> 或 <code class="language-plaintext highlighter-rouge">put</code> 更新已有 key）时，我们需要：
    <ol>
      <li>在哈希表中快速找到对应的 node。</li>
      <li>把这个 node 移到链表的头部（代表最近访问）。</li>
    </ol>
  </li>
  <li>当容量满了时：
    <ol>
      <li>我们从链表尾部拿到最旧的节点 <code class="language-plaintext highlighter-rouge">node</code>。</li>
      <li>通过 <code class="language-plaintext highlighter-rouge">node.key</code> 在哈希表中删除对应条目。</li>
    </ol>
  </li>
</ul>

<p>所以我们必须在每个 <code class="language-plaintext highlighter-rouge">Node</code> 中保留 <code class="language-plaintext highlighter-rouge">self.key</code>，因为这是唯一能让我们在 $O(1)$ 时间内，从哈希表中同步删除那一项的手段。</p>

<p>这个结构的设计核心就是：<br />
**哈希表用于快速定位，双向链表用于维护访问顺序。两者结合才能实现整体的 $O(1)$ 性能目标。</p>

<p>更加高屋建瓴地讲, 从 <a href="https://xiaobot.net/post/1354728a-277d-4429-a163-2212ef171a3a">Infra 面试之数据结构六：LRU</a> 文章来说, 解这道题的关键是如何管理复杂度, 把这个难的问题拆开来(难, 只是因为拆的不够简单)
宏观上，代码组织思路：</p>
<ol>
  <li>将该数据结构分为<strong>数据和索引</strong>两部分</li>
  <li>数据用链表组织，可动态维护时间先后。可保证替换时间复杂度为 $O(1)$</li>
  <li>索引用哈希表组织，用于快速查找删除。可保证增删时间复杂度为 $O(1)$ 
这种数据、索引分离考虑的思想，借鉴数据库的聚集索引|和二级索引.</li>
</ol>

<p>当然还有题目实现上的细节需要考虑
OK, 我们继续
从下面的这个题目中的空代码出发</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        


<span class="c1"># Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value
</span>
</code></pre></div></div>

<h1 id="original-分步骤部分-这个部分用-gpt-gemini-refine-之后发现变化特别大-保留原始部分了">original 分步骤部分 (这个部分用 GPT Gemini refine 之后发现变化特别大, 保留原始部分了)</h1>
<p>现在我们已经写好了, 这里除了一些算法上的实现细节, 其实有两种大的逻辑, 实现同样的功能,</p>
<ol>
  <li>是在比对了有 key 之后使用原来的内存地址上的点, 进行 detach, 再使用同一个移动到最前面的位置,</li>
  <li>是在对比有了 key 之后, 直接删除, 然后新创建一个 node 连在 head 后面, 这样会使用更加多的内存开销, 但是实现上更加简单, 而第二种其实代码更加复杂来避免反复的新建, 使用大量的内存, 所以我觉得第一种是第二种的优化, 所以我先写第二种, 再从优化的角度写第一种</li>
</ol>

<p>OK, 我们现在有, <font color="red">这里有一个初始值设定的问题, 有些会写 key = None 是什么的</font> , 继续写下面的代码,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">node</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    	<span class="c1"># table
</span>    	<span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># DDlist
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>
        
        <span class="c1"># input capacity
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
</code></pre></div></div>
<p>OK, 继续是初始化的步骤, 在这个位置想的是什么呢, 第一个是我们要 table , 第二个是我们要有链表啊, OK, 这就是所有了, 当然还有一个在使用链表做题时候一个 tricky 的地方, 就是
OK,在写了之后, 要继续想, 就是我们具体其实要操作的是数据结构本身, 那么, 其实, 这个要在上面画什么的决策树其实是 table 的添加和删除, 还有链表的添加和删除, 但是字典的添加和删除很简单, python 中都已经有接口实现了, 这时候注意, 我们的链表是我们本身创建的结构, 这个删除和添加的逻辑 python 并没有给我们,</p>

<blockquote>
  <p><strong>很多题解都写在 class LRUCache 下,</strong> 我的疑问是能不能写在 node 中, 好像是可以的, <code class="language-plaintext highlighter-rouge">_delete</code> 操作删除 node, 哦哦哦不行? class 中的方法, 可以删除自己吗, 应该可以吧, 再想想插入的方法, 我一般要插入的话要干什么, 都是更新在最新的位置, 那么就是说, 好像和 table 也没什么关联, 那么, 问题就剩下, 如果, 写在本身的话, 插入和删除的输入可不可以是自己, 应该可以是自己的吧, 因为递归的输入就是自己,</p>
</blockquote>

<p>OK 上面的问题的产生是因为我把 <code class="language-plaintext highlighter-rouge">class node</code> 和 <code class="language-plaintext highlighter-rouge">class doublelinkedlist</code> 弄混淆了, 也就是说, 其实这里我们的面向对象编程也省略掉了要创造 doublelinkedlist 这一步, 所以这里这个问题会出现是因为, 我没有思考过的. 继续, 我们先在 <code class="language-plaintext highlighter-rouge">class LRUCache</code> 中写我们的方法</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
	<span class="s">'''
	ignore upper codes
	'''</span>
	
	<span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
	<span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
</code></pre></div></div>
<p>其中删除的逻辑很简单, 就交给 python 的内存回收机制就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
	<span class="c1"># node.prev
</span>	<span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
	<span class="c1"># node.next 
</span>	<span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>
</code></pre></div></div>
<p>但是,这里的 ` _update<code class="language-plaintext highlighter-rouge"> 要使用 key 吗, 不清楚, 但是可以先写, 首先理解这个逻辑是, 如果存在在 DLList 中, 就 ... 如果不在那么就可以直接加在 head 的后面, OK, 从这个逻辑出发, 我们的 </code> _update` 方法是需要 key 的, 不然, 如何用 table $O(1)$ 时间地来判断重复呢? (这里也说明这个方法要在)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 错了吗
</span></code></pre></div></div>

<p>所以我们认为这个 <code class="language-plaintext highlighter-rouge">_update</code> 方法需要我们的 key, 在没有做这个题之前, 我觉得我确实想不出来, 因为这些关系都是交织的, 很难一下子直接分割到最小, 所以写成 <code class="language-plaintext highlighter-rouge">def _update(self, node, key): </code> 哦是这样吗? 错了, 只是更新一个 node, 但是 key 不更新的话, 那么其实我们也不需要这个 key 了, OK,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 对的?
</span></code></pre></div></div>

<p>其实, 我现在感觉没有这个对错, 问题的关键在于这个 key 的作用, 是什么作用, 要不要想不想切割到最小, 这个感觉, OK, 那先按照现在的思路继续写
然后想一下, 这个方法要干什么, 现在排除掉了检测, 其实就是什么呢, 就是要实现了一个链表的插入节点的操作, 一共有三个节点的状态应该考虑, 分别是 head, head.next, node</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>

	<span class="c1"># 从 head位置, 插入
</span>	<span class="n">headnxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
	
	<span class="c1"># node的前后
</span>	<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
	<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">headnxt</span>
	
	<span class="c1"># 原先的head后面的node的prev要接上新的node
</span>	<span class="n">headnxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>

<p>OK, 那么现在就剩下题目原来的 put 和 get 方法了, 现在, 想一想这个方法要干什么, get 是要检查有没有(注意更新最近使用), 然后 put 是要完成插入的逻辑, 同时要注意更新最近的逻辑, 同时要注意整体的 size, 因为这个 cache 有 capacity. 
get 比较简单, 先写 get, 大的框架是有 or 没有的逻辑, 这是很简单想到的,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
	
	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>OK, 那么继续实现一下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		
		<span class="c1"># 返回那个对应table[key]
</span>		<span class="c1"># 要在前面更新
</span>	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="c1"># 创建
</span>		<span class="n">tempnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		
		<span class="c1"># 删除
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># 要吗?
</span>		<span class="c1"># 新建?
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempnode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempnode</span> <span class="c1"># 其实前面不要删除更新一下就行了
</span>		<span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>那么还剩下一个 put 的方法了, 想一想逻辑,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
</code></pre></div></div>
<p>把决策树都画出来,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">输入key</span>
	<span class="n">如果在其中有key的话</span>
		<span class="n">删除原先的node在链表和table中</span>
		<span class="n">添加这个新的node到head后面</span>
		<span class="n">更新table</span>
	<span class="n">如果在其中没有key的话</span>
		<span class="n">现在的node放在head后面</span>
		<span class="n">table更新一下</span>
	<span class="n">最后检查size</span><span class="p">,</span> <span class="n">如果超过capacity就从tail开始删除一个</span>
	
</code></pre></div></div>

<p>写, 这里要注意 table 和链表删除的顺序, 应该先从链表上删除, 因为使用 table 可以用 $O(1)$ 的时间访问对应的节点, 但是如果先在 table 上把这个节点删除掉的话, 那么我们会丢失这个用 key 快速访问的能力, 但是相反的, 我们的删除逻辑本身运行后, 不会影响我们 table 的逻辑, 因为我们是改变 key 对应的 node 的前后连接关系, 而不是说让这个 node 本身变成 None, 但是好像即使是变成 None 也没什么关系, OK, 这里就说完了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
		
	<span class="k">else</span><span class="p">:</span> <span class="c1"># no key in self.table
</span>		<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>
	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="n">delnode</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
		
		<span class="c1"># del 
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">delnode</span><span class="p">)</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">delnode</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></div>

<p>OK 现在都写完了, 那么, 整体的全部代码如下,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># table
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># DLList
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>

        <span class="c1"># input capacity
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">headnxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">headnxt</span>
        <span class="n">headnxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 有key的情况下
</span>        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="c1"># 创建
</span>            <span class="n">tempnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># 删除
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># del self.table[key]  # 不需要删除，table 直接覆盖
</span>
            <span class="c1"># 新建并更新
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempnode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempnode</span>

            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
        <span class="c1"># 没有key的情况下
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no key in self.table
</span>            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
            <span class="n">delnode</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>

            <span class="c1"># del
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">delnode</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">delnode</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>

</code></pre></div></div>

<p>对于代码本身的优化, 这里的一个细节和 two sum 题很像, 就我感觉是 code 层面上的剪枝, 对于 put 方法而言, 很容易的就看到, 在 <code class="language-plaintext highlighter-rouge">self.table</code> 中在判断完是否有 key 后, 这个条件判断中, 每一个子部分, 都有, <code class="language-plaintext highlighter-rouge">建立 tempNode</code>, 然后是因为刚刚存入, 所以要更新到 <code class="language-plaintext highlighter-rouge">head</code> 后, 放置到最新的位置,这都是合理的, 哦那其实, 我们有代码重复在了一个两个不同的地方, 那么只要提出来就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="c1"># 想什么时候要额外, 就是有key的时候, OK
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
	<span class="c1"># 合并了
</span>	<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
	
	
	<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span> <span class="c1"># table
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span><span class="c1"># 更新到最新
</span>	
	<span class="c1"># size检查
</span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="n">del_target</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="c1"># del_target 
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">del_target</span><span class="p">.</span><span class="n">key</span><span class="p">])</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">del_target</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></div>

<p>OK, 在这个部分写完之后, 我们可以发现, 我们不需要对于 ` put<code class="language-plaintext highlighter-rouge"> 方法和 </code>get` 方法在每一步都建立一个新的 node, 在创建一个 node 的时候, 会在计算机上 grab 一个新的内存地址, 然后, 相当于 put 和 get 方法都需要频繁的内存操作,</p>
<blockquote>
  <p><strong>deepseek- 14b 分析</strong>
比如 malloc 和 free 或者垃圾回收的压力。此外，当缓存容量达到上限时，需要替换掉旧
的节点，这时候如果一直有新的节点被插入，老节点可能已经被移除或仍在链表中，这
可能会导致一些问题，比如内存泄漏或者其他逻辑错误。
   -
2第二种方法 <strong>优点</strong>：实现相对直接，不需要复杂的指针调整。<strong>缺点</strong>：每次访问都创建新节点，导致更多的内存分配和释放操作，可能影响性能。此外，管理旧节点的引用可能会增加代码复杂度。</p>
</blockquote>

<ol>
  <li><strong>建立新节点的影响</strong>：
    <ul>
      <li><strong>内存开销</strong>：频繁的新建会导致更多的内存分配，增加了垃圾回收或内存管理
的压力。</li>
      <li><strong>性能影响</strong>：内存分配操作可能成为性能瓶颈，尤其是在高并发场景下。</li>
    </ul>
  </li>
</ol>

<p>OK 现在如果我们只是操作原来在内存上已经建立的节点的话, 那么我们只是用原来已经被创建的对象, 这样可以大幅减小使用内存的开销.
一开始我以为只需要改变 <code class="language-plaintext highlighter-rouge">put</code> 方法和 ` get<code class="language-plaintext highlighter-rouge"> 方法, 但是现在我感觉 </code>_update`  方法也应该被更新</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="err">···</span> 
    <span class="n">ignoring</span>
    <span class="err">···</span>
    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    	<span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
    	<span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>
    	
	<span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="n">node</span>
		
		<span class="c1"># head
</span>		<span class="n">original_head_nxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">temp_pointer</span>
		
		<span class="c1"># node(temp_pointer)
</span>		<span class="n">temp_pointer</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
		<span class="n">temp_pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">original_head_nxt</span>
		
		<span class="c1"># original_head_nxt
</span>		<span class="n">original_head_nxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">temp_pointer</span>
		
	<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> 
		<span class="c1"># 剪枝
</span>		<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
		<span class="c1"># key in table
</span>		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
		<span class="c1"># update logic
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">temp_pointer</span><span class="p">)</span> <span class="c1"># self._move_to_after_head(self.table[key]) both OK ?
</span>		
		<span class="c1"># table 不需要动, only 节点的联系在变化就可以了
</span>		<span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
	
	<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		

</code></pre></div></div>

<p>对于 put 方法而言, 我们还是按照原始的 flow 就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="n">newNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		
		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNode</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># key in table 
</span>		<span class="c1">#dict value 更新
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># 
</span>		<span class="c1"># 删除
</span>			
		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="c1"># 指针
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="c1"># 原先断掉
</span>		<span class="c1"># 更新
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">temp_pointer</span><span class="p">)</span> <span class="c1"># 放到新位置
</span>		
	<span class="c1"># size, 实现lru
</span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="c1"># READ, find
</span>		<span class="n">the_lru_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
		
		<span class="c1"># DELETE
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">the_lru_node</span><span class="p">)</span> <span class="c1"># list
</span>		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">the_lru_node</span><span class="p">.</span><span class="n">key</span><span class="p">]</span> <span class="c1"># table
</span></code></pre></div></div>

<p>GPT 说的, 对 <code class="language-plaintext highlighter-rouge">_add_to_after_head</code> 方法的优化, 很简单, 其实我们不需要 <code class="language-plaintext highlighter-rouge">tempnode</code> 和 <code class="language-plaintext highlighter-rouge">original_head_nxt</code></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		<span class="c1"># head
</span>		<span class="n">original_head_nxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
		
		<span class="c1"># node(temp_pointer)
</span>		<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
		<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">original_head_nxt</span>
		
		<span class="c1"># original_head_nxt
</span>		<span class="n">original_head_nxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>
<p>然后可以再简化一下</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
	<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
	<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
	<span class="c1"># 上一次最新的节点(self.head.next), or现在head后一个的节点
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
	<span class="c1"># head
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>

<p>OK, 那么新的使用原始节点复用的 <code class="language-plaintext highlighter-rouge">LRUCache</code> 代码如下(下面的代码是 gpt 生成的, 有些名字不一样)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>      <span class="c1"># 用于反查哈希表
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>      <span class="c1"># 实际存储的值
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c1"># 指向前一个节点
</span>        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c1"># 指向后一个节点
</span>
<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># key -&gt; Node
</span>
        <span class="c1"># 虚拟头尾节点，便于统一操作
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="s">"""从链表中断开某个节点"""</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">_add_to_front</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="s">"""把节点加到链表头部（head后面）"""</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>         <span class="c1"># 从原位置断开
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>   <span class="c1"># 移动到最前面
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="c1"># 已存在：更新值，并移动到最前面
</span>            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不存在：判断是否超容量
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
                <span class="c1"># 删除最久未用（链表尾部的前一个）
</span>                <span class="n">lru</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">lru</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># 新建节点并放入头部
</span>            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>

</code></pre></div></div>

<h1 id="最后谈谈-简单写法用-ordered_dict">最后谈谈, 简单写法用 ordered_dict</h1>

<p>这个 title 是一开始全空白的时候留下的, 就是什么都没写的时候. 我一开始以为我这个部分没有写过, 会到时候写不出来, 但是现在实现了 python 版本的 lru 之后, 我发现这个如果用 ordered_dict 方法实现非常简单, 而且在 python3.6 之后, 我们的 dict 就已经默认是有 order 的了, 那感觉就太简单了就是想象一下头和尾可以 $O(1)$ 时间取到的有 append 的先后顺序的 dict 呗, 就留下一个坑吧</p>

<h1 id="appendix">Appendix</h1>

<h3 id="original-开头部分">original 开头部分</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先是背的, 使用链表, 而且是双向链表, 这里, 为什么是要用链表呢, 因为我们想实现 $O(1)$ 时间的删除, 如果使用 arr or 直接使用字典就是 $O (n)$ 了, 这里的这个 trade off 使用了这个性质, 是用 DLList 实现的. 而且因为单链表不行, 

这里的时候我其实对 key 有疑问, 就是, 什么是要在 `node` 这个 `class` 中, 写 `self.key` , 这个的 intuition 呢, 还有一个问题是我在第二次写的时候, 不知道 or 没有这个直接来判断在 dict 中使用的 key 是什么, 是那个输入的 key, 还是可以使用 node 本身呢 (这里有个疑问中的小疑惑, python 中的对象是和 java 一样会使用一个 hashcode 吗, 还是直接是地址, java 直接 print 是 hashcode 吗还是对象的内存地址), OK, 继续, 我自己想的是, 如果用 node 本身作为 table 的 key, 那么 value 一样的时候, key是不一样的, 会找不到对应的值, 所以这里, 可能应该要用本身 func 中输入的 key 作为 table 的 key, 

还有是为什么 DLList 的 node class 中要加入 `self.key`  这里要回到删除机制的概念了, 想到删除, 这里想到的是从 table 上删除, 但是 table 只是作为一个 $O(1)$ 时间访问的功能, table 的访问和删除, 我们可以很快的使用 key 来实现, 但是双向链表呢, 需要在链表上删除和添加对应的 node 的操作, 这个时候, 按照题目的要求, 我们也要 $O(1)$, 想起来(这里是背的), 我们怎么直接取到这个 node 呢, 为什么不可以就是 `table[key]` 然后在里面放一个正常形式的 node 呢? 我们已经是拿到了对应的 node, 为什么还要 key 呢, 对于正常的删除, 这里正常的意思是我们使用 put 方法的时候, 如果本身的 size 在添加的时候超出了 capacity 的话,~~那确实是不需要这个使用 node 中的 self.key,~~ 对就是在这个超出的 capacity 的功能上, 我们可以使用 $O(1)$ 的时间删除在链表上的点, 但是, 我们如果使用原始的 node class 的样式的话, 在 table 上如何删除对应的对象呢, 这里, table 要 O1 只能使用 key 来进行访问, 那么如果我们在访问到一个节点的时候, 我们没有 key 这个值的话, 我们就不可以在得到 node 的情况下, 用 O1 的时间定位到(查询到?)这个 node 在 table 上, 所以我们在设计这个 node 的时候, 我们加上了 self.key 这个参数
</code></pre></div></div>



<ul class="taxonomy__index">
  
  
    <li>
      <a href="#2025">
        <strong>2025</strong> <span class="taxonomy__count">6</span>
      </a>
    </li>
  
    <li>
      <a href="#2024">
        <strong>2024</strong> <span class="taxonomy__count">3</span>
      </a>
    </li>
  
    <li>
      <a href="#2023">
        <strong>2023</strong> <span class="taxonomy__count">8</span>
      </a>
    </li>
  
</ul>




  <section id="2025" class="taxonomy__section">
    <h2 class="archive__subtitle">2025</h2>
    <div class="entries-list">
      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/146.-lru/" rel="permalink">2025-05-23 Leetcode 146.LRU 5433字记录思考的过程
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">使用 GPT refine 了文章

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/Dot-products%E7%82%B9%E7%A7%AF-and-duality-Chapter-9/" rel="permalink">2025-05-01 Dot products点积 and duality Chapter 9/16
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">3Blue1Brown

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/%E4%BB%8EMatrix-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear-Algebra/" rel="permalink">Linear Algebra Starting from Matrix Multiplication
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">好像写成一个的线代的内容了, 有很多未完待续的内容

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/learning/" rel="permalink">Thinking and Re-thinking of Learning and Happiness
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Using LLMs to refine context through chaotic thinking, but I think GPT-4.5 (2025-04-22) is quite good.

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/recursive-problem/" rel="permalink">Recursive problem and Thinking Process
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">The article contains mistakes and misunderstandings, as it is a record of my own incorrect notes rather than a proper summary document.

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/How-I-use-LLMs-by-Andrej-Karpathy-%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93/" rel="permalink">2025-03-07-How I use LLMs by Andrej Karpathy 看后总结
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">https://www.youtube.com/watch?v=EWvNQjAaOHw

</p>
  </article>
</div>

      
    </div>
    <a href="#page-title" class="back-to-top">Back to top &uarr;</a>
  </section>

  

  <section id="2024" class="taxonomy__section">
    <h2 class="archive__subtitle">2024</h2>
    <div class="entries-list">
      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/Life-goals-at-30/" rel="permalink">Life goals before the age of 30 (in addition to finding a job)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">:)

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/visa-preparation/" rel="permalink">签证准备材料list
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">记录签证准备材料的list

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/how-to-read-mtf-curves.md/" rel="permalink">Notes for ‘How To Read MTF Curves’ article
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">文章翻译, 阅读, 解读MTF曲线, 笔记总结
Preface

</p>
  </article>
</div>

      
    </div>
    <a href="#page-title" class="back-to-top">Back to top &uarr;</a>
  </section>

  

  <section id="2023" class="taxonomy__section">
    <h2 class="archive__subtitle">2023</h2>
    <div class="entries-list">
      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/inner-producted/" rel="permalink">Inner producted 一些问题
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">A record of some simple ideas.

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/learning-how-to-learn-powerful-mental-tools-to-help-you-master-tough-subjects/" rel="permalink">learning how to learn powerful mental tools to help you master tough subjects
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          45 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">UCLA online
learning how to learn powerful mental tools to help you master tough subjects

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/CMU-Discrete-mathematics-2001-notes/" rel="permalink">Discrete Mathematics
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          3 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">虎头蛇尾…

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/Injective,-Surjective-and-Bi-jective/" rel="permalink">Injective, Surjective and bi-jective
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">A small concept in discrete mathematics

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/Lec1-and-lec2-content/" rel="permalink">MIT missing Cour
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">进度条…(2/8)

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/proof-of-Cramer-s-rule/" rel="permalink">Proof of Cramer’s Rule
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">The article contains three proofs.

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/elec211pdf/" rel="permalink">ELEC211: Digital Electronics &amp; Microprocessor Systems
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">

</p>
  </article>
</div>

      
        



<div class="list__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/comp-202/" rel="permalink">ELEC202 Lec 7&amp;8 FM&amp;PM
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">mainly talk about FM&amp;PM in ELEC202 at Lec 7&amp;8

</p>
  </article>
</div>

      
    </div>
    <a href="#page-title" class="back-to-top">Back to top &uarr;</a>
  </section>

  


  </div>
</div>
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <!-- MathJax 配置和加载 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        }
      };
    </script>
    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GXFVKNJ25Z"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-GXFVKNJ25Z');
    </script>

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 Chia-ch'i. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
