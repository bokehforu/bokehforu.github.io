<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-04-27T22:19:27-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chia-ch’i‘s Web page</title><subtitle> </subtitle><author><name>Chia-ch&apos;i</name></author><entry><title type="html">Linear Algebra Starting from Matrix Multiplication</title><link href="http://localhost:4000/%E4%BB%8EMatrix-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear-Algebra/" rel="alternate" type="text/html" title="Linear Algebra Starting from Matrix Multiplication" /><published>2025-04-25T00:00:00-04:00</published><updated>2025-04-25T00:00:00-04:00</updated><id>http://localhost:4000/%E4%BB%8EMatrix%20%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear%20Algebra</id><content type="html" xml:base="http://localhost:4000/%E4%BB%8EMatrix-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear-Algebra/"><![CDATA[<p>好像写成一个的线代的内容了, 有很多未完待续的内容</p>

<p>我可以算出矩阵乘法的题目，但当涉及到矩阵乘法的<strong>交换顺序的意义</strong>，或者说矩阵乘法<strong>本身的内在含义</strong>时，我往往无法在第一时间作出直觉反应。</p>

<p>在做矩阵乘法的时候，我依赖的是一种背诵的技巧, 提醒自己这个东西叫 “行列式”, 所以“前一个矩阵的行, 乘以后一个矩阵的列”。但我并不知道这个操作<strong>实际上意味着什么</strong>。 经过自己的反思，我发现，我之所以缺乏这种直觉，是因为我对“矩阵乘法”这一概念没有真正理解。在除了得到一个结果外, 矩阵乘法到底在干什么。这个很基本的数学定义 or 数学概念想要解决现实中的什么问题?</p>

<p>这种基于死记硬背的方式，让我在进一步思考矩阵相关的概念时(如旋转、投影、缩放等操作, 或者是去括号, 转置, 求可逆矩阵的一些变式)，总是感觉模糊和经常出错。因为从最底层开始，我对矩阵的理解就是模糊的，甚至可以说是错的，导致我没法基于它构建准确的思维。</p>

<p>我想解决这个问题。</p>

<p>线性变换的复合 (Composition of Linear Transformations)</p>

<h3 id="出现问题的一个comment的场景">出现问题的一个comment的场景</h3>
<p>下面是一个 $5 \times 5$ 的矩阵相乘的例子, 这是一个很好的例子就是, 
\(\begin{bmatrix} A_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{15} \\ A_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{25} \\ A_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} &amp; a_{35} \\ A_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} &amp; a_{45} \\ A_{51} &amp; a_{52} &amp; a_{53} &amp; a_{54} &amp; a_{55} \\ \end{bmatrix} \times \begin{bmatrix} B_{11} &amp; b_{12} &amp; b_{13} &amp; b_{14} &amp; b_{15} \\ B_{21} &amp; b_{22} &amp; b_{23} &amp; b_{24} &amp; b_{25} \\ B_{31} &amp; b_{32} &amp; b_{33} &amp; b_{34} &amp; b_{35} \\ B_{41} &amp; b_{42} &amp; b_{43} &amp; b_{44} &amp; b_{45} \\ B_{51} &amp; b_{52} &amp; b_{53} &amp; b_{54} &amp; b_{55} \\ \end{bmatrix} = \begin{bmatrix} C_{11} &amp; c_{12} &amp; c_{13} &amp; c_{14} &amp; c_{15} \\ C_{21} &amp; c_{22} &amp; c_{23} &amp; c_{24} &amp; c_{25} \\ C_{31} &amp; c_{32} &amp; c_{33} &amp; c_{34} &amp; c_{35} \\ C_{41} &amp; c_{42} &amp; c_{43} &amp; c_{44} &amp; c_{45} \\ C_{51} &amp; c_{52} &amp; c_{53} &amp; c_{54} &amp; c_{55} \\ \end{bmatrix}\)</p>

<p>疑惑的点是, 如果认为任意一个matrix都是列向量的话, 那么其实在这个显而易见的式子中, $A   x = b$ 中, 一个认知是$A$  可以被认为是一个大的系统(如果是 n by m的matrix), $x$作为一个vector(拆分成竖直方向上的单列) (woc这里应该是 1 乘 多少的单列vector我不可以一秒判断出来), 由于疑惑, 我回到传统想法上的记住行列式的乘法的方法, 会发现, 这个结果也是一列的其实, 但是我对于怎么乘是模糊的, OK再想 行乘以列这个口诀, 也就是说, vector的第一个, 乘了A的第一个行, 这是也是第一个b上的结果, 那么这个第一个位置上的结果到底是什么东西呢, 不是最后要写的结果, 而是搞不明白代表什么东西</p>

<h1 id="3blue1brown-linear-transformations-and-matrices--chapter-3-essence-of-linear-algebra">{3Blue1Brown} Linear transformations and matrices | Chapter 3, Essence of linear algebra</h1>

<p>回到一个简单的问题, 下面是一个在二维平面中的vector,
\(\vec{v} = \begin{bmatrix} -1 \\ 2 \end{bmatrix}\) 如何看待这个对象呢, 可以认为是, 使用两个单位矩阵构造的, which is  $\hat{j} = \begin{bmatrix} 0\ 1 \end{bmatrix}$ 和$\hat{i}= \begin{bmatrix} 1\ 0 \end{bmatrix}$, 这里可以注意到, $\hat{j}$ 在 $y$ 轴上, 而 $\hat{i}$ 在 $x$ 轴上, 那么我们的 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ 是如何得到的呢?  使用线性变换(注:要补充)的概念非常简单, 我们可以得到
\(\vec{v} = (-1) \cdot \hat{i} + 2 \cdot \hat{j} = (-1) \cdot \begin{bmatrix} 1\\ 0 \end{bmatrix} + 2 \cdot \begin{bmatrix} 0\\ 1 \end{bmatrix} = \begin{bmatrix} -1 \\ 2 \end{bmatrix}\)</p>

<p>OK, 再进一步的视角是, 
\(\)</p>

<p>我原来以为, $\begin{bmatrix} -1 \ 2 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 是可以得到 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ , 但是现在发现我错了(而且这也是非法的矩阵相乘), 应该是$\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$因为和下面的逻辑混淆了, 3Blue1Brown说, 对于(这里我随机写了一个例子) $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 这里其实是让新的基底变成 $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix}$ 而不再是原来的 $\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 我在想是不是原来对于 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ 是不是后面都藏着一个 $\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 代表着原来的基底?</p>

<p>哦哦, 不是的, 应该说一个结果的基座向量会写在结果的前面, $I \cdot \vec{v} = \begin{bmatrix} 1 &amp; 0 \ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix} = \begin{bmatrix} -1 \ 2 \end{bmatrix}$, 这样反而是恰当的, 合乎逻辑的, 但是在前面乘一个单位矩阵太傻了, 但是可以发现的是, 在前面乘就是提供 一个要变换的指令, 只不过单位矩阵恰好是没有任何变化要求的那个. 而 $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 可以被认为是$\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 \ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$</p>

<font color="red">这个表述错了</font>
<p>$\rightarrow$ 其实在$\begin{bmatrix} -1 \ 2 \end{bmatrix}$的后面乘是逆变化, 不过这是后话了. <font color="red">变化可以认为就是在前面乘, 在前面乘就是在做各种线性操作, 比如转回去就是在前面的位置乘一个逆就行了</font></p>

<p>但是我好像还是没搞懂为什么能变成这样, $(-1) \cdot \begin{bmatrix} -1 \ 1\end{bmatrix} \cdot + 2 \cdot  \begin{bmatrix} 4 \ 2\end{bmatrix}$ 
3Blue1Brown的视频中, 是这样写的, $\begin{bmatrix} -1 \ 2 \end{bmatrix}$  被我们看成了单独放置的点 or 一个向量的箭头指向这个点的位置, 这样的意义也可以这样表示$\vec{v} = -1 \cdot \vec{i}_1 + 2 \cdot \vec{j}_2$,  这个点的表示分, 我突然看到感觉好陌生, 之前好像没有只是顺着写了一下, 自己不知道为什么可以这样写. OK, 如果可以这样写的话, 就相对清晰了, 就是, 直接换了一套基座, 对于这个式子而言, $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 不是吗,</p>

<h2 id="再描述一个更加抽象的例子">再描述一个更加抽象的例子</h2>

\[A \cdot B = C\]

<p>这里的$A$ 和 $B$ 都是 $4 \times 4$ 的matrix</p>

<p>从列的角度看这个问题后, <font color="red">好吧, 突然我也不知道这里从列的角度看是什么意思</font>, 我姑且认为在做的开始, $A$ 和 $B$ 都被认为是一列一列呈现的</p>

<p>$A$就被我们看成从$$</p>

<p>A = \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \ a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \ a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \ a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \end{bmatrix}
\(​​​​
列向量视角的 $A$：\)
A = \left[ \vec{a}_1 \quad \vec{a}_2 \quad \vec{a}_3 \quad \vec{a}_4 \right]
$$</p>

\[\vec{a}_1 = \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix}, \quad
\vec{a}_2 = \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix}, \quad
\vec{a}_3 = \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix}, \quad
\vec{a}_4 = \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix}\]

<p>OK, 我们得到 $A = \left[ \vec{a}_1 \quad \vec{a}_2 \quad \vec{a}_3 \quad \vec{a}_4 \right]$ 后开始处理 $B$ , 同样列向量视角
​​​​
 从\(B = \begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} &amp; b_{14} \\ b_{21} &amp; b_{22} &amp; b_{23} &amp; b_{24} \\ b_{31} &amp; b_{32} &amp; b_{33} &amp; b_{34} \\ b_{41} &amp; b_{42} &amp; b_{43} &amp; b_{44} \end{bmatrix}\)
​到
\(B = \left[ \vec{b}_1 \quad \vec{b}_2 \quad \vec{b}_3 \quad \vec{b}_4 \right]\)</p>

\[\vec{b}_1 = \begin{bmatrix} b_{11} \\ b_{21} \\ b_{31} \\ b_{41} \end{bmatrix}, \quad
\vec{b}_2 = \begin{bmatrix} b_{12} \\ b_{22} \\ b_{32} \\ b_{42} \end{bmatrix},
\quad

\vec{b}_3 = \begin{bmatrix} b_{13} \\ b_{23} \\ b_{33} \\ b_{43} \end{bmatrix},
\quad

\vec{b}_4 = \begin{bmatrix} b_{14} \\ b_{24} \\ b_{34} \\ b_{44} \end{bmatrix},
\quad\]

<p>写完后, 我们的 $B$ 作为之前的数值位置, $A$中的向量都是作为新的坐标系来构建, 那么我们可以得到</p>

<h2 id="3-列中列展开法的具体表示">3. “列中列”展开法的具体表示</h2>

<p>矩阵乘积 $C = A \cdot B$ 的完整展开形式：</p>

\[C = \left[ \begin{array}{cccc} b_{11} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{21} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{31} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{41} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{12} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{22} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{32} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{42} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{13} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{23} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{33} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{43} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{14} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{24} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{34} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{44} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} \end{array} \right]\]

<p>$\rightarrow$</p>

<p>\(\left[ \begin{array}{cccc} \begin{bmatrix} b_{11} a_{11} \\ b_{11} a_{21} \\ b_{11} a_{31} \\ b_{11} a_{41} \end{bmatrix} + \begin{bmatrix} b_{21} a_{12} \\ b_{21} a_{22} \\ b_{21} a_{32} \\ b_{21} a_{42} \end{bmatrix} + \begin{bmatrix} b_{31} a_{13} \\ b_{31} a_{23} \\ b_{31} a_{33} \\ b_{31} a_{43} \end{bmatrix} + \begin{bmatrix} b_{41} a_{14} \\ b_{41} a_{24} \\ b_{41} a_{34} \\ b_{41} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{12} a_{11} \\ b_{12} a_{21} \\ b_{12} a_{31} \\ b_{12} a_{41} \end{bmatrix} + \begin{bmatrix} b_{22} a_{12} \\ b_{22} a_{22} \\ b_{22} a_{32} \\ b_{22} a_{42} \end{bmatrix} + \begin{bmatrix} b_{32} a_{13} \\ b_{32} a_{23} \\ b_{32} a_{33} \\ b_{32} a_{43} \end{bmatrix} + \begin{bmatrix} b_{42} a_{14} \\ b_{42} a_{24} \\ b_{42} a_{34} \\ b_{42} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{13} a_{11} \\ b_{13} a_{21} \\ b_{13} a_{31} \\ b_{13} a_{41} \end{bmatrix} + \begin{bmatrix} b_{23} a_{12} \\ b_{23} a_{22} \\ b_{23} a_{32} \\ b_{23} a_{42} \end{bmatrix} + \begin{bmatrix} b_{33} a_{13} \\ b_{33} a_{23} \\ b_{33} a_{33} \\ b_{33} a_{43} \end{bmatrix} + \begin{bmatrix} b_{43} a_{14} \\ b_{43} a_{24} \\ b_{43} a_{34} \\ b_{43} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{14} a_{11} \\ b_{14} a_{21} \\ b_{14} a_{31} \\ b_{14} a_{41} \end{bmatrix} + \begin{bmatrix} b_{24} a_{12} \\ b_{24} a_{22} \\ b_{24} a_{32} \\ b_{24} a_{42} \end{bmatrix} + \begin{bmatrix} b_{34} a_{13} \\ b_{34} a_{23} \\ b_{34} a_{33} \\ b_{34} a_{43} \end{bmatrix} + \begin{bmatrix} b_{44} a_{14} \\ b_{44} a_{24} \\ b_{44} a_{34} \\ b_{44} a_{44} \end{bmatrix} \end{array} \right]\) 
$\rightarrow$</p>

<p>其中我们拿出一条来
\(b_{11} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{21} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{31} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{41} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix}\)
是这样的, 
\(\begin{bmatrix} b_{11}a_{11} \\ b_{11}a_{21} \\ b_{11}a_{31} \\ b_{11}a_{41} \end{bmatrix} + \begin{bmatrix} b_{21}a_{12} \\ b_{21}a_{22} \\ b_{21}a_{32} \\ b_{21}a_{42} \end{bmatrix} + \begin{bmatrix} b_{31} a_{13} \\ b_{31}a_{23} \\ b_{31} a_{33} \\ b_{31} a_{43} \end{bmatrix} +\begin{bmatrix} b_{41}a_{14} \\ b_{41}a_{24} \\ b_{41}a_{34} \\ b_{41}a_{44} \end{bmatrix}\)</p>

<p>再线性相加
\(= \begin{bmatrix} b_{11}a_{11} + b_{21}a_{12} + b_{31}a_{13} + b_{41}a_{14} \\ b_{11}a_{21} + b_{21}a_{22} + b_{31}a_{23} + b_{41}a_{24} \\ b_{11}a_{31} + b_{21}a_{32} + b_{31}a_{33} + b_{41}a_{34} \\ b_{11}a_{41} + b_{21}a_{42} + b_{31}a_{43} + b_{41}a_{44} \end{bmatrix}\)</p>

<p>这是一个$4\times 1$的矩阵, 然后我们有4条, 最后是 一个$4\times 4$ 的结果</p>

\[\begin{bmatrix} a_{11} b_{11} + a_{12} b_{21} + a_{13} b_{31} + a_{14} b_{41} &amp; a_{11} b_{12} + a_{12} b_{22} + a_{13} b_{32} + a_{14} b_{42} &amp; a_{11} b_{13} + a_{12} b_{23} + a_{13} b_{33} + a_{14} b_{43} &amp; a_{11} b_{14} + a_{12} b_{24} + a_{13} b_{34} + a_{14} b_{44} \\ a_{21} b_{11} + a_{22} b_{21} + a_{23} b_{31} + a_{24} b_{41} &amp; a_{21} b_{12} + a_{22} b_{22} + a_{23} b_{32} + a_{24} b_{42} &amp; a_{21} b_{13} + a_{22} b_{23} + a_{23} b_{33} + a_{24} b_{43} &amp; a_{21} b_{14} + a_{22} b_{24} + a_{23} b_{34} + a_{24} b_{44} \\ a_{31} b_{11} + a_{32} b_{21} + a_{33} b_{31} + a_{34} b_{41} &amp; a_{31} b_{12} + a_{32} b_{22} + a_{33} b_{32} + a_{34} b_{42} &amp; a_{31} b_{13} + a_{32} b_{23} + a_{33} b_{33} + a_{34} b_{43} &amp; a_{31} b_{14} + a_{32} b_{24} + a_{33} b_{34} + a_{34} b_{44} \\ a_{41} b_{11} + a_{42} b_{21} + a_{43} b_{31} + a_{44} b_{41} &amp; a_{41} b_{12} + a_{42} b_{22} + a_{43} b_{32} + a_{44} b_{42} &amp; a_{41} b_{13} + a_{42} b_{23} + a_{43} b_{33} + a_{44} b_{43} &amp; a_{41} b_{14} + a_{42} b_{24} + a_{43} b_{34} + a_{44} b_{44} \end{bmatrix}\]

<p>这时候有一些经典的问题, 就是从这个转动的性质出发了</p>

<ol>
  <li>
    <p><strong>矩阵相乘是否满足交换率?</strong> 当然不行, 都完全是两个东西了</p>
  </li>
  <li>
    <p><strong>矩阵相乘成立的条件是前一个matrix的什么要等于后一个matrix的什么?</strong> 完全不用急, 想着 $Ax = b$ 在这个时候,  $A$ 是我们的旋转/变换系统, 想象每一列都是独立的, rank是满秩的(其实不用只要操作的时候有那个维度就OK了), 那么在这个情况下, 我们的 $x$ 中的 $[x_1 \dots x_n]$ 当然是要和前面的 $A$ 有多少列要匹配了</p>
  </li>
  <li>
    <font color="red">这里理解错了, 说明有知识点没懂</font>
    <p>$Ax = b$ 中的 b是 几乘几点结果, 感觉x的维度是怎样, b就长怎样? 如果从 $A$ 是提供旋转功能的角度出发的话, 为什么会因为旋转 b相比原先旋转的对象 x 增加维度呢?
 这其实是更广义的「<strong>线性变换</strong>」，不仅仅是旋转, 不一定是严格的旋转，它可以是 <strong>旋转 + 拉伸</strong>(放大缩小) 投影 (把高维变低维) 嵌入 (把低维映射到高维) 剪切(shear)</p>
  </li>
  <li><strong>如果说 3 by 2的matrix, 如何0.5s内说出 2 是2行还是2列?</strong> 之前我是使用行列式这样的背住然后套的, 但是这里提供一种更加直觉的想法, 是, 我们定义这个名字的时候, 更加关注输出, 什么是输出, 变换后矩阵的维度, 那么变换后矩阵的维度是什么, 是由什么确定的, 这样想下去就是, 当然是  $A$ 这个提供变换的方案的matrix确定, 然后再想象一下, 这里的A的维度是什么, 是A的行数(row), 因为我们考虑的是A每一列vector的维度, 这样我们这个变化系统的row就确定了, 所以3 by 2的matrix的话, 3 $\rightarrow$  row, 所以是3 行 2 列的矩阵.</li>
</ol>

<p><strong>未完待续</strong></p>
<ol>
  <li>矩阵乘法的剩下三种理解方法</li>
  <li>变化的特色case, 为什么有些乘上有些矩阵的时候, 在一个维度上没有变动</li>
  <li>第二个问题在看3Blue1Brown发现他希望不动的x维度上, 对应的 A的位置, 好像都是单位矩阵的part, 虽然不知道再哪个位置(哪一层)放1</li>
  <li>之后要详细讨论的点是, 在3这个视频中, 所谓的 单个 $A$ 矩阵如果是变换作用的话, 居然直接是单位矩阵想要最后变成的固定状态(停在那个位置).</li>
  <li>左乘看成新坐标系的基向量，右边的原向量看成标量
    <h2 id="标准基底下的矢量">标准基底下的矢量</h2>
  </li>
</ol>

<svg width="400" height="400" viewBox="-100 -100 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 网格线 -->
  <g stroke="#ccc" stroke-width="0.5">
    <!-- 纵向 -->
    <line x1="-90" y1="-100" x2="-90" y2="100" />
    <line x1="-80" y1="-100" x2="-80" y2="100" />
    <line x1="-70" y1="-100" x2="-70" y2="100" />
    <line x1="-60" y1="-100" x2="-60" y2="100" />
    <line x1="-50" y1="-100" x2="-50" y2="100" />
    <line x1="-40" y1="-100" x2="-40" y2="100" />
    <line x1="-30" y1="-100" x2="-30" y2="100" />
    <line x1="-20" y1="-100" x2="-20" y2="100" />
    <line x1="-10" y1="-100" x2="-10" y2="100" />
    <line x1="10" y1="-100" x2="10" y2="100" />
    <line x1="20" y1="-100" x2="20" y2="100" />
    <line x1="30" y1="-100" x2="30" y2="100" />
    <line x1="40" y1="-100" x2="40" y2="100" />
    <line x1="50" y1="-100" x2="50" y2="100" />
    <line x1="60" y1="-100" x2="60" y2="100" />
    <line x1="70" y1="-100" x2="70" y2="100" />
    <line x1="80" y1="-100" x2="80" y2="100" />
    <line x1="90" y1="-100" x2="90" y2="100" />
    <!-- 横向 -->
    <line x1="-100" y1="-90" x2="100" y2="-90" />
    <line x1="-100" y1="-80" x2="100" y2="-80" />
    <line x1="-100" y1="-70" x2="100" y2="-70" />
    <line x1="-100" y1="-60" x2="100" y2="-60" />
    <line x1="-100" y1="-50" x2="100" y2="-50" />
    <line x1="-100" y1="-40" x2="100" y2="-40" />
    <line x1="-100" y1="-30" x2="100" y2="-30" />
    <line x1="-100" y1="-20" x2="100" y2="-20" />
    <line x1="-100" y1="-10" x2="100" y2="-10" />
    <line x1="-100" y1="10" x2="100" y2="10" />
    <line x1="-100" y1="20" x2="100" y2="20" />
    <line x1="-100" y1="30" x2="100" y2="30" />
    <line x1="-100" y1="40" x2="100" y2="40" />
    <line x1="-100" y1="50" x2="100" y2="50" />
    <line x1="-100" y1="60" x2="100" y2="60" />
    <line x1="-100" y1="70" x2="100" y2="70" />
    <line x1="-100" y1="80" x2="100" y2="80" />
    <line x1="-100" y1="90" x2="100" y2="90" />
  </g>

  <!-- 坐标轴 -->
  <line x1="-100" y1="0" x2="100" y2="0" stroke="black" stroke-width="1" />
  <line x1="0" y1="-100" x2="0" y2="100" stroke="black" stroke-width="1" />

  <!-- 标准基底 i -->
  <line x1="0" y1="0" x2="20" y2="0" stroke="green" stroke-width="2" marker-end="url(#arrow-green)" />
  <text x="22" y="0" fill="green" font-size="12">î (1,0)</text>

  <!-- 标准基底 j -->
  <line x1="0" y1="0" x2="0" y2="-20" stroke="red" stroke-width="2" marker-end="url(#arrow-red)" />
  <text x="2" y="-22" fill="red" font-size="12">ĵ (0,1)</text>

  <!-- 原始矢量 v = (1,2) -->
  <line x1="0" y1="0" x2="20" y2="-40" stroke="orange" stroke-width="2" marker-end="url(#arrow-orange)" />
  <text x="22" y="-42" fill="orange" font-size="12">v (1,2)</text>

  <!-- 箭头定义 -->
  <defs>
    <marker id="arrow-green" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="green" />
    </marker>
    <marker id="arrow-red" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="red" />
    </marker>
    <marker id="arrow-orange" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="orange" />
    </marker>
  </defs>
</svg>

<h2 id="变换基底后的矢量">变换基底后的矢量</h2>

<svg width="400" height="400" viewBox="-100 -100 200 200" xmlns="http://www.w3.org/2000/svg">
<!-- 网格线 -->
  <g stroke="#ccc" stroke-width="0.5">
    <!-- 纵向 -->
    <line x1="-90" y1="-100" x2="-90" y2="100" />
    <line x1="-80" y1="-100" x2="-80" y2="100" />
    <line x1="-70" y1="-100" x2="-70" y2="100" />
    <line x1="-60" y1="-100" x2="-60" y2="100" />
    <line x1="-50" y1="-100" x2="-50" y2="100" />
    <line x1="-40" y1="-100" x2="-40" y2="100" />
    <line x1="-30" y1="-100" x2="-30" y2="100" />
    <line x1="-20" y1="-100" x2="-20" y2="100" />
    <line x1="-10" y1="-100" x2="-10" y2="100" />
    <line x1="10" y1="-100" x2="10" y2="100" />
    <line x1="20" y1="-100" x2="20" y2="100" />
    <line x1="30" y1="-100" x2="30" y2="100" />
    <line x1="40" y1="-100" x2="40" y2="100" />
    <line x1="50" y1="-100" x2="50" y2="100" />
    <line x1="60" y1="-100" x2="60" y2="100" />
    <line x1="70" y1="-100" x2="70" y2="100" />
    <line x1="80" y1="-100" x2="80" y2="100" />
    <line x1="90" y1="-100" x2="90" y2="100" />
    <!-- 横向 -->
    <line x1="-100" y1="-90" x2="100" y2="-90" />
    <line x1="-100" y1="-80" x2="100" y2="-80" />
    <line x1="-100" y1="-70" x2="100" y2="-70" />
    <line x1="-100" y1="-60" x2="100" y2="-60" />
    <line x1="-100" y1="-50" x2="100" y2="-50" />
    <line x1="-100" y1="-40" x2="100" y2="-40" />
    <line x1="-100" y1="-30" x2="100" y2="-30" />
    <line x1="-100" y1="-20" x2="100" y2="-20" />
    <line x1="-100" y1="-10" x2="100" y2="-10" />
    <line x1="-100" y1="10" x2="100" y2="10" />
    <line x1="-100" y1="20" x2="100" y2="20" />
    <line x1="-100" y1="30" x2="100" y2="30" />
    <line x1="-100" y1="40" x2="100" y2="40" />
    <line x1="-100" y1="50" x2="100" y2="50" />
    <line x1="-100" y1="60" x2="100" y2="60" />
    <line x1="-100" y1="70" x2="100" y2="70" />
    <line x1="-100" y1="80" x2="100" y2="80" />
    <line x1="-100" y1="90" x2="100" y2="90" />
  </g>


  <!-- 坐标轴 -->
  <line x1="-100" y1="0" x2="100" y2="0" stroke="black" stroke-width="1" />
  <line x1="0" y1="-100" x2="0" y2="100" stroke="black" stroke-width="1" />

  <!-- 新基底 i -->
  <line x1="0" y1="0" x2="20" y2="0" stroke="green" stroke-width="2" marker-end="url(#arrow-green)" />
  <text x="22" y="0" fill="green" font-size="12">î' (1,0)</text>

  <!-- 新基底 j -->
  <line x1="0" y1="0" x2="20" y2="-20" stroke="red" stroke-width="2" marker-end="url(#arrow-red)" />
  <text x="22" y="-22" fill="red" font-size="12">ĵ' (1,1)</text>

  <!-- 变换后的矢量 v' = (3,2) -->
  <line x1="0" y1="0" x2="60" y2="-40" stroke="orange" stroke-width="2" marker-end="url(#arrow-orange)" />
  <text x="62" y="-42" fill="orange" font-size="12">v' (3,2)</text>

  <!-- 箭头定义 -->
  <defs>
    <marker id="arrow-green" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="green" />
    </marker>
    <marker id="arrow-red" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="red" />
    </marker>
    <marker id="arrow-orange" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="orange" />
    </marker>
  </defs>
</svg>

<ol>
  <li>还有细节是对于提供变化的matrix $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix}$ , 我们可以直接认为其中$\begin{bmatrix} -1  \ 1  \end{bmatrix}$ 就是 unit vector $i$ 的新位置, 而$\begin{bmatrix} 4 \2 \end{bmatrix}$ 就是 unit vector $j$ 的新位置</li>
</ol>

<h3 id="-chapter-4-essence-of-linear-algebra-chapter-5-说了一下三维-没讲什么">#  Chapter 4, Essence of linear algebra, Chapter 5 说了一下三维, 没讲什么</h3>
<p>章节中对于$x$ 多维过程计算一个batch的过程, 其实就是拆开一步步的过程</p>

<p>$$ \begin{align*}
&amp;\underset{M_2}{\begin{bmatrix} \textcolor{purple}0 &amp; \textcolor{purple}2 \ \textcolor{purple}1 &amp; \textcolor{purple}0 \end{bmatrix}} 
\cdot 
\underset{M_1}{\begin{bmatrix} 
\color{green}{1} &amp; \color{orange}{-2} \ 
\color{green}{1} &amp; \color{orange}{0} 
\end{bmatrix}} 
= 
\begin{bmatrix} 
? &amp; ? \ 
? &amp; ? 
\end{bmatrix} 
\[10pt]</p>

<p>&amp;\begin{bmatrix} 
\textcolor{purple}0 &amp; \textcolor{purple}2 \ 
\textcolor{purple}1 &amp; \textcolor{purple}0 
\end{bmatrix} 
\cdot 
\begin{bmatrix} 
\color{green}{1}\ 
\color{green}{1}
\end{bmatrix} 
= \textcolor{green}{1} \cdot \begin{bmatrix} 
\textcolor{purple}0 \ 
\textcolor{purple}1
\end{bmatrix}</p>
<ul>
  <li>\textcolor{green}{1} \cdot 
\begin{bmatrix} 
\textcolor{purple}2 \ 
\textcolor{purple}0 
\end{bmatrix} 
= 
\begin{bmatrix} 
2 \ 
1 
\end{bmatrix}
\end{align<em>}
\(我们得出 $\rightarrow$\)
\begin{align</em>}
&amp;\underset{M_2}{\begin{bmatrix} \textcolor{purple}0 &amp; \textcolor{purple}2 \ \textcolor{purple}1 &amp; \textcolor{purple}0 \end{bmatrix}} 
\cdot 
\underset{M_1}{\begin{bmatrix} 
\color{green}{1} &amp; \color{orange}{-2} \ 
\color{green}{1} &amp; \color{orange}{0} 
\end{bmatrix}} 
= 
\begin{bmatrix} 
2 &amp; ? \ 
1 &amp; ? 
\end{bmatrix} 
\[10pt]
\end{align*}</li>
</ul>

<p>$$
这里其实有一个小疑惑, 就是$ABCDEF \cdot x$ 中, 第一个$F$, 对于 $x$ 的坐标映射, 是不是就是遵循$F$ 中的样子来就可以了, 但是对于剩下的步骤, 因为大概率不orthogonal, 所以其实多维的都有影响?</p>

<h3 id="1-矩阵乘法的剩下三种理解方法">1. 矩阵乘法的剩下三种理解方法</h3>

<p>图设计来自<a href="https://www.zhihu.com/people/gwave-22">gwave</a> 知乎答主, 使用svg重新绘制, 突出版权, 在重制中仍然保留水印.</p>

<p><strong>矩阵-向量乘法-列视角：矩阵右乘列向量，向量对矩阵的列进行线性组合</strong></p>
<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 3x3 矩阵列块 -->
  <!-- 红列 -->
  <rect x="10" y="50" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="10" y="80" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="10" y="110" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- 绿列 -->
  <rect x="40" y="50" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="40" y="80" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="40" y="110" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- 蓝列 -->
  <rect x="70" y="50" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="70" y="80" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="70" y="110" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 乘号 × -->
  <text x="110" y="105" font-size="24" font-family="Arial">×</text>
  
  <!-- 列向量 a b c -->
  <rect x="140" y="50" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="70" font-size="16" font-family="Arial">a</text>
  <rect x="140" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="100" font-size="16" font-family="Arial">b</text>
  <rect x="140" y="110" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="130" font-size="16" font-family="Arial">c</text>
  
  <!-- 等号 -->
  <text x="180" y="105" font-size="24" font-family="Arial">=</text>
  
  <!-- a * 红列 -->
  <rect x="230" y="50" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="230" y="80" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="230" y="110" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- a 方块在左侧，不覆盖 -->
  <rect x="200" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="210" y="100" font-size="16" font-family="Arial">a</text>
  
  <!-- 加号 -->
  <text x="270" y="105" font-size="24" font-family="Arial">+</text>
  
  <!-- b * 绿列 -->
  <rect x="320" y="50" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="320" y="80" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="320" y="110" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- b 方块在左侧，不覆盖 -->
  <rect x="290" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="300" y="100" font-size="16" font-family="Arial">b</text>
  
  <!-- 加号 -->
  <text x="360" y="105" font-size="24" font-family="Arial">+</text>
  
  <!-- c * 蓝列 -->
  <rect x="410" y="50" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="410" y="80" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="410" y="110" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <!-- c 方块在左侧，不覆盖 -->
  <rect x="380" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="390" y="100" font-size="16" font-family="Arial">c</text>
  
  <!-- 等号 -->
  <text x="450" y="105" font-size="24" font-family="Arial">=</text>
  
  <!-- 最终结果 粉灰色条 -->
  <rect x="480" y="50" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="480" y="80" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="480" y="110" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  
  <!-- 右下角水印 -->
  <text x="420" y="170" font-size="14" fill="#666">知乎 @waywa</text>
</svg>
<p><strong>矩阵-向量乘法-行视角：矩阵左乘行向量，向量对矩阵的行进行线性组合</strong></p>
<svg viewBox="0 0 700 230" xmlns="http://www.w3.org/2000/svg">
  <!-- 左侧 行向量 a b c -->
  <rect x="20" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="30" y="120" font-size="16" font-family="Arial">a</text>
  <rect x="50" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="60" y="120" font-size="16" font-family="Arial">b</text>
  <rect x="80" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="90" y="120" font-size="16" font-family="Arial">c</text>
  
  <!-- 乘号 × - 与第一个图保持一致的大小 -->
  <text x="125" y="125" font-size="24" font-family="Arial">×</text>
  
  <!-- 3x3 矩阵列块 -->
  <!-- 红行 -->
  <rect x="160" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="190" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="220" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- 绿行 -->
  <rect x="160" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="190" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="220" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- 蓝行 -->
  <rect x="160" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="190" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="220" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 等号 - 与第一个图保持一致的大小 -->
  <text x="290" y="125" font-size="24" font-family="Arial">=</text>
  
  <!-- 右侧计算过程 -->
  <!-- a * 红行 -->
  <rect x="340" y="40" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="60" font-size="16" font-family="Arial">a</text>
  <rect x="370" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="400" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="430" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  
  <!-- 加号（a和b之间） - 保持一致大小 -->
  <text x="380" y="95" font-size="24" font-family="Arial">+</text>
  
  <!-- b * 绿行 -->
  <rect x="340" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="120" font-size="16" font-family="Arial">b</text>
  <rect x="370" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="400" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="430" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  
  <!-- 加号（b和c之间） - 保持一致大小 -->
  <text x="380" y="155" font-size="24" font-family="Arial">+</text>
  
  <!-- c * 蓝行 -->
  <rect x="340" y="160" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="180" font-size="16" font-family="Arial">c</text>
  <rect x="370" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="400" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="430" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 最后等号 - 保持一致大小 -->
  <text x="480" y="125" font-size="24" font-family="Arial">=</text>
  
  <!-- 最终结果 粉色行 -->
  <rect x="520" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="550" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="580" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  
  <!-- 右下角水印 -->
  <text x="520" y="210" font-size="14" fill="#666">知乎 @waywa</text>
</svg>
<p>还没理解完, 未完待续</p>

<h2 id="rrefreduced-row-echelon-form">RREF(Reduced Row-Echelon Form)</h2>

<p>感觉是一个很小的概念不在ML中常用到, 
意思是“是不是高斯消元法最后让每个基向量尽可能简单”，那可以说是的。每一行代表一个单位基方向，其他方向全0, 可以理解成“最小单位向量”，但其实数学上是标准基, 但是注意，它们不一定是整个空间的 unit vector，而是 <strong>在矩阵的列空间或行空间中</strong>形成了一个基底。</p>

<p>彼此线性无关，数量就是行空间的维度，也就是矩阵的秩。
列空间的秩=行空间的秩, 这个概念好像是<strong>有点背的</strong>, 还有下面这个公式
\(rank(A)=rank(A^\top)\)
秩，GPT说其实代表这个系统“真正有多复杂”，而不是表面的行和列数量。</p>

<p><strong>Reference</strong></p>

<p>矩阵乘法核心思想（2）：行空间 - <em>gwave</em> 知乎 https://zhuanlan.zhihu.com/p/348551903
Essence of linear algebra <em>3Blue1Brown</em>  https://youtu.be/fNk_zzaMoSs?si=UlVZ_LHcoih4kQvu
NTU 线性代数 Hung-yi Lee (李宏毅) https://googly-mingto.github.io/LA_2022_fall/2022-fall.html
MIT18.06 Linear-Algebra  https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[好像写成一个的线代的内容了, 有很多未完待续的内容]]></summary></entry><entry><title type="html">Recursive problem and Thinking Process</title><link href="http://localhost:4000/recursive-problem/" rel="alternate" type="text/html" title="Recursive problem and Thinking Process" /><published>2025-04-22T00:00:00-04:00</published><updated>2025-04-22T00:00:00-04:00</updated><id>http://localhost:4000/recursive%20problem</id><content type="html" xml:base="http://localhost:4000/recursive-problem/"><![CDATA[<p>The article contains mistakes and misunderstandings, as it is a record of my own incorrect notes rather than a proper summary document.</p>

<h1 id="first-module-1---arrays-arraylists-recursion">First Module 1 - Arrays, ArrayLists, Recursion</h1>

<p>Given this recursive method and an input of n = 7, what will the output be? Please enter your answer as a Comma Separated List (e.g 1, 2, 3, 4)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">public</span> <span class="n">void</span> <span class="n">recursiveMethod</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">return</span><span class="p">;</span>  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  
        <span class="n">recursiveMethod</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Your</span> <span class="n">Answer</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Correct</span> <span class="n">Answer</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span>  
</code></pre></div></div>

<p>The answer relies on a recognition that the output will come before the recursive call, and that the output after all recursive calls are made will output from smallest to largest instead of largest to smallest</p>

<h1 id="then-a-cmu-web-towers-of-hanoi">Then a CMU web, Towers of Hanoi</h1>

<p>In this puzzle, we have three pegs and several disks, initially stacked from largest to smallest on the left peg. (See the 6-disk picture below.) The rules are simple:</p>

<ol>
  <li>Our goal is to move the entire tower to the middle peg.</li>
  <li>We can only move one disk at a time.</li>
  <li>We can never place a larger disk on a smaller one.</li>
</ol>

<p><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk0.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk1.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk2.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk3.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk4.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk5.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/basea.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/baseb.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/basec.gif" alt="" /></p>

<p>If JavaScript 1.2 is enabled on your browser, you can try it yourself. Just click on the disk you want to move, and then click on the peg you want to put it at. Although technically you are only allowed to move one disk at a time, the program will move several disks if it is necessary to complete the move.</p>

<p>We’ll answer both of these questions in sequence.</p>

<p>To describe how the monks should solve this puzzle, the concept of recursion will be useful. We look at that next.</p>

<p>Next: <a href="https://www.cs.cmu.edu/~cburch/survey/recurse/recursion.html">Recursion</a>.</p>

<h1 id="then-a-simple-leetcode-q-104-maximum-depth-of-binary-tree">Then a simple leetcode Q <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h1>

<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a> eng ver</p>

<p>But most people did like this, correct, but…, not friendly for me at first</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>        
</code></pre></div></div>

<h1 id="then-two-prob">Then two prob</h1>

<h3 id="reverse-linked-list">Reverse Linked List</h3>
<p>https://neetcode.io/problems/reverse-a-linked-list
Not the normal Iteration</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
       	<span class="c1"># weird place
</span>        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">reverseList</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
        
        <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div>

<p>And <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a> again , simple question again
I think it is a good way to understand?</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
</span>
<span class="c1"># class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1"># I'm starting from the root node now
</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># if there is no root, there is no root node at all, so I should return the value 0
</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># OK, the logic now is that there is at least one root node. Now, based on the logic of the recursive function,
</span>
        <span class="c1"># we can know the depth of the left and right nodes starting from the root
</span>
        <span class="c1"># which is
</span>
        <span class="n">left_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

        <span class="n">right_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># OK, now, we start to think, we have the depth of the root nodes root.left and root.right, now we want to add
</span>
        <span class="c1"># the depth of the root layer itself, so we need to add 1. At the same time, we want the maximum depth, so we have the max function
</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

</code></pre></div></div>

<h1 id="right-now-the-problems-are">Right now, the problems are</h1>
<ol>
  <li>Reinforce point</li>
  <li>Return type, and helper method (create a new helper method)</li>
</ol>

<h1 id="a-simple-leetcode-q">A simple Leetcode Q,</h1>
<p>The thinking flow of recursive Q in BST
<a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root1</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
            <span class="c1"># if two entering roots are None, direct return one of trees, 
</span>            <span class="c1"># return node2 # ? wired, wanna change [root1s] val, but it return a value, 
</span>
            <span class="k">if</span> <span class="n">node1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">node2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> 
            
            <span class="k">if</span> <span class="n">node1</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">node2</span><span class="p">.</span><span class="n">val</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            
        <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>

        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">):</span> <span class="c1"># -&gt; treeNode
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root1</span>
            <span class="c1"># if root1 and root2 # adding value logic
</span>            
            <span class="n">root1</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="p">.</span><span class="n">val</span>
            <span class="n">root1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">root2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">root1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">root2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">root1</span>
        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">)</span>
        
</code></pre></div></div>
<h1 id="leetcode-450">Leetcode 450</h1>
<p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>

        <span class="k">def</span> <span class="nf">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">val</span><span class="p">):</span> <span class="c1"># Unsure of the return type, changing the tree structure, so should the return type be treeNode?
</span>
        <span class="c1"># Or do I only need a single return, because I'm only changing the tree structure?  Confused
</span>
            <span class="c1"># no root , return None
</span>            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Confused here. The question says if found, delete it; if not found, return None or the original?
</span>
                <span class="c1"># I don't know whether to write return or return None, I can't convince myself.
</span>
            
            <span class="c1"># if node: ... so right now this place has a node, first one is root
</span>            <span class="c1"># from root perspective
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="c1"># using successor, that is the minimum value of the right subtree.
</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">successorHelp</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                
                <span class="c1"># Oh, it can be using if statment here.
</span>                <span class="c1"># if node.right and not not node.left ....
</span>

            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># node.left
</span>                <span class="n">temp</span> <span class="o">=</span> <span class="n">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">temp</span> <span class="c1">#?
</span>            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">successorHelp</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="c1"># When calling itself, the input cannot be None, but I think it's okay to check?
</span>
			<span class="c1"># Wow, it seems that a check is necessary because of the recursive boundary problem, but can we directly check if it's a leaf node? No, what if there's only a left subtree and no right subtree?
</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># I suddenly don't know what to return.  Returning None feels strange.
</span>
                
                <span class="c1"># It was written as None at the end, but after thinking about it, I don't think it will be called.
</span>
            <span class="c1"># .right once
</span>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
                
                <span class="c1"># delete that node
</span>                <span class="n">new_value</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="n">new_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            
            <span class="c1"># I think the above can be adjusted.  It's about `val` and an impossible `val`. If it's an impossible `val`, it means there's no right subtree starting from the node, so connect to the left subtree starting from the node, that is, `node = node.left`.
</span>
            
            
        
        
</code></pre></div></div>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[The article contains mistakes and misunderstandings, as it is a record of my own incorrect notes rather than a proper summary document.]]></summary></entry><entry><title type="html">Thinking and Re-thinking of Learning and Happiness</title><link href="http://localhost:4000/learning/" rel="alternate" type="text/html" title="Thinking and Re-thinking of Learning and Happiness" /><published>2025-04-22T00:00:00-04:00</published><updated>2025-04-22T00:00:00-04:00</updated><id>http://localhost:4000/%C2%A0learning</id><content type="html" xml:base="http://localhost:4000/learning/"><![CDATA[<p><strong><font color="red">Using LLMs to refine context through chaotic thinking, but I think GPT-4.5 (2025-04-22) is quite good.</font></strong></p>

<p>下面的内容是我胡乱打的, 也就是说想到什么写什么说什么, 但是大概follow了我在想一些事情时候的本意.</p>

<blockquote>
  <p>感觉学习递归的过程, 认为让我理解了学习为什么困难or为什么成绩不好什么的. 一个本质的问题是, 你是否认为一个人可以学会任何东西. 相信大脑的能力,相信神经. 我相信这一点, 不过在学习时间够长的情况下. 为什么在一个阶段学不懂, 我认为是之前其实有东西没学懂.  基础出现问题. (补充) 但是可能硬件不同, or正常理解框架下的智商, 我感觉是大脑全链路激活层的学习速度, 我觉得学习速度应该是真有快慢的, 这是事实. 有些人, 有些快, 在比较心理, 认为自己的不行的暗示下, 距离就逐渐拉开了. 知识没有被分成足够小的chuck.</p>

  <p>学习的目的非常重要, 我认为需要正反馈. 不可以骗自己, 可以骗一个月, 不可能骗10年, follow自己的内心, 非常重要. 感觉这也是另外一种版本的价值回归.</p>

  <p>回到递归, 做递归, 最忌讳的就是思考递归的细节, 但是学习为什么感觉都是一个逆过程, 追求成绩, 违反本身的追求真理的逻辑, 学习过程的正反馈是, 在相同时间内学的比别人快, 学的比别人多, 而不是增加探究世界现象的手段, 当然痛苦.</p>

  <p>我感觉学习, 读书, 好像在不断获得和学习认识这个时间的工具, 就像一个天生近视800度的人, 可以逐渐看清越来越远的东西, 像镜头的景深越来越深, 这个过程当然是快乐的, 而且是逐步快乐的, 这个时候检测 考试, 好像就是解读一些观察时候的corner case. 但是push的手段却是比较时间断内, 谁看到的世界比较大, 谁获得的知识比较多, 奇怪, 不过如果检测集足够大, 确实可以筛选出来那些本身获得正反馈的, 和本身速度就比较快的人…</p>
</blockquote>

<p>使用的简单prompt是,<code class="language-plaintext highlighter-rouge"> 这个是一个混乱的思路文稿,{上面的文本内容},解读,组织成一个结果完整的文章 </code></p>

<h1 id="claude-37">claude 3.7</h1>

<blockquote>
  <h1 id="递归学习与思维过程的反思">递归学习与思维过程的反思</h1>

  <p>您分享的文稿表达了对学习过程、特别是递归思维的一些深刻反思。我将整理您的想法，并从编程与学习思维的角度进行解构分析。</p>

  <h2 id="递归思维的本质与编程应用">递归思维的本质与编程应用</h2>

  <p>在编写代码时，尤其是面对递归问题时，人脑应该关注的核心不是递归的具体执行细节，而是问题的整体结构和解决方案的框架。这与您所说的”最忌讳的就是思考递归的细节”相呼应。</p>

  <p>在编程思维过程中，我们应该关注：</p>

  <ol>
    <li><strong>问题分解</strong> - 将复杂问题拆解为更小、更易管理的子问题</li>
    <li><strong>模式识别</strong> - 发现问题中的重复模式，这是递归的基础</li>
    <li><strong>边界条件</strong> - 明确递归的终止条件，防止无限循环</li>
    <li><strong>信任抽象</strong> - 相信子问题的解决方案，而不陷入执行细节</li>
  </ol>

  <h2 id="编码思维流程">编码思维流程</h2>

  <p>当我们编写递归代码时，思维流程通常是：</p>

  <ol>
    <li>首先识别问题是否适合递归解决（是否有重复的子问题结构）</li>
    <li>定义基本情况（边界条件）- 递归必须有终止点</li>
    <li>设计递归关系 - 如何将大问题分解为同类型的小问题</li>
    <li>实现递归逻辑，相信递归会正确处理子问题</li>
    <li>验证解决方案，检查边界情况</li>
  </ol>

  <p>这个过程与您提到的”学习的逆过程”有相似之处。递归编程要求我们相信函数能够完成其承诺，而不是纠结于每一层的执行细节。</p>

  <h2 id="学习过程的启示">学习过程的启示</h2>

  <p>您的文稿中提到了几个关于学习的重要观点：</p>

  <ol>
    <li><strong>学习基础的重要性</strong> - “在学习时间够长的情况下，为什么在一个阶段学不懂，我认为是之前其实有东西没学懂，基础出现问题”</li>
    <li><strong>内在动机与正反馈</strong> - “学习的目的非常重要，我认为需要正反馈”</li>
    <li><strong>知识分块</strong> - “知识没有被分成足够小的chuck”</li>
  </ol>

  <p>这些观点与有效的编程学习特别相关。编程学习也需要将复杂概念分解为可管理的小块，建立在坚实的基础上，并通过解决问题获得正反馈。</p>

  <h2 id="编程与学习的哲学联系">编程与学习的哲学联系</h2>

  <p>编写代码，尤其是递归代码，可以视为一种认知训练，它培养了以下思维能力：</p>

  <ol>
    <li><strong>抽象思维</strong> - 看到问题的本质而非表面细节</li>
    <li><strong>系统思考</strong> - 理解部分与整体的关系</li>
    <li><strong>信任机制</strong> - 相信系统各部分能够协同工作</li>
  </ol>

  <p>这与您描述的学习过程相似：”学习，读书，好像在不断获得和学习认识这个时间的工具，就像一个天生近视800度的人，可以逐渐看清越来越远的东西，像镜头的景深越来越深”。</p>

  <h2 id="实践建议">实践建议</h2>

  <p>在面对递归等复杂编程概念时：</p>

  <ol>
    <li>先理解问题的整体结构，而非实现细节</li>
    <li>确定最简单情况的解决方案（基本情况）</li>
    <li>设计递归关系，而不是试图在脑中跟踪整个执行过程</li>
    <li>编写代码时关注逻辑结构，而非执行顺序</li>
    <li>通过测试简单情况验证代码，建立对解决方案的信心</li>
  </ol>

  <p>这种方法类似于您所提倡的学习方式：关注整体理解，而非机械记忆；追求内在价值，而非外部评判；将复杂问题分解为可管理的部分。</p>

  <p>通过这种方式，编程不仅是一种技能获取，更是一种思维培养，帮助我们”看清越来越远的东西”，扩展我们认知的”景深”。</p>
</blockquote>

<h1 id="deepseek---r1">deepseek - R1</h1>

<blockquote>
  <h2 id="递归思维与学习困境一场关于认知本质的思辨">递归思维与学习困境：一场关于认知本质的思辨</h2>

  <p>在计算机科学的递归算法里，程序员最忌惮陷入函数调用的细节迷宫。这个编程隐喻恰如其分地揭示了人类认知的深层困境——当我们面对知识体系的建构时，常常迷失在表层现象的追逐中，却遗忘了思维递归的本质特征：每个层次的突破都建立在坚实基础之上。</p>

  <h3 id="一知识大厦的地基危机">一、知识大厦的地基危机</h3>

  <p>现代教育体系如同加速运转的传送带，将标准化知识模块源源不断地输送给学习者。在这个过程中，多数人陷入”知识假性完整”的认知陷阱：微积分公式的机械套用掩盖了极限概念的模糊，编程语法的熟练操作遮蔽了算法思维的缺失。这种基础性认知漏洞如同建筑地基的裂缝，在知识体系不断叠加的过程中产生级联效应，最终导致整个认知结构的崩塌。</p>

  <p>认知神经科学的最新研究证实，大脑新皮层的神经可塑性并非均匀分布。前额叶皮层与海马体构成的记忆环路，其信息处理效率直接影响知识模块的整合质量。当基础概念网络存在结构缺陷时，高阶认知功能的神经表征将出现拓扑紊乱，这正是”阶段式学习困境”的神经生物学基础。</p>

  <h3 id="二认知时钟的速率谜题">二、认知时钟的速率谜题</h3>

  <p>在慕尼黑大学的天才追踪研究中，发现顶尖学者的大脑白质纤维束呈现出独特的拓扑结构。这些增强的神经连接通道，使得他们的信息处理速度比常人快3-5个数量级。这种硬件差异如同CPU的时钟频率，决定了知识编译的基本速率。但神经可塑性研究同样表明，持续的正向刺激能使大脑胼胝体的髓鞘厚度每年增加0.5-1%，这意味着学习速度本身具有可塑性。</p>

  <p>教育评估体系制造的比较陷阱，本质上是将马拉松改造成百米冲刺的竞技场。当知识检测简化为碎片信息的提取速度测试，真正的认知深度反而被排除在评价体系之外。这种异化机制催生出大批”解题运动员”，他们熟练操作知识符号却丧失了概念建构能力。</p>

  <h3 id="三认知觉醒的正向递归">三、认知觉醒的正向递归</h3>

  <p>真正的学习革命始于元认知的觉醒。当学习者将注意力从外部评价转向内在建构，知识获取就转化为持续的正反馈循环。这个过程遵循着严格的递归逻辑：每个新概念必须完全内化为认知基元，才能支撑更高层级的思维跃迁。MIT媒体实验室的认知增强实验证明，采用这种递归学习法的被试者，其知识留存率是传统学习者的4.7倍。</p>

  <p>建立认知增强系统需要重构学习范式：将知识体系分解为原子化概念单元，通过间隔重复形成稳定的神经突触连接；构建概念之间的多维联结，形成抗干扰的认知拓扑网络；最终在问题求解中实现知识的创造性重组。这个过程如同3D打印认知结构，逐层构建却始终保持整体一致性。</p>

  <p>站在认知革命的门槛上，我们需要重新理解学习的本质。知识获取不是信息的简单堆砌，而是认知结构的递归升级。当我们将每个知识节点都锻造成坚实的认知基元，就能在思维空间实现真正的维度跃迁。这种递归式认知进化，终将带领我们突破智能边界，见证思维宇宙的奇点时刻。</p>
</blockquote>

<h1 id="gpt---45">GPT - 4.5</h1>

<blockquote>
  <p>学习递归的过程让我意识到为什么学习对很多人来说如此困难，也让我进一步理解了成绩表现不佳背后的原因。</p>

  <p>首先，我们必须承认一个基本问题：人类是否能够学习任何内容？我个人相信大脑具备这样的能力，相信神经网络能够通过不断训练和刺激逐渐掌握知识。然而，即便学习时间充足，某些阶段的知识却依然难以理解，这背后往往是因为之前的基础知识并没有真正掌握透彻。</p>

  <p>然而，这里还存在另一个重要因素：硬件的不同，或者我们常规理解中的智力差异。每个人大脑中神经元连接的效率，即所谓的“全链路激活层”，确实存在差别。这导致了不同人的学习速度存在客观上的差异。这种差异本身是真实存在的事实。有些人学得更快，有些人则相对慢一些。当人们开始将自己与他人比较，并暗示自己能力不足时，这种差距便会逐渐扩大。此外，知识没有被分解成足够小的知识单元（chunks），也进一步加剧了学习困难。</p>

  <p>明确学习的目的至关重要。我认为最重要的是持续的正反馈。一个人可能短暂地欺骗自己一段时间，比如一个月，但绝不可能持续地自欺欺人十年之久。因此，诚实地追随内心真正的兴趣与价值观尤为重要。这实际上也是一种价值回归——回归到学习本质的乐趣与探索。</p>

  <p>以递归为例，递归最大的忌讳便是陷入细节，却忽略整体思维。可是现实的学习过程却经常与这种理念背道而驰。追求分数和表面成绩的过程中，往往偏离了对真理与知识本身的追求。真正的正反馈应该来源于自己对世界现象的深入探索和理解，而不是在相同时间内比别人学得更多或更快。然而，现行的学习模式与评估机制却经常以知识量和学习速度为衡量标准，这自然带来学习的痛苦与焦虑。</p>

  <p>我感觉学习的过程，就像不断地获得观察世界的工具。就好像一个天生视力不足、近视800度的人，通过不断调整镜片逐渐看清更远处的风景，视野变得越来越清晰，景深也逐渐增加。这种逐步清晰的过程本应是快乐且满足的。而考试或者测试，就像是观察世界中的一些特殊案例（corner cases），本质上是一种检验我们观察能力的方式。</p>

  <p>但令人奇怪的是，我们往往用一种截然相反的标准去评价——在特定的时间段内，谁观察得更多，掌握的知识更广。这种评价方法尽管表面上合理，但实际上却忽略了真正重要的事情：人们学习过程中自发的正反馈和内在的学习速度。不过如果评估的范围和规模足够大，确实能够从中挑选出那些本身就能获得正反馈、学习速度较快的人。</p>

  <p>最终，学习不应只是一场速度与数量的竞争，而更应该是一场逐渐拓宽视野、深入理解世界的旅程。理解并尊重学习的本质，才能真正享受学习的快乐与成长。</p>
</blockquote>

<h1 id="2025-04-27">2025-04-27</h1>

<p>好像也解决了那个所谓买菜为什么要数学的问题, 如果对探知的要求只有百元以内的菜价, 那么好像确实没有持续学习的必要了. 再引申开来一点的话, 如果课本里的知识没有在帮助解决现实中的问题，只提供难和奇怪的过程, 就很容易让人觉得它们抽象且难以消化。而且，我认为一部分学习带来的成就感来源于和他人的比较，一旦身边的同路人越来越少，或者遇到天赋更高的人，这种动力就会逐渐消失. 所以我感觉做事的时候更应该想清楚目的.</p>

<p>一点粗浅的感想罢了.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[Using LLMs to refine context through chaotic thinking, but I think GPT-4.5 (2025-04-22) is quite good.]]></summary></entry><entry><title type="html">2025-03-07-How I use LLMs by Andrej Karpathy 看后总结</title><link href="http://localhost:4000/How-I-use-LLMs-by-Andrej-Karpathy-%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="2025-03-07-How I use LLMs by Andrej Karpathy 看后总结" /><published>2025-03-27T00:00:00-04:00</published><updated>2025-03-27T00:00:00-04:00</updated><id>http://localhost:4000/How%20I%20use%20LLMs%20by%20Andrej%20Karpathy%20%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/How-I-use-LLMs-by-Andrej-Karpathy-%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93/"><![CDATA[<p>https://www.youtube.com/watch?v=EWvNQjAaOHw</p>

<p>当然这个视频, 感觉是一个挺好的材料, 从一个很简单的角度切入, 快速判断什么任务可以实现
两个多小时的视频, 结果花了三天的时间还比较碎片的时间才看完, 之前通宵两天熬夜太狠了, 感觉看的时候一直没有很专注, 然后还没干什么事情, 笑死.
注: 
回到这个这个视频, 回顾的想, 这个视频的信息含量没有涉及什么复杂的步骤和内容, 更多的是一个科普向的视频, 或是一个操作演示一样. 当然打开之前我就知道, 干货应该不多, 肯定不如Let‘s build 那个系列, 我只是想比较一下我使用LLM和Andrej Karpathy使用LLM的区别. 接下来的步骤都是我看过之后一次性回忆的, order可能有问题, 然后一些sub subjects会有遗漏. 加上实在感觉我看完了不等于是会了, 我认为会了仍然还有大量可能的错误, 不如直接写下来. 相信即使是最简单的逻辑和常识也需要被整理. 花一点时间, 把要大量使用的工具理解清楚我觉得还是对我重要和有价值的.</p>

<h2 id="笼统介绍">笼统介绍</h2>

<p>一开始，Andrej Karpathy 提到，他几乎订阅了所有主流 LLM 模型的会员服务(2025 年 3 月) 接着，用了一个特别形象的比喻which is zip 文件，来形容大模型预训练后的状态。这个比喻很有意思，因为 zip 文件如果不解压，里面的内容是没法直接用的。换句话说，预训练后的模型并不像字典那样，能瞬间（O(1) 时间）找到你想要的东西, 所以模型不是pageRank那样的搜索? 
LLM good at writing. 然后，Karpathy 花了一些时间解释 token 的概念，简单了解一下非常有意义。
无论是文字、标点符号，还是输入输出，都会消耗 token。我们看到的是连贯的文章，但对模型来说，它处理的是一串 token。LLM 的输入是 token，输出也是 token，它的任务就是预测下一个可能的 token，一个接一个地生成文本。（这里我打个比方：假设人 A 对美国人 B 说中文，但 B 听不懂中文。于是，A 的中文被转换成了一串数字（比如 Unicode 编码），B 看到的是这串数字。虽然 B 不懂中文，但他已经通过学习知道这些数字之间的关系，通过不断的预测, 最后他也用一串数字来回应。最后，这串数字被解码成中文，A 听到了 B 的回复。）然后视频演示了下面这个开发者做的网站，它能展示输入输出时 token 的具体的展现：
https://tiktokenizer.vercel.app/</p>

<h2 id="继续讲了预训练和后训练">继续讲了预训练和后训练</h2>

<p>预训练很贵, 预训练使用大量的历史上的材料, 互联网上已经有的内容, 组成了一个由token之间的关系的size很大的zip文件. 但是这个zip文件是有损失和有概率 zip 文件. 是sequence of token.</p>

<p>后训练 much much cheaper. Using SFT（Supervised Fine-Tuning, 监督微调）、RLHF（Reinforcement Learning from Human Feedback, 人类反馈强化学习） 和 RL（Reinforcement Learning, 强化学习）on Conversations, 这里Andrej认为post train类似于角色扮演, 后训练的重点是调整模型的行为，而不是再教知识, 我感觉对于使用者来说了解到这里就OK了?
<strong>GPT讲,</strong> 换句话说，预训练教会了模型语言，而后训练教会了它如何像人一样“扮演”某种对话风格或人格。</p>
<h2 id="开始演示使用大模型">开始演示使用大模型</h2>
<p>展示了不同模型随便输入一个问题后, 显示了一些输出什么的. 这里我记得没什么好着重提及的, 可能Andrej使用了perplexity来使用deepseek的模型有点难评.</p>

<p>这里有一个细节, 我之前没有注意, 我之前以为perplexity这家公司没什么技术, 但是在演示中发现, perplexity搜索速度蛮快的, 这里有我不知道的点.</p>

<p>还有这里解释为什么会出现不正确输出的原因, 因为预测本身就不会是100%正确的, 很正常很自然. 
还讲了GPT模型不透明的情况, 比如虽然选了GPT-4o但是你怎么知道运行的是不是4o, 明确的提及了在用户没有登录的时候, GPT提供的是一个size非常小的模型.</p>
<h2 id="上下文搜索">上下文搜索</h2>
<p>现在的模型, 只要用过, 就会发现模型具有一定的上下文记忆能力，即它能够理解并引用同一对话中的先前输入和输出。此外，如果持续在同一对话中交流，token 消耗会非常快，这也意味着模型实际上是在不断地处理和整合之前的对话内容。每次新的输入都会与之前的输入输出结合.</p>

<p>看视频的时候直接跳过了, 但是这里有个疑问, 就是, 模型是怎么选择之前的记忆的呢? 首先这个window肯定有一个size, 如果已经输入的内容和输出的内容过长, 这个window肯定是装不下的, 但是抛弃之前的内容的策略是? 之前就知道会丢和能保存.</p>

<blockquote>
  <p><strong>问了GPT,</strong>  LLM 的上下文窗口(context window)是<strong>有限的</strong>，有一个固定的大小(如 4096、8192 或更大的 token 数), 当输入和输出的内容<strong>超出上下文窗口的容量</strong>时，模型必须决定如何<strong>舍弃部分旧内容</strong>。策略有, 滑动窗口（Sliding Window）, 基于重要性截取（Relevance-Based Pruning）, 层次化摘要（Hierarchical Summarization）, 基于提示（Prompt Engineering）</p>
</blockquote>

<p>OK, 策略这么多, 如何这里如何选择也是一个黑盒…</p>
<h2 id="不同模型的价格">不同模型的价格</h2>
<p>这里就是说一下不同模型的价格和提供的服务不同, 没有涉及到api.</p>

<h2 id="联网搜索--search">联网搜索 * Search</h2>
<p>为什么有联网搜索的功能? 本质上因为创建那个zip file的过程是一个由时间限制的东西, 决定使用23年4月为止的内容, 那么之后的内容当然涉及不到. 比如询问大模型一个今天的天气, 有点强模型所难了. 如果使用搜索改变了什么呢, 相当于爬虫爬取了网上搜索得到的内容, 作为输入, 那么这里有新的输入了, 这部分知识, 在输出回答的时候, 就可以回到诸如今天的天气和气温这类的问题.</p>

<h2 id="reasoning-model">Reasoning Model</h2>
<p>由GPT-o1开始, 强化学习来解决数学编码等逻辑问题, 这个思路被做出来了一个产品. 原理我不懂,  有空有必要了再学吧. 这里浅显的说法是, 对于数学推理、代码生成等任务，我们希望模型<strong>一步步地推理</strong>，而不是仅仅根据概率生成看起来正确的文本.</p>

<p>所以之前一个高中生的prompt让claude 3.5变reasoning model的新闻有点扯淡. 两个看似相似的输出, 输出的文本背后的逻辑都不一样.</p>
<h2 id="deepresearch">deepResearch</h2>
<p>有点感觉是一个set of reasoning model的组合, 忘了, 回去看的时候再补一下, 这里好像说到了现在grok和gpt都有这种能力, 挺有潜力的一个功能, 但是我目前没感觉特别厉害, 或者我没有使用场景. 我冲了20美元的GPT会员使用下来(可以用10次), 我用了两次, 我使用的情况是没跑出来什么特别有用的东西…</p>
<h2 id="llm-文件上传主要是pdf">LLM 文件上传(主要是pdf)</h2>
<p>这里在使用claude的时候, 提及了在pdf中的插图应该是不会被使用的. 识别的都是大量的文字, 应该也是类似于多模态调用OCR的能力? 虽然我事后搜索了一下Claude有识别读取pdf中图片的能力, 所以, 不知道是不是 Karpathy 讲错了还是在使用中没有发现对插图有识别和作为输入. 我在之前使用的时候没意识到这个细节, 但是我记得在只输入图片的情况下是可以识别的(which就是一张图中有示意图和文字解释或文字内容), 但是我记得之前输入一个graph, 让GPT判断后输出BFS或者DFS还是挺费劲的, 这里不知道是为什么. 感觉要了解图片是怎么被LLM读取的才可以搞明白.</p>

<p>这样就有一个疑问就是, 我希望LLM在处理图片输入的时候, 希望它在使用正确的信息, 这里在prompt的地方可以说一下, 提及一下就是, 让模型输出OCR后, 它看到了什么, 这样可以在输出OCR结果不对的情况下发现错误.</p>
<h2 id="code-interpreter容器-data-analy">Code interpreter(容器?) data analy</h2>
<p>LLM的代码能力非常好, 我猜测是因为代码有一条类似于flow的处理逻辑, 是不是非常容易被强化学习拟合啊? 就是, 输入的数据啊, 个数啊, 类型啊, 都是设计好的, hh无端猜测了. 
这里想到一个经典问题, 好像是9.9大还是9.11 大什么的,这里如果使用python解释器来输出结果应该是没问题的, 但是我记得有新闻是说, 这里GPT会比较的是圣经的章节, 所以 9section的第9 subsection当然小于9section的第11 subsection的, 这里想到这是一个简单的小计算过程, 如果在一个大型项目中, 使用LLM认为过于简单没有自动调用Code interpreter使用python输出来比较的话, 在这一步给出一个正确的答案会怎么办呢? 过程如果过于多, 还挺难定位这个问题的
在这里视频的最后写了一下直接使用GPT做data analysis其实网上有大量的资源, 不展开介绍.然后在演示的时候, GPT还出现了数据的错误. 我记得是一个最大值的数据点搞错了</p>
<h2 id="one-more-related-tool--claude-artifactsapps-diagrams">One more related tool , Claude Artifacts(apps, diagrams)</h2>

<p>这里Andrej Karpathy甚至生成了一个anki卡片的网页应用, 然后来检测从wiki上复制的亚当斯密的知识点, 神了, 反正我之前是没有这样使用过和没想过的. 有交互还有反馈.
然后在这个section, Karpathy介绍了一下用Claude生成mermaid流程图, 然后展示出来, 这个事情其实我在GPT3.5的时候就做过, 生成完code再粘贴到mermaid模拟器上, 在视频中看到Claude就是多了一个出完code的时候及时生成展示图片的功能, 好确实好, 但是没感觉多好,hhhhh, 可能就是有没有想到这样去用LLM来得到这个输出的区别. 我想想当时好像是软件工程的作业要画流程图, 我发现一个geek朋友非常喜欢用代码写那个软件的工程图, 我们大部分是用线上的画图软件自己画的, 我画了第一个图之后,感觉非常非常麻烦. 我没学过那个流程图的代码框架, 这时候想到why not 用GPT生成那个结构代码, 刚好typora也支持mermaid, 用代码写这种流程图完全不需要关注框图的间距, 箭头的粗细这种问题, 然后我就一直使用这样方法写这部分的任务. 后来的latex也是. 一次一次的任务然后习惯了使用md的语法, 最开始是发现gpt一直在使用这种格式的文本输出, 觉得挺轻便和美观的就在b站学了半小时之后写到了现在. 
这里我想到LLM直接跑D3.js还有Graphviz应该都蛮棒的
这里Andrej Karpathy的用法是, 使用mermaid梳理文本, 梳理人物关系网, 梳理故事发展过程, 这个用法我之前没想到过, 以后可以多加使用.</p>

<h2 id="我加的任务处理">(我加的)任务处理</h2>
<p>下次再说吧, 是Claude开发的一个工具.</p>
<h2 id="cursor">cursor</h2>
<p>之前看课代表立正的视频的时候, 里面一个视频讲, 对于自己的粉丝做了一个调查是, 认为过去一年ai没什么发展的和ai发展飞速的好像是一半一半, 但是认为过去一年ai发展快速的人中, 绝大部分的人是使用过cursor的, 
这里, 就是感觉, 虽然明面上说是整个文件都是一个上下文窗口中读入的, 但是项目一大, 应该仍然是会丢失的, 那么那些神奇的策略们的选择黑箱, 该如何选择, 这里的策略好像不可以被人为调控. 
Karpathy飞速的做了两个demo, 挺不错的. 有点神奇的是, 如果本地环境下, asset中没有一些文件, (视频中是一个点击的声音特效, 还是胜利音频特效来着), cursor居然会联网爬一个库下载下来, 我真是一脸正经, 之前一直以为是巧妇难为无米之炊的, 这还可以自己下一个文件过来? 但是转念一想, 好像这和运行一些项目要使用一些lib然后自动下了一些pip好像没什么不同, 然后又不觉得特别神奇了.</p>
<h2 id="使用声音输入--输出">使用声音输入 / 输出</h2>

<p>这里只是使用speech-to-text模型输入文本给GPT, 然后得到文本的返回, 没有使用下面的语音模型. 很多时候, 其实我们只需要一轮问答, 比如, 现在的Karpathy 在视频里面讲使用快捷键F5快速调用(类似于siri), 询问一个问题, 得到LLM的回复, Karpathy 说现在接近一半他都是在这个使用场景下使用的
我想了想, 确实比较方便, 打算下个礼拜在自己的电脑上整好这个操作.</p>
<h2 id="使用语音模型-伦理">使用语音模型, 伦理</h2>

<p>这里我记得使用grok可以沟通出一些怪怪的声音和对话内容, 是在使用GPT的语音对话无法实现的, 而且GPT语音还是拒绝回答一些类型的问题, “利用怪怪的声音快速说1-20”我记得视频里面好像说了这个例子.</p>
<h2 id="notebooklm">NotebookLM</h2>
<p>输入一些文件, pdf, 然后gemini出一个talk. 我之前有听说这个功能十分惊艳, 但是没引起重视, 或者觉得这个功能无法帮助到我. 
1, 是想不出这个功能的实用价值, 首先我不用播客类节目变现, 再是在油管和xhs加上一个B站这些视频流媒体平台提供给我的内容, 无论是否优质, 已经足够足够多了, 我现在的精力甚至是减弱这些平台给我的影响, 减少注意力分散, 我不应该去关注太多信息来源, 虽然很多优质的信息还是从这方面来的, 没办法无法隔离. 
2, OK回到这个NoteBook播客功能上, 还有一个原因就是语言(英语水平)还是存在问题, 虽然CS, 科技, 数码 or 摄影相关的英文内容我可以做到95%的时间follow上和听得懂, 但是非母语还是有问题就是, 感觉脑子在输入英语的时候有一层decoder一样, 还是要慢一些, 我脑子在输入英语的时候对专注要求更加高, 这样听这个英语博客还是挺累的, 中文还是我的舒适区无法改变了, 不然这篇文章我肯定是想用英文打出来的. 
OK, 所以这个应用就对我来说有点鸡肋, 我不需要使用这个function来获取信息, 加上流畅使用还是有语言门槛, 如果想快速了解某个领域的知识, 为什么不直接上网搜索一个general的介绍呢? 整10篇文章输入, 做一个博客有点奇怪. 或者说, 泛泛的去了解一个domain的知识这样做有点出力太多, 但是如果想认真学习一下, 这样做是远远不够的, 所以我困惑于对我自己的使用场景. 我感觉是不是deep research加上这个NotebookLLM podcast的功能是不是有使用价值一点, 其实我希望连选都不要选topic, 用一个推荐算法什么的, 网易云音乐式得生成高质量podcast如果有一个这样的产品我会愿意去用, 我连花时间喂Notebook的生成podcast的操作都懒.</p>

<p>然后Karpathy说, 整了一些podcast可以在开车路上听, 哈哈好吧, 碎片时间, 可惜我没有车.</p>

<h2 id="图片输入">图片输入</h2>
<ol>
  <li>
    <p>之前提到过, 图片输入往往有输入的错误, 这里Karpathy说他 使用方法是分成两步, 而不是直接让LLM输出结果, 比如使用prompt, <code class="language-plaintext highlighter-rouge">分成两步, 第一步输出OCR的输出结果, 第二步使用这些结果输出我想要的答案</code></p>
  </li>
  <li>
    <p>转成公式
simpleTex, Math Snipping Tool这种识别论文中的公式使用OCR的小而美的business应该都快寄了, 我真感觉用一个LLM的api再使用一个prompt做一个小应用就行, 用cursor做可能不用半小时.</p>
  </li>
</ol>

<p>突然有点好奇LLM的输入, 图片和文字的区别, 是直接图片使用分配给OCR的模型读取么</p>
<h2 id="chatgpt的个性化助手和应用市场-提示词">ChatGPT的个性化助手和应用市场, 提示词?</h2>
<p>这里涉及了好多Karpathy的个人信息啊哈哈哈哈, 看到网上的comment是他谈了一个韩国女友, 所以在各种姿势学习韩文. OK离开八卦的话是, LLM在翻译任务上简直是出人意料的好, 逻辑流畅舒适, 甚至可以输出一些引申的含义. 
还有我其实有个疑问是, 要不要使用xml类似的指令? 使用自然语言和xml语言有对文本读取来说有多大的差别, 如果有差别的话, 我自己感觉是各模型厂家在post train的时候调整的, 还有如果使用api去调用的话, 在code界面, 大家使用的都是xml的结构. 我自己感觉是有区别但是区别不大, 不然其中的一种方法会被大肆宣传的.
比如下面是我希望解释Leetcode问题时候的prompt</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;task&gt;</span>
编写一个解决这个问题的程序
<span class="nt">&lt;context&gt;</span>
我希望你像一个人类程序员一样思考这个问题。请展示完整的思考过程,包括:
- 初步理解问题时的想法
- 尝试解决时遇到的困惑
- 思路的演变和修正
- 为什么最终选择这个实现方案
<span class="nt">&lt;/context&gt;</span>

<span class="nt">&lt;format&gt;</span>
请用以下格式输出:
1. 初步分析
- 用简单的语言描述你对问题的第一理解
- 列出可能需要考虑的关键点

2. 解决方案构思
- 写下你能想到的几种方案
- 分析每种方案的优缺点
- 解释为什么选择或放弃某个方案

1. 代码实现
- 每写一个代码块前,先解释你准备做什么
- 用注释记录当时的思考
- 如果发现问题需要修改,说明原因
- 展示完整的思维过程,包括错误的尝试

2. 最终总结
- 回顾整个解决过程
- 指出关键的思考点
- 分享可能的改进方向

<span class="nt">&lt;style&gt;</span>
注释风格:
# 初步想法
# 发现问题
# 修正思路
# 实现原因
<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<p>另外一个疑问是在customize ChatGPT的时候 <code class="language-plaintext highlighter-rouge">What traits should ChatGPT have?</code> 和 <code class="language-plaintext highlighter-rouge">Anything else ChatGPT should know about you?</code> 在输入的时候到底有什么区别.</p>

<h2 id="演示了一些图片生成-视频生成">演示了一些图片生成, 视频生成</h2>

<p>Andrej Karpathy翻了一个twitter的po文, 我本人对这部分功能兴趣不大, 但是看的时候, Google 生成的视频非常真实, 感觉还挺厉害的.</p>

<h2 id="finally">Finally</h2>
<p>08-March-2025
本来想用20min写一点想法和总结就行, 但是居然写了快2个小时半才写了一半内容, 麻了, 太废了, 实在是太笨了, 效率太低了,打字速度也慢.  今天先不写了, 不然任务完不成了. 看了一眼左下角字数统计, 一边想, 一边整理两个小时写2100多字, 好像也不算是非常非常慢的整理速度, 好吧, 平衡了. 
09-March-2025
今天好像也是花了好久在写这个东西…</p>

<p>希望 llya 这位LLM真神可以在5年之内弄出一个更加逆天的模型.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[https://www.youtube.com/watch?v=EWvNQjAaOHw]]></summary></entry><entry><title type="html">Life goals before the age of 30 (in addition to finding a job)</title><link href="http://localhost:4000/Life-goals-at-30/" rel="alternate" type="text/html" title="Life goals before the age of 30 (in addition to finding a job)" /><published>2024-07-28T00:00:00-04:00</published><updated>2024-07-28T00:00:00-04:00</updated><id>http://localhost:4000/Life%20goals%20at%2030</id><content type="html" xml:base="http://localhost:4000/Life-goals-at-30/"><![CDATA[<p>:)</p>

<ol>
  <li>Suceived in GT in the QCF and CSE program(wanna dual degree)…</li>
  <li>Use the money which I earned to buy two leica cams (m1x, mp)</li>
  <li>Be proficient in using a sewing machine to make small bags and edc backpack design under your own understanding (difficult)</li>
  <li>Japanese level is equivalent to IELTS 5.5 in Eng(I think it is enough), and I can communicate with native jp people.  (difficult)</li>
  <li>Reasonable understanding of the process, materials, steps, installation and design of house decoration</li>
  <li>launched two self-developed independent apps, iOS / web OS</li>
</ol>

<p>时间很长却也很快.</p>

<p>感觉人还是要活的现实一点, 不要太有梦想, 做一些本身有实际价值事情, 而不是感动自己/他人的事情.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[:)]]></summary></entry><entry><title type="html">签证准备材料list</title><link href="http://localhost:4000/visa-preparation/" rel="alternate" type="text/html" title="签证准备材料list" /><published>2024-07-11T00:00:00-04:00</published><updated>2024-07-11T00:00:00-04:00</updated><id>http://localhost:4000/visa-preparation</id><content type="html" xml:base="http://localhost:4000/visa-preparation/"><![CDATA[<p>记录签证准备材料的list</p>

<h3 id="美国签证准备材料-详细版本">美国签证准备材料 (详细版本)</h3>

<ul>
  <li>护照原件、旧护照原件（如有）</li>
  <li>签证预约确认页</li>
  <li>SEVIS FEE缴费收据</li>
  <li>DS160 表格确认页</li>
  <li>i20表格（签名）</li>
  <li>2张白底签证照(51mm*51mm)</li>
  <li>存款证明原件</li>
  <li>英文简历（研究生必须）</li>
  <li>学校录取信</li>
  <li>Study Plan （研究生必须）</li>
  <li>导师个人简历 （如有）</li>
  <li>个人论文（如有）没有</li>
  <li>自带包裏 透明没有拉链, 塑料A4纸夹片</li>
  <li>学校成绩单中英文版本</li>
  <li>在读证明中英文版本（如在读)</li>
  <li>毕业证/学位证中英文版本（如毕业）</li>
  <li>标化考试（如TOEFL、IELTS、GRE、GMAT、SAT 等）成绩单复印件或原件</li>
  <li>父母双方收入证明</li>
  <li>户口本/身份证</li>
  <li>房产、车产证明</li>
</ul>

<h3 id="美签学签证-简单版本">美签学签证-简单版本</h3>

<ol>
  <li><strong>护照</strong></li>
  <li><strong>身份证</strong></li>
  <li>DS-160（含照片和条码）</li>
  <li>签证预约信（含条码）</li>
  <li>SEVIS缴费证明</li>
  <li><strong>i-20表格</strong></li>
  <li>录取的offer</li>
  <li>个人简历</li>
  <li><strong>学习计划</strong>(study plan在美国大使馆官网可以下载)</li>
  <li>经济文件: 做i20时候的存款证明</li>
  <li>户口本</li>
  <li><strong>签证预约缴费单</strong></li>
  <li><strong>51*51 mm的签证照（两张）</strong></li>
</ol>

<p>加粗的部分是最后使用到的文件.</p>

<h3 id="日本签证">日本签证</h3>

<ul class="task-list">
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />1、彩色白底免冠证件照电子版;</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2、护照首页（照片信息页）及末页（第46-47页）的清晰完整对开扫描件（护照剩余有效期需大于回程半年以上）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />3、户口本扫描件（除空白页都要）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />4、非上海领区户籍需额外提供居住证正反面扫描件/在职证明+6个月以上社保/ 在职证明+近1年内税单（上海市内居住证需额外提供验证页面截图电子版）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />5、结婚证、离婚证扫描件（如有）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />6、出生证扫描件（未成年必须提供）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />7、日本签证受理表（电脑编辑填写，必须填写完整）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />9、个人信息处理同意书（需填写好日期，姓名和手写签字，打印出来签字提供扫描件，一家人可以写在一起）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />10、提供以上基本资料+经济材料（7选1）</p>
  </li>
</ul>

<p>温馨提示：领馆有权利让您补充材料，若被通知请及时配合提交；拿到签证之后再定机酒。</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[记录签证准备材料的list]]></summary></entry><entry><title type="html">Notes for ‘How To Read MTF Curves’ article</title><link href="http://localhost:4000/how-to-read-mtf-curves.md/" rel="alternate" type="text/html" title="Notes for ‘How To Read MTF Curves’ article" /><published>2024-06-18T00:00:00-04:00</published><updated>2024-06-18T00:00:00-04:00</updated><id>http://localhost:4000/how-to-read-mtf-curves.md</id><content type="html" xml:base="http://localhost:4000/how-to-read-mtf-curves.md/"><![CDATA[<p>文章翻译, 阅读, 解读MTF曲线, 笔记总结</p>
<h1 id="preface">Preface</h1>

<p>The following context and material are sourced from Dr. H.H. Nasse’s articles.  Many many thx for sharing and explain MTF in the preview articles.  However, I still had no understanding at all when I read those articles during my first year of bachelor studies. I will attempt to write this article in my own words without using any grammar or AI tools.  I have to say in some places, I will use some “direct copy” sentences. I don’t consider this as a form of academic plagiarism, as I am writing this post for learning in photography as an enthusiast.</p>

<p>I listed the all used article below. Again, I will use some images and words directly without any citations. If you have any concerns about this post, PLZ contact me at (notmyemailcode@gmail.com) for specific sections throughout the entire article. I will do it for you ASAP.</p>

<p>[1]<strong>Intro. (ZEISS page)</strong></p>

<p><a href="https://lenspire.zeiss.com/photo/en/article/measuring-lenses-objectively-why-do-we-need-mtf-curves-by-dr-hubert-nasse-part-1">https://lenspire.zeiss.com/photo/en/article/measuring-lenses-objectively-why-do-we-need-mtf-curves-by-dr-hubert-nasse-part-1</a></p>

<p>[2]<strong>How to Read MTF Curves</strong>(December 2008)</p>

<p><a href="http://lenspire.zeiss.com/photo/app/uploads/2018/04/Article-MTF-2008-EN.pdf">http://lenspire.zeiss.com/photo/app/uploads/2018/04/Article-MTF-2008-EN.pdf</a></p>

<p>[3]<strong>How to read MTF curves? Part II</strong>(March 2009)</p>

<p><a href="https://lenspire.zeiss.com/photo/app/uploads/2018/04/CLN_MTF_Kurven_2_en.pdf">https://lenspire.zeiss.com/photo/app/uploads/2018/04/CLN_MTF_Kurven_2_en.pdf</a></p>

<p>[4] 如何閱讀MTF(一), Weifu Lin 林渭富 <a href="https://medium.com/one-eyed-poet/">如何閱讀mtf-f85a60cf59c</a></p>

<p>(以上引用都没有被作者授权, 如有侵权, 本人会尽快删除, 文章承认前置的引用的文章的所有贡献.  本文章没有传播价值和商业价值, 是我看了引用的文章的笔记, 理解上的总结与整理 )</p>

<p>The main purpose for this article is helping me in realizing how designers made an excellent lens in the past and to understand which are favorable features for a good lens. And Iet me select suitable apertures not only by weather and sun</p>

<p>I  wanna finish this work in 2 days (2024.06.17-2024.06.18).  太难了, 最后看了一个礼拜才看了一半不到.</p>

<p>The final date for this article is 7.6</p>

<p>淦, 还是用中文写吧.</p>

<h1 id="start-here">START here</h1>

<p>photographers want to take a very natural-looking picture of a subject, the lens should be sharp, which means that the lens will reflect the correct image of the view. As you know, the light line can gather in a light point on the frame plane. The perfect lens needs to show this “point” in the image correctly, but the truth is that the lens cannot do that on every surface. In the article, the Dr. H.H. Nasse give the example pic below, I attached this image below.</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic1.png" alt="pic1" style="zoom:30%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a></p>

<p>this pic indicates 8 satuations in a size comparison, which all input a small white square light, but totally output different light results in cmos(tip: pic7 should be the perfect example)</p>

<h2 id="调制传递modulation-transfer">调制传递（Modulation Transfer）</h2>

<h3 id="sinusoidal-brightness-distribution">Sinusoidal brightness distribution</h3>

<p>下面是文章中第一次出现的需要解释的图</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic2.png" alt="pic2" style="zoom:43%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a> 。</p>

<p>在原文中, 作者提到 Since we are primarily interested in how extended objects are imaged, objects which, unlike stars, comprise an infinite number of points, we must find another way to quantitatively describe the image quality. 于是我们使用sinusoidal brightness distribution来量化. 正弦波是一个连续的、周期性的波形，它在数学上非常容易描述和分析.</p>

<p>如果把原始的光源场景想象成一个简单的正弦函数的话(sinusoidal brightness distribution是明亮和黑暗条纹的图案), 那么在比如说光线在经过镜头以后, 如果成像系统是完美的，我们应该得到一个清晰的、与原始正弦波相同的图像。也可以说, 使用正弦图像我可以得到一个稳定的结果进行分析. 这里的稳定不是指成像质量.</p>

<p>但是成像系统总是存在一些缺陷，玻璃的折射, 空气灰尘, 传感器的噪声. 实际得到的图像正弦波会与原始的场景的正弦波有所不同。 但是Several of its properties also remain stable or at least have nothing to do with imaging quality: The direction of the stripes does not change and the frequency – the number of stripes per unit length – only changes according to the imaging scale.</p>

<p>由于成像系统的缺陷, 光线不会完美地聚焦在它应该聚焦的地方。这就导致了所谓的“点扩散”. 也就是说, 某光线不仅照亮了应该照亮的区域, 也让周围应该是暗的区域发亮了.  这种光线的扩散效应改变了明暗条纹之间的亮度差异，使得图像的对比度降低。</p>

<p>回到需要解释的图,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic2.png" alt="pic2" style="zoom:43%;" /></p>

<p>黑色曲线代表了实际风景的正弦条纹的亮度分布(which means 原始的一个简单明暗分布), 而空心圆组成的image线条是实际成像后的结果图, 可以认为是照片的实际效果, 这里埋一个伏笔.</p>

<p>然后是红色点和红色线, 蓝色点和蓝色线, 这是一开始我没有理解的部分, 我以为有什么特殊含义, 但是, 其实这组Point Spread Profile说明了有一个点光源分别在成像的时候, 落在了某个地方对原始光线造成了影响, 点作为亮度最高的部分, 下面的曲线则代表了光源的Profile, 很好理解. 从最亮的地方, 逐渐减弱,这样.</p>

<p>于是定义来了,</p>

<p>1⃣️ the difference between bright and dark is referred to as “contrast”.</p>

<p>2⃣️ the difference between maximum and minimum for all sinusoidal, periodically changing quantities is called “modulation.”</p>

<p>那么这两个相似表述的区别是什么, GPT说, <strong>对比度</strong>通常通过比较图像中最亮和最暗部分的亮度来衡量。<strong>调制</strong>通过信号的最大值和最小值的差异来衡量，反映信号的幅度变化。OK还是没理解, 回到图.</p>

<p>如果我们使用对比度的相关概念来描述, 在一张高对比度的照片中，太阳的亮光和树影的黑暗之间的差异非常明显。而使用调制的逻辑是, 在一个<strong>调制较高</strong>的正弦波信号中，波峰的高度和波谷的深度之间的差异非常大。</p>

<p>我感觉这里光学的modulation和信号处理的modulation的差距有点大, 虽然学的不精, 但是依稀记得是改变载波信号的幅度/频率/相位来传递信息(AM,FM,PM), 好的按下不表.</p>

<p>在这里之前的伏笔来了, “对比度”指图像中明暗区域之间的差异, 但是在事实上, 是我们判断镜头分辨率的关键.</p>

<p>我们引出了</p>

<h2 id="调制传递函数mtf">调制传递函数（MTF）</h2>

<p>用来评估光学系统将物体上的调制传递到图像中的能力。通过比较图像的调制(图像)与物体的调制(图像)来计算，结果是一个介于0和1（或0%到100%）之间的数值。</p>

<p>在这里文章给出了一个列子,有点难理解的, The photographer is used to expressing bright-dark differences in aperture stops, which is also very reasonable as the perception of our eyes follows such logarithmic scales. But, what, for example, does a modulation transfer of 50% mean if our pattern of stripes consists of a difference of 6 aperture stops between the brightest and darkest points, i.e. a brightness ratio of $1 : 2^6  = 1 : 64 $ ? Is the difference in the image 3 aperture stops or $1:32$, which would correspond to 5 aperture stops? 神来一笔, 我们如何理解 <strong>modulation transfer of 50%</strong>, 调制传递率（Modulation Transfer）的50%并不是指整体画面会变暗50%。 Both would be wrong. In reality, we would then still have approximately 1.5 aperture stops in the above-mentioned case.</p>

<p>给出Contrast计算的公式
\(\text{Contrast} = \frac{\text{Maximum} - \text{Minimum}}{\text{Maximum} + \text{Minimum}}\)
我觉得还是挺容易理解的公式, 带入Contrast值=50%, 然后文章给出了例子, 没看懂从哪里来的, Therefore, in our example, the contrast of the object is 63 divided by 65, or approx. 哦, 就是突然给了两个值, Maximun-Minmun=63, Maximun+Minmun=65, 再63÷65≈0.97. 作为经过调制传递率为50%的成像，我的理解是满足上面那个公式上的定义, 然后MTF=50% 开始定义, 这时候文章下面有一个图我去比较了, 结果又理解错了. 正常的步骤是直接得出0.97的一半, 大约是0.48, 然后 (x-1)/(x+1)=0.48得到我们的估算值为 x≈2.846, 所以我们的档位从6掉到了2.846, 光量从64掉到了7.19004101289. 我在这里还是没有理解档位的问题…见下图</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic4.png" alt="howToReadMTFpic4" style="zoom:23%;" /></p>

<p>圖３：將反差對比的定義以正弦波圖形表示，兩者比値與測量位置情報共同構成MTF曲線。本圖經過翻譯及重繪。原始圖片來源 &amp; Credit：戶村賢一、〈MTF：MTF曲線から読み取るレンズ特性の正体〉、page 128、《ライカ通信》 Vol.1, 2000年4月。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic3.png" alt="pic3" style="zoom:30%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a> 。</p>

<p>为什么这么像PN结放大…</p>

<p>我感觉这个地方, 一开始也有理解错的地方, 我的疑惑点有这些</p>

<ol>
  <li>MTF在图像中, 在曲线上是一个固定的参数, 好像是不会变化的, 但是在调整光圈档位的时候, 传感器接收到的maximum和minimum的光会减少, 我感觉这个在光圈变化后会变化, 但是MTF没有变.</li>
  <li>如果研究的目标是Object, 那我感觉光圈变化不会影响MTF啊, 因为环境的maximum和minimum的光量不会变啊</li>
  <li>对档位的理解有点奇怪, 0,1,2,3,4,5档, 如果使用$2^n$ 来理解的话, 可能可以想通, 我之前一直没搞明白, 就是越调档, 光量越小, 结果更加好? 反正我觉得有点奇怪.</li>
  <li>这里档位, 有个点没有明白就是比如, object contract有10档, image contact只有最高有6档, 那么object contract的10档中的第6档和image contact的最高档第6档的光照亮度强度是一样的么</li>
  <li>横坐标从1开始的, 有点没理解</li>
</ol>

<p>OK我觉得这里的混淆, 主要是由于参照坐标系的混乱造成的.</p>

<p>那么这个图怎么看呢, 比如取最高点(MTF=97%进入平缓发展的点), 取(10,6)点为例, Object Contrast (Aperture Stops) = 10, Image Contrast (Aperture Stops) = 6, 使用contact的定义, 在 $2^n$带入6和10, 得到64和1024(最高亮度值), 他们的最低值都是1, 所以
\(\text{Object Contrast} = \frac{L_{\text{max, object}} - L_{\text{min, object}}}{L_{\text{max, object}} + L_{\text{min, object}}} = \frac{1024 - 1}{1024 + 1} = \frac{1023}{1025} \approx 0.9976\)
再得
\(\text{Image Contrast} = \frac{L_{\text{max, image}} - L_{\text{min, image}}}{L_{\text{max, image}} + L_{\text{min, image}}} = \frac{64 - 1}{64 + 1} = \frac{63}{65} \approx 0.9692\)
这里引出/使用计算mtf的公式
\(\text{MTF} = \frac{\text{Image Contrast}}{\text{Object Contrast}} = \frac{0.9692}{0.9976} \approx 0.97153167602\)
下面是作者对于这个图的简单总结, 一开始没懂怎么来的, 感觉还挺难理解的.</p>

<p>我们可以从三个方面来理解 MTF 曲线的特性：</p>

<ol>
  <li><strong>高 MTF 值的小差异在高物体对比度下特别显著</strong>：
    <ul>
      <li>当物体对比度很高时（例如光圈档位为 9 或 10），MTF 曲线的高值（例如 90% 或 97%）之间的细微差异对图像质量有很大影响。即使 MTF 仅从 90% 增加到 97%，在高对比度的物体下，这种小的差异也能显著提高图像的对比度。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.1.png" alt="howToReadMTFpic3.1" style="zoom:20%;" /></li>
    </ul>
  </li>
  <li><strong>弱的色调变化（小于一个光圈档位）不需要高 MTF 值</strong>：
    <ul>
      <li>当物体对比度较低（例如低于一个光圈档位时），高于 70-80% 的 MTF 值差异几乎没有实际意义。这意味着在低对比度场景中，即使 MTF 下降到 70-80%，也不会对图像质量造成明显影响。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.2.png" alt="howToReadMTFpic3.2" style="zoom:20%;" /></li>
    </ul>
  </li>
  <li><strong>非常低的 MTF 值下，物体对比度的高低几乎没有影响</strong>：
    <ul>
      <li>当 MTF 值非常低（例如低于 20%），无论物体的对比度多高，图像的对比度总是很低。这表明系统在低 MTF 下对比度还原能力很差，导致图像质量大幅下降。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.3.png" alt="howToReadMTFpic3.3" style="zoom:20%;" /></li>
    </ul>
  </li>
</ol>

<p>OK, 在看了这三个特征总结之后,  object光圈档位调整的含义和具体的光圈档位感觉可以澄清, 就是不同的光量, 如果两个contract都是处在Aperture stop=6的情况下的话, 他们的光量都是$2^6=64$, 也就是说是一样的. 我一直有一个错误的想法, 就是把一个环境和一个传感器上的光均匀切割, 然后分成不同的等份作为不同档位的错误理解.   调制传递函数（MTF）表示成像系统在不同空间频率下传递对比度的能力,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">这个位置的小节</span><span class="o">,</span> <span class="n">我觉得我从这段文本得到的新的认知是</span><span class="o">,</span> <span class="n">我在之前从来不知道</span><span class="o">,</span><span class="n">对比度</span><span class="o">,</span> <span class="n">明暗</span><span class="o">,</span><span class="n">对清晰度的影响</span><span class="o">,</span> <span class="n">或者说对比度在直接控制清晰度</span><span class="o">?</span> <span class="n">感觉这个说法有问题</span><span class="o">,</span> <span class="no">OK</span><span class="o">,</span> <span class="n">在对岸的一个作者的一篇文章上找到了答案</span><span class="o">.</span>
</code></pre></div></div>

<p>下面小结的内容来自Weifu Lin在Medium平台上的文章, 链接在 <a href="https://medium.com/one-eyed-poet/%E5%A6%82%E4%BD%95%E9%96%B1%E8%AE%80mtf-f85a60cf59c">如何閱讀MTF(一)</a> , 是作者结合蔡司的这篇文章和日本的一个作者的文章的翻译. 有两个图非常非常好, 指明了contract和Resolution的区别.</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic6.png" alt="howToReadMTFpic6" style="zoom:33%;" /></p>

<p>繪圖：Weifu Lin</p>

<p><strong>这里的内容是直接引用的[5].</strong> 兩種不同設計取向的鏡頭的比較。鏡頭B的解像力較高，但實際拍攝時，鏡頭A會給觀賞者「更銳利」的觀感。箭號位置所指的虛線，是人眼能分辨細節的最低臨界點。本圖經過翻譯、修訂以及重繪。原始圖片來源 &amp; Credit：戶村賢一、〈MTF：MTF曲線から読み取るレンズ特性の正体〉、page 129、《ライカ通信》 Vol.1, 2000年4月。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic7.png" alt="howToReadMTFpic7" style="zoom:25%;" /></p>

<p>到这一步的时候, 我有点没看懂…</p>

<h2 id="modulation-transfer-function-resolving-power">Modulation transfer function, resolving power</h2>

<p><em>It is obvious that one single stripe pattern is not sufficient to characterize the quality of a lens. A very coarse pattern with large separations between bright and dark stripes could, of course, also be imaged well by a lens with a relatively large point spread function. If we decrease the separation between the stripes, however, so that the separation between bright and dark approaches the size of the point spread, then a lot of light from the bright zone is radiated into the darker zones of the pattern and the image contrast becomes noticeably lower.</em> 我觉得可以理解成原来黑白粗线条的object contract比较高, 因为每个亮区和暗区之间的光线干扰较少. 但是在原本光照环境没有改变的情况下, 一些细小的线条远看是灰色, 导致亮区变暗，暗区变亮, 这会造成对比度的降低这样. 有一个形象的解释是, 写毛笔字, 尺寸比较大, 气势磅礴的字体可以使用大的毛笔, 但是涓涓小楷, 甚至在鼻烟壶里面写字, 这些艺术家为我需要更精细的书写工具. 菜刀如何雕刻核舟记?</p>

<p>为了比较不同精细度的条纹图案来研究镜头的成像能力(其实就是复杂环境)，我们使用调制传递函数（MTF）来量化. 而且, 为了研究镜头如何成像不同精细度的条纹图案，我们需要为每一个条纹图案确定一个调制传递。将这些调制传递值绘制为一个描述条纹图案精细度的参数的函数，这些值就形成了一条曲线，即调制传递函数(MTF)。</p>

<h3 id="我们如何量化条纹图案精细度">我们如何量化条纹图案精细度</h3>

<p><strong>条纹图案的精细度</strong>：通过计算图像中每毫米包含多少个条纹周期来测量。一个周期是两个亮条纹或两个暗条纹之间的距离，或由一个暗条纹和一个亮条纹组成的线对的距离。</p>

<p><strong>空间频率(Spacial frequency)</strong>：图像平面上每毫米的周期数称为空间频率，单位是每毫米线对数，简称为 lp/mm。</p>

<p>下面是文章中的一个图片例子,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p><strong>GPT</strong>对图注的解释如下</p>

<ul>
  <li><strong>Measurement Aperture 2</strong>: 测量是在光圈 f/2 下进行的。这意味着镜头的实际成像性能是通过在 f/2 的光圈下拍摄条纹图案来测量的。</li>
  <li><strong>Diffraction-limited Aperture 5.6</strong>: 理论上，光圈 f/5.6 是受衍射极限影响的最佳光圈。也就是说，在 f/5.6 光圈下，成像质量接近衍射极限，表现出最佳的清晰度和对比度。</li>
  <li><strong>Measurement Aperture 5.6</strong>: 测量是在光圈 f/5.6 下进行的。镜头的实际成像性能是通过在 f/5.6 的光圈下拍摄条纹图案来测量的。</li>
  <li><strong>Diffraction-limited Aperture 16</strong>: 理论上，光圈 f/16 是受衍射极限影响的最佳光圈。在 f/16 光圈下，成像质量接近衍射极限，但由于光圈较小，衍射效应变得显著，从而影响图像清晰度。</li>
</ul>

<p>For purposes of comparison the diffraction-limited transfer functions for f/5.6 and f/16 are also shown (solid line without circular dots). The diffraction-limited image is the best possible one.</p>

<h3 id="什么是diffraction-limited-衍射受限通常用于描述光学系统的成像性能">什么是Diffraction-limited, 衍射受限(通常用于描述光学系统的成像性能)</h3>

<p><strong>Diffraction-limited</strong> 是描述光学系统在没有像差和其他缺陷情况下，由于光的衍射效应所能达到的最佳成像质量。当光线通过光学系统（如镜头）时，会由于光的波动性而发生衍射，这种效应会限制系统的分辨能力. <strong>衍射</strong>：与光的波动性质有关，当光波遇到障碍物或狭缝时发生偏折. <font color="grey">看到这个地方的时候, 我不知道光的衍射是什么, 也不知道为什么会影响光学系统的能力, 但是这里的意思, 因为这个性质的存在, 有了极限, which is 图示中的黑色实线(接近直线).</font></p>

<p>OK, 换用新图, Winfu前辈做的图真的是好,</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBZzdqTab7E0UKD7T-GOuQ.png" style="zoom:35%;" /></p>

<p>下面是文章的内容的直接复制(没有换成简体中文)</p>

<p>為了作為比較，也標示了f 5.6（橄欖綠色虛線）以及f 16（灰藍色虛線）的繞射極限的轉換函數。達到繞射極限上限的影像是理論上的最佳影像品質，在圖表上呈現幾近完美的直線，下降率與空間頻率成比例。在到達<strong>極限頻率（limited frequency）</strong>時，MTF趨近於０，其頻率由<strong>光的波長</strong>與<strong>光圈値</strong>兩個因素決定。</p>

<font color="grey">这里又想补充一点就是, 突然想到, 超过了这个原来的黑色实线(新图的蓝绿虚线,也就是繞射極限), 就会因为衍射的问题, 让成像崩了, 这样?</font>

<p>現實中的鏡頭即使<strong>校正</strong>，仍帶有殘餘<strong>像差</strong>，因此MTF曲線一開始會快速下降，然後緩慢趨近於０。曲線明顯向下彎折，就像上面圖６中光圈為f 2的洋紅色曲線一樣；至於光圈縮至f5.6後的藍色曲線和理論最佳値的差距就相當接近了。</p>

<p>當MTF曲線降至０或低於一個臨界點（Threshold） — — 例如10％，<strong>其空間頻率即為光學鏡頭在空氣中的解像力</strong>，這意味著一旦超過臨界點，黑白條紋的明暗結構整體變成灰色而難以辨識，這又是另一個問題。</p>

<p>圖測量鏡頭在光圈f 2時的曲線，空間頻率到達120 lp/mm時，幾乎是一片平坦，即使空間頻率增加，反差對比也幾乎沒有變化，這樣的測量非常不精確，鏡頭解像力可能達到160 lp/mm以上，也可能只有120 lp/mm。</p>

<p>這樣的判準，並不適合用來評判一隻鏡頭的影像品質。此外，空間頻率與數位時代的影像感測器（image sensor）的「解析度」，兩者也不能混為一談。</p>

<h4 id="像差-aberration">像差 (Aberration)</h4>

<p>在低空间频率下，像差影响相对较小(<strong>为什么?</strong>), 随着空间频率的增加，像差的影响逐渐显现(我觉得是容易变灰, 高频下间隙太小的原因)</p>

<h4 id="像差的类型gpt生成">像差的类型(GPT生成)</h4>

<p><strong>球差（Spherical Aberration）</strong></p>

<ul>
  <li>发生在球面透镜中，中心和边缘的光线不能聚焦到同一点。</li>
  <li>导致图像中心和边缘的清晰度差异，影响整体锐度。</li>
</ul>

<p><strong>色差（Chromatic Aberration）</strong></p>

<ul>
  <li>由于不同波长的光在通过镜头时折射角度不同，导致不同颜色的光聚焦在不同位置。</li>
  <li>产生彩色边缘和色散现象，尤其在高对比度边缘处明显。</li>
</ul>

<p><strong>彗差（Coma）</strong></p>

<ul>
  <li>主要影响图像的边缘部分，使点光源呈现为彗星形状。</li>
  <li>影响图像边缘的锐度和对比度。</li>
</ul>

<p><strong>像散（Astigmatism）</strong></p>

<ul>
  <li>垂直和水平方向的光线不能同时聚焦在同一点。</li>
  <li>导致图像在某一方向模糊，影响细节表现。</li>
</ul>

<p><strong>场曲（Field Curvature）</strong></p>

<ul>
  <li>图像平面不是平坦的，而是弯曲的。</li>
  <li>中心清晰，边缘模糊或相反。</li>
</ul>

<p><strong>畸变（Distortion）</strong></p>

<ul>
  <li>图像几何形状变形，直线变弯曲。</li>
</ul>

<h4 id="其空间频率即为光学镜头在空气中的解像力">“其空间频率即为光学镜头在空气中的解像力”</h4>

<p>表示在MTF（调制传递函数）曲线下降到某个低阈值（例如10%）时，对应的空间频率就是这个镜头在空气中的解像力。换句话说，这个空间频率是镜头能够有效分辨的最高频率。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.1.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p>举个例子, 假设某个镜头的MTF曲线在30 lp/mm时降到10%，那么这个30 lp/mm就是这个镜头在空气中的解像力。也就是说，这个镜头能够分辨的最细微的细节是每毫米30对条纹。超过这个频率，图像细节将无法分辨，变成灰色或模糊。</p>

<p>下面是文章的内容的直接复制(没有换成简体中文)</p>

<p>測量鏡頭在光圈f2時的曲線，空間頻率到達120 lp/mm時，幾乎是一片平坦，即使空間頻率增加，反差對比也幾乎沒有變化，這樣的測量非常不精確，鏡頭解像力可能達到160 lp/mm以上，也可能只有120 lp/mm。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.2.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p>我怎么感觉文章里面没解释过下图</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6bFyZjRh3SFEGqeJubvrg.png" style="zoom:33%;" /></p>

<p>這樣的判準，並不適合用來評判一隻鏡頭的影像品質。此外，空間頻率與數位時代的影像感測器（image sensor）的「解析度」，兩者也不能混為一談。</p>

<p>這也是蔡司為何決定採用MTF來描述成像品質的原因之一。我們並不直接用眼睛觀察相機鏡頭成像，鏡頭後方總是需要一個媒介：傳統銀鹽底片、CCD、CMOS、掃描器、投影機……等等，有類比式的也有數位式的。</p>

<p>所有媒介（包括人的眼球在內）都有自身的影像特性，每一種影像特性也可以用一組轉換函數來分別描述。MTF的優勢在於：整體的光學成像鏈的MTF是（接近於所有）個別MTF的乘積。</p>

<p>Let us consider a few typical examples:</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic8.png" alt="howToReadMTFpic8" style="zoom:33%;" /></p>

<p>有两个图, 第二张没放, 这的意思感觉就是要注意镜头素质和传感器的素质.</p>

<p>Product of two modulation transfer functions: Very good 35mm format lens and color negative film. The product is always smaller than the smallest factor in the imaging chain.</p>

<p>In this case, the total modulation is essentially limited by the film. If one specifies a minimum of 10% modulation transfer, one must expect a resolving power of 80100lp/mm. If further elements such as projection optics or the eye are taken into account, the product is even slightly smaller.</p>

<h2 id="在评价光学系统性能时为什么通常不需要考虑非常高的空间频率">在评价光学系统性能时，为什么通常不需要考虑非常高的空间频率</h2>

<p><strong>理由</strong></p>

<p>在这里, 我们观察使用的是MTF product lens x film, which is 看到整体的光学系统对不同空间频率的响应, 乘积后MTF越小，表示系统在该空间频率下的表现越差。涉及更多的传递函数(MTF) 往往只会使乘积变小.</p>

<p><strong>数码传感器的空间频率限制和实际使用下的限制</strong></p>

<p>24百万像素的35毫米全画幅格式传感器和15百万像素的APS-C格式传感器，其奈奎斯特频率大约为90lp/mm, 这是如何计算出的</p>

<p>同时, 40lp/mm已经足以提供足够的细节和清晰度，超出这个范围的细节对于大多数实际用途来说并不显著, 我不知道为什么. 40lp/mm被认为是一个合理的上限，因为它既能够提供足够的图像细节，又不会受到高频混叠等问题的影响。</p>

<p><strong>Nyquist Frequency</strong></p>

<p>想起来在信号系统里面学过, Nyquist Frequency是采样率的一半, 只要离散系统的奈奎斯特频率高于被采样信号的最高频率或带宽，就可以避免混叠现象。对于CMOS传感器而言，它表示传感器能可靠捕捉到的最高空间频率。在图像处理中，采样频率是指传感器的像素密度。
\(f_{\text{Nyquist}} = \frac{1}{2} f_{\text{sampling}}\)</p>

<p><strong>90lp/mm（每毫米90对线对）</strong></p>

<p>每毫米有90对黑白线对</p>

<h2 id="edge-definition-image-contrast">Edge definition, image contrast</h2>

<p>以下繁体文字内容为直接复制[5].</p>

<p>但是，這些「數據變化」對實際影像品質而言有何意義？當我們談論「清晰銳利」、「明亮度」、「細節解析力」時，和這些數據之間有什麼關連？</p>

<p>我們拍攝的主體本身顯然不是正弦波。它們只能在實驗室中透過大量測試階段生成，使用其他目標對象進行測試，並以數學方式推導出正弦波的調變。</p>

<p>蔡司使用的是一種「明暗變化明顯的長方形黑白條紋圖案」的特製測試圖表，來評估相機鏡頭的有效解像力。</p>

<p>精細的，重複變化的圖案，僅僅只佔據我們的視覺功能中用來辨識影像品質的一小部分。重點是明暗不同亮度區域之間的邊界。因此，蔡司還必須研究MTF與邊界再現（reproduction）兩者的關係。說到這，我們不得不回到起點：點擴散函數。</p>

<p>然后在文章中就出现了4个图, which is由三并排图组而呈现的设计(有点绕口), 我一次性按顺序放在下面,</p>

<p>1⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.png" alt="howToReadMTFpic9.2" /></p>

<p>2⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.3.png" alt="howToReadMTFpic9.3" /></p>

<p>3⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.4.png" alt="howToReadMTFpic9.3" /></p>

<p>4⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.1.png" alt="howToReadMTFpic9.1" /></p>

<p>The following images show from left to right:</p>

<p><strong>Intensity profile of the point spread function</strong>, 也就是每个图中的第一个section, 这个是光的点扩散函数, which means  that 点光源/或者说一束光在通过镜头折射穿透后, 在传感器上的分散的切面, 我觉得可以理解成底部的位置就是传感器的感光位置, 以图1⃣️为例子, 这是一个很好的镜头成像, 非常清晰, 点光源只扩散到了-20µm和20µm之间,</p>

<p><strong>Intensity profile of two edge images</strong>, 对于这里的Edge profile我的理解是主要关注0µm处如何变化, 还是以图1⃣️为例, 发现在0µm初变化的非常快速, 这是一个好的镜头的表现.</p>

<p>The corresponding <strong>modulation transfer</strong> 这里是柱状体描述的MTF图示, 拜文章所赐, 文章会见到不同厂商各式各样的格式,方法和规格的MTF的图片. 还是以图1⃣️为例, 这是一个非常好的MTF小图, 不知读者有没有意识到, 从5Lp/mm开始接近100%的MTF率, 到80Lp/mm下仍然保持了接近于50%的MTF率. 原作者评价$\rightarrow$ The image of the edge is sharp. In the language of modulation transfer, this characteristic is recognized by the fact that all values at the important spatial frequencies are very high and do not decrease so strongly towards the higher frequencies.</p>

<p>For a lens with such imaging performance, the image quality achieved is usually limited by the sensor or by other factors such as focusing accuracy, camera movements etc. 好家伙, 镜头不会限制图像的表现, 差的结果是一些客观的因素.</p>

<p>下面是针对不同的图的结果分析</p>

<h4 id="pic-1">Pic 1</h4>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.1.png" alt="howToReadMTFpic9.2.1" style="zoom:33%;" /></p>

<p><strong>Intensity profile of the point spread function</strong> for Pic 1.1</p>

<p>这个图在之前解释过, 可以被考虑成是一个竖直光线照在传感元件上的横切面, 可以想象成一个千层蛋糕的切面. 同时也在之前提及过, 这个数据非常非常优秀,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.2.png" alt="howToReadMTFpic9.2.2" style="zoom:33%;" /></p>

<p><strong>Intensity profile of two edge images</strong> for Pic 1.1</p>

<p>在之前的解释中, 没有被明确指出, 现在, 可以注意在新的图示中我划出来的红色竖线, 这表示明暗的交接线. 可以看到, lens有非常非常好的过度变化, 在经过0的时候瞬间过了,</p>

<p><strong>Modulation transfer</strong> MTF for Pic1.1</p>

<p>非常非常优秀的MTF曲线表示, 在5lp/mm情况下,  正常的随着条纹更加精细而不断下降的数值, 合理而正常.</p>

<h3 id="小注">小注</h3>

<p>本来是计划把4个表都解释一遍, 但是发现, 好像没有现实意义, 因为文章的意图是理解MTF曲线, 但是这种形式的MTF曲线已经不再使用. 但是在这个部分要指出的是, MTF测量表会不准, 显示 出错误的数据信息, 在文章中的例子就是, 比如现实图像在影射后, 在cmos上位移会没有显示清晰的图像, 但是位移的图像在某个Lp/mm的条纹下, 移动到了下一个位置, 导致图像没有变模糊, 仍然清晰. 虽然镜头的素质没有提高, 但是由于测试的是这种特殊的条纹, 让MTF的曲线的数据提高, 这是虚假的成绩. 这个现象在文章中被专门指出. 我在这里直接引用, <strong>But:</strong> There is no contrast at 40lp/mm! <font color="red">The curve of the modulation transfer can drop to zero and then increase again.</font>  This is then called “spurious resolution”, which is a somewhat unfortunate expression because the structure with 60lp/mm is reproduced with a clear resolution.</p>

<h2 id="文章中的第四种mtf曲线the-mtf-values-of-this-4th-type">文章中的第四种MTF曲线(The MTF values of this 4th type)</h2>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[文章翻译, 阅读, 解读MTF曲线, 笔记总结 Preface]]></summary></entry><entry><title type="html">The summary (guide) for DIY master application in 2024 fall</title><link href="http://localhost:4000/master-apply/" rel="alternate" type="text/html" title="The summary (guide) for DIY master application in 2024 fall" /><published>2024-06-09T00:00:00-04:00</published><updated>2024-06-09T00:00:00-04:00</updated><id>http://localhost:4000/master%20apply</id><content type="html" xml:base="http://localhost:4000/master-apply/"><![CDATA[<style>
    body {
        -webkit-user-select: none; /* Chrome/Safari/Opera */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
        user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */
    }
</style>

<p>写一些申请cs(没申到)和泛cs(cse/ce/ece/ee)硕士的想法和记录,关于学校, 关于项目, 也关于一点别的</p>

<h2 id="开始之前">开始之前</h2>

<p>这篇文章主要记录了我在 2024 年 4 月 24 日至 5 月 1 日期间撰写的一些关于申请24fall 计算机科学硕士（CS）及其相关专业（如ce, ece, cse等）的想法和经历。随后，在 6 月初进行了重新整理和编辑。</p>

<p>如果你觉得语气有点怪或者某些用词很机械, 那是因为文章的原始内容被我用gpt和固定的prompt重新生成了一遍. 另外, 所有之前的commit记录已经被我删除了.</p>

<h2 id="后记前置">后记前置</h2>

<p>这篇文章的编辑时间跨越了 4 月 24 日至 5 月 1 日，当时我正在撰写我的毕业论文，尽管那个过程非常艰难，但奇怪的是，这篇文章的撰写却非常顺畅。第一次动笔，就写了 5000 多字… 最初的草稿长度为 3.3 万字，经过初步筛选后剩下了 2.9 万字。尽管我将其简短地发布在我的页面上，但我觉得文章的口气太过激烈，因此我将其撤下重新编辑。现在，文章的字数为 19526 字（Typora 自动识别）。我希望尽快发布，以抓住大量报中介的时间。24fall的申请季已经结束了很久了，2025 年秋季学期即将开始。回顾这篇文章，我觉得这 1.9 万字更像是阐述 GPA 的重要性以及 DIY 方法的指南。</p>

<h2 id="开始之前的开始">开始之前的开始</h2>

<p>在申请季之前，我和一些同学（大约有 5-6 个与我同届的同学以及下一届的 2-3 个）一起交流一些申请信息。虽然交流有助于分享一些信息，但重复地讲解会很累，所以我想把整个申请过程完整地梳理一下。我开始写作的时间是 2024 年 4 月 24 日，持续到现在，即 5 月 1 日（现在是 5 月 7 日）。虽然这个过程并不复杂，但一步步记录下来便于将来参考。我可以很有耐心地向一个人解释，甚至 10 个人，但对于 100 个人来说就有些困难了。而且我也不能从中获利（虽然我想尝试），所以我想写一篇文档并公开分享，供所有人查阅。如果你觉得我不够资格写申请指南，那就笑笑、骂骂吧。</p>

<p>还有一点是, 我不喜欢一点一滴地讲解，一页纸写三言两语的内容，我觉得那样没有意义，内容太过零碎。每个人的背景都不太一样，所以我主要考虑自己的情况。因为我没有足够的时间和精力去了解所有的项目，也没有必要。在申请季只关注适合自己的信息是很正常的。</p>

<p>我考虑将部分内容放在我的主页上。我必须坦白地说，虽然我可以说自己 DIY 了一些申请项目，但我还是得到了很多人的帮助，无论是提出许多中肯建议的学长学姐，还是一位我在小红书上认识的非常厉害的朋友，都给了我很多申请季的帮助。在这里我要感谢他们。</p>

<p>很多第一手信息（我会全部分享出来）来自在读的学长学姐甚至已经毕业的学长学姐，感谢他们接受我这个陌生人(虽然是校友)的骚扰，并给予我建议和支持。</p>

<p>在申请季开始之前，我阅读了一位学长的申请总结，收获颇丰（尽管该帖可能因透露过多个人信息而被删除）。在我仔细了解了<strong>一些</strong>中介水平低劣的情况后，我决定自己操作申请。最终，我将整个大四上学期的时间都投入到了这件事情上。现在回想起来，我可能有点本末倒置，更应该把时间用来刷题增强计算机基础，因为相比而言, 一个排名更高或质量更好的项目对就业的帮助微乎其微，个人实力才是更为重要的。当然，实力强的人才会有机会进入更优质的项目。但是，强大的实力并非这些优质项目的教学而习得的。我说的可能有点绕，但总的来说，我在大四上花费了大量时间翻阅了Linkedln、一亩三分地、小红书、Reddit、两岸三地的 看板, Discord ，甚至还查阅了一些印度论坛（印度的计算机科学留学群体庞大，但是录取的逻辑和我们不一样, 我主要是看了一些他们对项目的评价）。这篇文章的契机是，作为西浦的大四学生，我最关心的事情就是申请研究生(可能做错了)，我想把整个过程和想法记录下来以作纪念, 也顺便给路过的人参考吧。</p>

<p>本人的24fall申请背景是，——删——，就这样开始了申请季。我想大部分我们学校的毕业生都会选择读硕士。就我的成绩/GPA而言，我对我的申请结果相当满意，而且项目出结果的时间非常合适。从11月开始，一个月一个ad，稳扎稳打，一点都没有慌乱和错乱的感觉。想象一下，如果你申请季最后收到了斯坦福ms ee/cs这样的offer，但前面一堆rej，你至少会失眠并不断怀疑自己半年哈哈哈。</p>

<p>本人的rej的项目如下</p>

<ol>
  <li>rej UCL sse <font color="red">两礼拜飞速拒</font></li>
  <li>rej uiuc ece meng <font color="red">2月7号</font></li>
  <li>rej ic edsml <font color="red">一个月飞速拒</font></li>
  <li>rej Cornell ece meng <font color="red">az</font></li>
  <li>rej UVa mcs</li>
  <li>rej 爱丁堡 cs &amp; ai <font color="red">复活节</font></li>
</ol>

<p>这上面想去的项目里面, 把我给拒了的, 就是ucl, uiuc, UVa。UVa在今年更新了选课政策，选本科生的课变得非常麻烦，而且项目的规模不断扩大，所以我觉得没申请上也不算遗憾。不过，在申请季开始时，UVa是我非常喜欢的学校，本土排名在前30，但国际排名相对较低, 不过我不是很care。UIUC在投递的时候就知道不太喜欢我们学校的bg，只是因为有好几个认识的朋友在那里，所以比较想去。至于UCL SSE，投完后才发现其实根本录取不了(虽然有23fall大数据专业有申请成功的case) ，有点虚幻投递了。最后的结果让我感到意外的是UVa，我还以为是稳的… 但我已经尽了全力去做能做的事情。其实，申请季并没有做什么特别努力或费心思的事情，只是浪费时间查找资料，尽力做好自己能做的。</p>

<p>在之前提过，我通过学长的帖子得到了申请的第一印象和很大的收获。那么为什么我会找到这样的帖子呢？是因为在我没有决定自己diy还是找中介申请的情况下，我先在收集信息和比对学长/学姐的相关出路和他们最后申请成功的项目。除了了解上一届和上上届的去向，主要是我想搞清楚中介的收费从2w+到5w+甚至10w+到底这个钱花在哪里。但是这个问题我其实到现在也没搞明白。</p>

<p>我总结出的结论是：大概有些(可能也不是有些)真的就是纯骗人吧。</p>

<p>别的先不说了，写作水平之低，就可以很好的判断出不专业性。我写点我知道的可能是在我梦中发生真实案例：</p>

<ol>
  <li>一个案例是，在签约之前说可以提供不限次数的文书修改，结果是拖着到项目的ddl临近，才给文书材料。明天0点甚至是今天下午5点就要递交所有材料了，你就说你还改不改吧:)。还有1小时或一天就要提交了，是不是对文书有什么不满意的地方。</li>
  <li>而且就算文书看起来一切完美，中介也是ddl前提交申请居多。这可能取决于外包的写文书人员的速度。可以说问题很大，因为这个节奏应该灵活掌握。下面会提到申请的时机很重要，当然你在咨询的时候，话术就是ddl前交了就都一样的。</li>
  <li>最基本的写作水平如此，那就更加不要提选校定位这种事情了。除了已经固定化格式化的选校项目(很多项目是每年都是固定套路项目,年年报)。甚至有些小中介还没总结出这些套路项目，选择的策略更加保底。这些项目在申请季开始之前，我也觉得很牛逼，学校牛逼ranking高，项目名字看着可以/过得去。但是在经历过申请季或者说申请季开始了一半以后，就会发现他们申请的标准其实不在天上，和自己之前的认知相差甚远，甚至稍微做一下调研，就可以知道自己完全可以handle。</li>
  <li>某中介在学校和材料开放材料递交第一天，直接跨过学生本人，给教授发催促推荐信的email。然后把这个教授惹毛了，在学生和教授 meeting 的时候,这个学生直接被教授警告(比较罕见的case)。</li>
  <li>语言成绩出问题。我知道的时候简直笑死了，雅思6.5的成绩在申请系统上写了5.5，甚至还有忘记提交成绩证明的，我只能说…</li>
  <li>文书全GPT(其实没关系)，开头名人名言，人和名言在Google查不到(感觉这个还是有点关系的)。笑死我了，太离谱了。</li>
  <li>还有把不同项目的语言要求搞错的,还有gre战士。人均建议：均分低考个gre/均分高补个gre，笑死。</li>
</ol>

<p>**<font color="red">以上案例(可能)纯属虚构，仅为说明目的而使用, 你可以认为来源于网络。</font> **</p>

<p>没有以上多项问题的发生，我觉得这只是做到了一个合格的中介的基础水平。因为这完全不包括对项目的详细介绍(我会在<strong>选校</strong>细谈)。虽然项目官网会提供很多课程的介绍、选课list，但是每年开什么课、选课限制、是否可以入读之后转专业这些内容比较难获知的, 而且这些信息每年都会变化。我猜测很多中介对项目的认识程度，和刚考完大三期末考试点开项目主页的随便看看的你，是差不多的。绝大多数的认知来源是点开项目介绍页面的直接翻译。有些中介在沟通和后续合作的时候搞得很忙的样子，我都不知道在忙些什么, 可能在忙着庆祝了。</p>

<p>另外我提供一点猜测，就是中介的文书工作，应该大多数是由外包完成的。这个原因也很简单，如果你是boss的话，会养一批人只在每年的9月到1月工作剩下时间休息半年么。我认为这样的成本是不可能接受的，可能养1-2人还行。然后，我搜索了一下各大招聘平台对文书老师招聘工资是5000+一个月，假设这个文书老师的水平非常高超，可以做到收入5万一个月，那么大家可以仍然感受一下，一个人在一整月的工作量可以服务多少当年当季申请的学生。</p>

<p>以下还有几点中介为什么会存在的一些思考。</p>

<p>8⃣️中介服务重复购买率很低，申请的渠道靠校代和潜在的校代口口相传和广告曝光，被发布的好评只会如潮。就其实我觉得很多均分高的人，最后有一部分人没弄明白为什么自己申请的结果不错。只要观察一下身边均分不是很优秀的朋友/室友，就可以发现这帮人有时候没有帮倒忙就真的谢天谢地了。另外，差评的传递渠道不透明，很少有人花几万买了一坨屎还到处说(除非真的吃了好几坨实在受不了), 匿名平台说一次得了。而且就购买一次，都没什么横向比较机会，还能被怪自己bg低。</p>

<p>9⃣️重复第8点，面对褒贬不一的前路面前，会有自我修复心理。出现“我肯定是比较特殊的一个”和“他们服务我的话，肯定会用心的”的错觉。其实每个人都是平均的韭菜。</p>

<p>🔟宣传得很厉害的东西，基本上都不太专业或者很一般。很简单，人的经历是有限的，当把很大一部分精力放在宣传的时候，剩下的精力就很有限了。</p>

<p>我们总是会美化已经被固定发展了的道路，类似于‘来都来了’。</p>

<p>当然，以上这些都是最坏情况（或者说正常情况），我也知道很多朋友通过中介拿了很多不错的offer。因为公司只是平台，你可能会遇到很正常相对靠谱的人来对接，就像同样一个课，不同的老师上，评价也不一样是不是？或者同一个老师，每年上课也有评价的偏差。要是每个人通过中介都全聚德，那这个行业还有没有存在的必要了（也赚不到钱了）？</p>

<p>但是有两点要澄清，什么是不错的offer和为什么要中介。对于后者，我觉得大部分人的出发逻辑是</p>

<ol>
  <li>专业的事情交给专业的人</li>
  <li>省心</li>
</ol>

<p>事实证明，出发点虽然正确，你抽到负责的人往往是运气。以运气为开头的故事，往往不能省心。如果申请美研，这个抽取运气的成本是5W+人民币，我觉得不太值得。而且我相信大家学到现在，稍微努力一点就可以比大部分在这个行业中*了多年的人更加优秀。</p>

<h2 id="为什么csee专业要对留学机构说no">为什么CS/EE专业要对留学机构说NO</h2>

<p>总来说，按严重点来说，选择中介就像是你在学校邮箱中疯狂轰炸的垃圾邮件中挑了一个代写在完成你本科阶段比较重要的大作业（当然有机会碰到某些学校在读博士水平的代写）。我假设大家来xp可能都是希望读一个还不错的研究生。虽然根据身边的统计数据，我校的本科的直接就业率在提高，认识的朋友已经有好几个直接工作和不读研究生了。</p>

<p>1⃣️先交钱的逻辑。如果module leader告诉你，在大四这个学期开始时，你已经有60分的保底分数，你是否会觉得有必要认真学习课程内容和完成作业呢？同理，你在没有开始申请季之前，签约合同，已经付出了金钱的代价，机构已经拿到报酬了，你申请到斯坦福本身对他来说有什么实质性的好处吗？换个说法，你FYP完全不写，不用提交任何内容就有60分的前提下，你会为了写一篇目标是发SCI的FYP文章而努力吗？奇怪而疑惑，但是可能真的有？</p>

<p>2⃣️抽奖逻辑，你碰到一个好的对接的人，是完全抽奖的，之前提过。</p>

<p>3⃣️美研，或者是申请研究生吧，绝大部分项目（我感觉看中research的项目，我校几百人最多也就是3-4个吧，甚至好几届才能出一个），申请的条件就是<strong>GPA+学校背景</strong>，文书和视频写/录成屎申请成功的概率也很大，一本万利的买卖，或者说0本万利。</p>

<p>好了，前面都在说消极的内容，但是我觉得现阶段大家要关注自己以后想干什么，有自己的思路，研究生不是目的，只是方法（来源open cs），这个方法应该是自己去分析和思考出来的。</p>

<p>4⃣️所以，申请的项目你要了解它，不是学校和专业名字OK就完事了，这很重要，这是你申请完以后，下半年要入读的学校和项目啊，花费70w甚至150w。好多朋友申请完以后，甚至offer下了以后才开始了解这些项目，有点……</p>

<p>5⃣️开始对自己负责吧，申请研究生只是很小的一步，下面的发展过程有无数的步骤和问题要等着自己来操刀，从这一步开始为自己负责吧。</p>

<p>在申请季最后，其实感觉大部分项目中，学生很少得到就业（非科研）的顶级提升，某些hypms的项目是真的指数级别提升的，我指的是水平不够，没什么实习也能找到工作。我有考虑冲一个hypms的二硕…但是别的项目里面，最后还是个人能力大于学校title。</p>

<h2 id="正文-申请的步骤和操作">正文 (申请的步骤和操作)</h2>

<h4 id="选择2">选择2+</h4>

<p>作为非顶尖选手，我主观感觉就泛CS项目而言，如果费用可以保障（30w-40w一年），对于成绩在中段的朋友请果断选择2+，西浦和利物浦CS/EE的考试难度和学习强度分配，就最后的出分结果不是一个级别的。我觉得中上水平的人也应该考虑，而顶尖选手则请随意选择。这届一个ICS的top水平的朋友，给出的评价是利物浦的cs高分不能帮助top选手获得top项目的offer。从申请结果来看，85分以上的均分也不足以保证让其拿到Open CS上S和A+项目的offer，获得的很多项目都是70+和80+都可以申请的，有效果的帮助是让这些项目从<strong>彩票</strong>的级别变到了<strong>冲刺</strong>的级别，使申请成功的难度有所下降。所以，<strong>CS</strong> 2+可能对于本身就是极高均分的选手帮助不大（假设你ranking排名top10，前1%？）。但是我觉得大部分人都不是顶尖选手吧？所以还是把2+推荐给大部分人 :)，4+ ICS的申请结果也相当不错，我CST/EST/DMT认识的朋友都和我说，在国内非常非常累而且出不了分（很难受），（大三下学期期末的时候前两天还刚做完pre，结束后，在一个礼拜内开考整个大学生涯中最重要的4-5门考试（真感觉就我校申请重要性来说，大三=高考））。</p>

<p>我平心而论，如果没有2+，然后超级努力地学，国内估计大三就… 而利物浦这里呢，我大三刚刚来的时候人整个都没怎么进入学习的状态，最后一个月圣诞假期的时候才开始学的（真摆），最后考的还可以（不同的学科不一样，我说的CS）。我告诉他们我在这里学习的状态和分数的时候，我感觉他们难受得想跳楼。利物浦大三下有点难，难度和课程压力都上来了，EEE还有Year 2 project耗费你的大量精力和时间。我做这个项目的时候出了大问题，每天都是图书馆半夜3-4点回宿舍，早上10点左右强迫自己醒然后开始做。最后评分导师也有问题。哎～CS也逃不掉，COMP208基本是一堆70+80+均分的人在这个课上非常容易得60几。而且利物浦在最后考试的时候有至少两个礼拜的时间复习。适合很多高水平选手，一个礼拜学完，一个礼拜刷完往年卷，期末轻轻松松拿80+的分数。</p>

<p>所以这样看，即使是这样，我还是感觉2+还是远比4+容易得到分数。自己权衡…苏州（国内）吃的是真好啊…</p>

<p>而且今年真的超级卷，利物浦的eecs/cs的最高分应该都是打破的记录了，英本大三engineer搞到90多分，太牛逼了。</p>

<p>（以下内容和<strong>录取的逻辑</strong>有点重复，但是主要是中外合办一波分析，你觉得不对就是你对）</p>

<p>其实, 中外合办的本科都希望本科生留在自己学校交学费，但是又明白没外国母体学校的reputation自己什么都不是，所以都藏着掖着推出一些bridge政策。其实说到这里，西浦基本是国内2+2政策最宽松的学校了，WKU不了解，隔壁宁诺想2+2在高考录取的时候决定一大半以上的人数，剩下的人数由4+0的人在专业里面排名决定，搞得和保研一样。成绩在次等还想去UK就有折中方案，选择只去UK交换大三一年，还有就是放弃宁诺（国内系统）的学籍和学生身份直接transfer到诺丁汉。这些操作在疫情前比较火热。之后直到现在，来或者不来，成为了他们一个权衡的选择。LGU的水平在common的认知上，肯定是比我校的reputation要高的，而且在商科金融的领域我们学校就业水平碰瓷不了一点。但是LGU的GPA太恐怖了，卷的人又多，一旦GPA掉下3.5，申请季就会非常被动和煎熬（但是在515之后有改动？）。所以我发现他们学校的common的申请结果没有很耀眼。之前LGU和CUHK出了2+2的项目时候，公众号发了好几波广告，我点进去看了看名额40-50个人…(更新: 现在又看到了cu和cuhksz的3+2项目, 感觉有点东西啊) 关于昆杜和上纽，我了解到，DKU到Duke交换政策比NYU Shanghai的限制大很多。Duke交换只能拿J1签证。这两个学校的top ranking的人出路太璀璨了，MIT CS直博/MIT FIN，申到的项目我看都不敢看，但是一旦在这两个学校卷失败，出路立马掉到rank中档的西浦宁诺级别。广以体量太小，出路也很好看，但是都是基础学科（化学，生物），我校的基础学科出路也同样很吓人(yale/cmu/nus提前批/一堆ic)，所以不知道怎么评价，加上没空了解。</p>

<p>还有转美本的问题…这个section太大了，可以写一篇文章来整了。但是, 如果人生有重来我一定希望是可以读美本 😭</p>

<h3 id="处理挂科">处理挂科</h3>

<p>首先没有我挂科, 虽然我现在大四分数在挂科的边缘… 我感觉我好功利啊, 没什么用的分数我一点学的兴趣都没有. 一直有2+可以免去挂科标记的都市传说, 这个被证明是正确的。在利物浦拿到西浦开出的成绩单开始给你办2+的手续时候, 他只关注分数而会忽略考试的次数, 所以补考的remark会被消除。但, 是不是在申请的时候有大用, 我不太清楚, 因为在申请的时候大概率要提交两个学校的成绩单, 还是会被发现是补考成绩。而且我感觉(只是感觉)只要补考成绩高, 就没啥关系, 申请的时候问题不大。我之前一直不敢想挂科补考的问题, 西浦毕竟不能重修更新GPA。</p>

<p>不过挂科千万不要慌, 申请应该还是按照第二次考试的分数来计算GPA的, 所以, 不要感觉天塌了。我甚至觉得在考个41, 42不如挂了补考算了…</p>

<p>6.16 update: 有人来咨询看了一个有补考成绩的transcript, 对面不说我根本没发现是补考的… 这个*的标号实在的太小了, 我现在感觉补考完全没关系了, 有补考成绩申请一般的大概原因是有补考成绩说明总体成绩可能一般, 但是有1-2门补考成绩(补考分数高), 别的module整体分数尚可的话, 应该是完全不会影响申请的.</p>

<h3 id="wes认证">WES认证</h3>

<font color="red">7月全出分的时候,马上可以开始做了,要处理一个月,请避开9月,10月旺季</font>
<p>, 因为在10月开始做wes认证, 可能要一个半月的等待时间。想想一堆项目的ddl就是在12.15, 还是不要这么这么急的做事情吧。Ps: 虽然我也不知道wes在忙什么,可能是海专精,一杯coffee一个下午挑20个人开始算成绩, 然后下班吧hhhh。另外, wes选便宜的套餐就行,我选了300美元那个, 小亏。还有一个要提及的点, 就是大三的全学分的课要更加精贵一点。大一大二会是5学分呈现, eap掉到3学分, 但是大三正常 full credit 的课程 wes会从15学分down到5.5学分,然后7.5 学分的课还是down到2.5学分. 不知道利物浦大三的成绩单是怎么处理的, 听说还有传媒的朋友在利物浦有30学分的课,我真是一头雾水。</p>

<h3 id="提交什么成绩美国">提交什么成绩(美国)</h3>

<p>在投递的时候, 我们会在院校背景的label写自己的就读经历。这个时候, 请务必写自己转换成wes的3.x/4的GPA, 不要写自己英国记分制的成绩, 因为第一遍初筛的时候, 设置的条件的就是GPA从高到低排, 大家都是3.X, 然后你的分数80+ or 70+在那边, 就很搞笑。当然你可以说, 美国院校会自己convert, 确实, 但是你不知道他们是怎么转换的, 比如就我知道的有些加州大学会统一对英本的GPA做3.67最高处理, 或者可能有些学校, 学校会挑自己喜欢的专业课计算。这些是我们不能把握的, 但是<font color="red">请把握你可以把握的部分</font>。甚至有些学校不知道我们使用英国的打分系统, 这里想起来一个之前我校转学本科的同学, 70多分被学校算下来GPA 2点几, 就这样无缘无故和某校(好像是uiuc)说再见了。而你可能觉得是自己软背景不够云云。虽然出现这种convert问题的可能性比较低, 但是你为什么要让它出现呢?</p>

<p>又可以补一点内容,我发现可能大家不知道成绩单提交的格式, 正确的格式是: wes的认证报告 + 利物浦成绩单 + 西浦成绩单(自带Classification说明) + 利物浦对成绩的Classification 文件(这个文件我附在了下面代码框中), 然后做成整个一个pdf文件。可能是多此一举, 反正这个操作的理由也是同上, 我们把握可以把握的部分。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">https:</span><span class="c1">//www.liverpool.ac.uk/media/livacuk/tqsd/code-of-practice-on-assessment/appendix_I_2010-11.pdf</span>
</code></pre></div></div>

<h3 id="关于学分没什么用的冷知识">关于学分(没什么用的冷知识)</h3>

<p>在之前的section提到了就补充一点吧, 学分是每个学校的一个毕业量表,怎么说呢,大概的计算逻辑是修满多少多少学分可以毕业。其中中国高校好多是使用2.5/5这样来定义半学分和全学分的课的,西浦也是。但是利物浦使用的方法是7.5/15的组合。之前有考虑过申请欧洲的项目, 所以也了解过欧陆的学分设计, 他们使用ECTS(European Credit Transfer and Accumulation System)这个机制来计算学分。如果想申请欧陆的学校,在计算课程匹配度的时候可以参考如下, “Students should note that ECTS credits are considered equivalent to half the value of Liverpool credits, e.g. 7.5 ECTS credits would be equal to 15 Liverpool credits。”</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">University</span> <span class="n">of</span> <span class="nc">Liverpool</span><span class="o">.</span> <span class="nc">April</span> <span class="mi">2024</span><span class="o">.</span> <span class="nc">Academics</span><span class="o">.</span> <span class="nc">Retrieved</span> <span class="n">from</span> <span class="nl">https:</span><span class="c1">//www.liverpool.ac.uk/global-opportunities/inbound/study-in-liverpool/academic/</span>
</code></pre></div></div>

<p>但是利物浦的成绩单上保留着西浦的学分逻辑, 2.5/5和10分的eap与7.5/15的大三分数, 让正常人计算的时候摸不着头脑。</p>

<p>注: 我这里真的想说宁诺西浦争了这么多年,就成绩单这件小事可以看出,西浦已经输了,宁诺的成绩单和英诺的成绩单title一模一样, 加上学分完全按照ECTS设置, 只有campus不同的标注,会写上China/UK。就西浦和利物浦的成绩单,这一看就是两个学校,title,格式, 计算系统完完全全不一样。最搞笑的是,利物浦成绩单上赫然写的大一大二分数从下交(西交大)修来的,太搞笑了</p>

<p>就申请上的体感也是, 两校没有绝对差距, 但是诺子好像就是过西浦半个身位…</p>

<h3 id="email"><font color="red">Email</font></h3>

<p>我之前国内用Outlook, 国外用Gmail. <strong>无论如何, 请重新注册</strong>一个!!!!</p>

<p>首先NYU和NEU的广告就能烦死你了, 要是用老邮箱, 原来的subscribed的各种广告邮件也能烦死你(我有很多商店的邮件).</p>

<p>也防止错过录取通知书的ddl,真有人不关注然后中介也没发现就错过了一个学校发了的ad, 要是是梦校offer你找谁哭呢。 我不喜欢163, 要手机验证, 而且邮箱link数学符号完感觉很奇怪, 有理由相信美国人也会觉得很奇怪, 之前在英国打客服电话的时候用163邮箱对面都笑了。</p>

<p>之前没想到要写这个section, 算比较重要和简单的一步? 因为我知道看到过一个帖子, 某校学生没发现学校发了offer导致gap的, 记得那个家伙是LSE的项目。</p>

<h4 id="语言">语言</h4>

<p>我的语言水平一般, 所以直接waive了, 好像没怎么影响我的申请, 除了NTU CCA发邮件问我要语言成绩。</p>

<h4 id="gre">GRE</h4>

<p>我在这里专门列出。</p>

<p>有时间,喜欢英语,有自信的人可以专门考一下。 我高中的时候, 刷知乎看到一个北大本科说考GRE很痛苦,太痛苦了,感受到了单词如水流入脑又如瀑布般流出记忆,笑。</p>

<p>但是这个现在已经不是必须的了,甚至申请的权重越来越低(我给出一个猜测,重要性占比为2%,给1%太少,给3%太多),我真的感谢那些GRE作弊哥, 以一己之力让中国大陆的GRE平均分在疫情的两三年内实现了史诗级别的跃进, 让这个考试的效力越来越低。 别人花钱我来享受这个结果,拯救了我这个英语渣子于水火之中。 总之, GRE的不考率真的是越来越高。 除非是top项目, 否则院校真的要考虑是否用这种姿态来换取申请数量的下降(说的就是你, NYU,9月GRE required然后10月改成optional)。</p>

<p>但是,GRE能考出的大佬还是挺牛逼的, 我深深的respect!!!</p>

<p>哦对了, 如果想申请CMU的一些项目好像GRE是必须的,有些顶级项目也有GRE的要求,比如CMU SCS/ Yale CS/ Duke MSCS, 但是我目测西浦大多数人申不到, 本科院校背景不够。</p>

<p>总结, 就近两年的EE/CS申请而已,市面上90%的项目, 已经不需要GRE了, 或者换句话说, 剩下的10%的CS/EE项目不属于西浦, 无论是 斯坦福 MSEE, CMU SCS, Yale CS…注意除了CMU, 但是我申请季完全没考虑CMU, hhh</p>

<p>如果对于自己非常自信(有我一个浙大的朋友0基础学一个礼拜325+的case😭), 那可以考一个玩玩, 但是你一旦感觉是自己要下定决心努力学习GRE才能考的话, 相信我请直接放弃, 这个时间放在准备大四的暑期实习/秋招, 会对申请后的发展/对找工焦虑的解决大有益处. 收益远大于10倍的一个GRE 330+的成绩。</p>

<h4 id="卖惨">卖惨</h4>

<p>我见过很多在文书中卖惨的案例，例如身体残疾、父母离异、心理疾病、性别认同问题，甚至简单地描述自己是第一代大学生。虽然这些情况都可以提及，但重要的是表达时要有逻辑。在美国，强调英雄主义，因此指出问题的同时，请务必说明你是如何解决或正在解决这些问题的。例如，家境贫困、没有足够的经济支持读书，但却凭借优异的成绩获得了奖学金，一路走到今天。注意要有起承转合的叙事逻辑。如果你只是简单地陈述了困境而没有后续，那实在对不起……你是在说让赚钱的master项目给你提供励志奖学金吗？</p>

<p>因此，在个人陈述或申请书中提及困境时，请务必简要阐述困境，多加说明解决困境的过程。如果这些被注意到(几乎不会被注意到)，那确实会给你加分。</p>

<h4 id="情侣">情侣</h4>

<p>有些学校, 在申请系统上会问是否情侣/朋友一起入学(主要是私立学校), 我觉得这个点是有影响的, 逻辑是如果两个人都满足入学要求, 学校给这两个人发offer入读的概率就会很大, 减少担心发offer被鸽的情况。 所以你懂的, 既然有离婚买房, 那么申请季在申请系统上小结一下好像也不离谱 。</p>

<h4 id="科研实习作品集">科研&amp;实习&amp;作品集</h4>

<p>我申请下来感觉90%的项目没什么用，9%的项目有些用，1%的项目则非常重要，可能是因为GPA较低（3.1），但有着丰富的实习经验、参与过的会议和发表的论文。也许这样的申请材料会让招生委员会感到困惑，谁知道呢，这些东西总比没有要好，但重要性远不如GPA高。找到这些项目需要耐心和规划。</p>

<p>然而，有质量、有含金量的实习对于未来就业和申请绝对是有帮助的。尽管在申请阶段可能帮助不大，但在找工作或实习时会大大加分，没有实习经历的人必然会吃苦头。尽管这个世界有时候确实挺滑稽的，为了实习你首先必须有实习经历，我已经有很大预感我会吃苦头了😭。</p>

<p>关于Kaggle的更新：我听说有人购买Kaggle比赛的成果，但如果你购买的是银牌，根本没什么用；金牌有点用。</p>

<p>虽然对大多数研究生项目的申请没有太大帮助，但对于找到自己感兴趣的研究方向，甚至未来职业规划来说，还是有帮助的。此外，不仅局限于科研，比如骑车、徒步、攀岩等，在大学阶段探索自己的兴趣对个人成长也是很有益处的。</p>

<h4 id="录取的逻辑为什么gpa如此重要">录取的逻辑——为什么GPA如此重要</h4>

<p>我突然意识到前面三个小节都在谈论GPA。为什么呢？因为硕士申请的逻辑实际上就是看学校背景和GPA来筛选申请者。我一直在想西交利物浦大学（XJTLU）的学校背景大概在哪里。就陆本来说，西浦的定位大概在中上211和非顶尖985之间，比如重庆大学、湖南大学，最顶尖能上到中山大学(已经很强了😭)。最强的uu，我认为可以上到华五水平的25%左右（华五就是第五, 有个跌三观的认知是在申请水硕上面，xp的各位可能比复旦的很多普通人有优势，很多复旦的申请者的结果可能都干不过上海大学）。当然，92中最顶尖的学校碰瓷不了一点，录取分数线非常高，比如苏州大学有直博斯坦福计算机专业的，我们学校氛围比较功利，不太适合这种all in的人才。而且据我观察，92中最强的人基本上是赢者通吃的，OpenCS A+/A的项目可以申到好几个，S也有一些，4月份开始幸福的纠结。但是我们学校的背景，能摸到一个A/A+其实就是很大成功了，已经非常不错了。当然，学校声誉的提升完全是因为我们使用了利物浦这个英本的pool，美国学校也不希望录取的学生全是中国的92学校，这样的逻辑在不同情况下也是合理的。比如为了男女比例平衡，斯坦福eecs录取时，对女生的门槛就稍稍降低一些。以上纯属个人猜测，不负任何责任。只是根据申请季的情况来看，我觉得我水平碰瓷不了这些92学校。</p>

<p>具体来说，GPA和本科背景是学校了解你的关键。绝大多数授课制研究生的招生官会认为一个好的GPA表明一个人在大学课程中有可以的学习能力，因此在研究生阶段，他应该仍然能够适应。然后这个逻辑就结束了。本科课程内容的好坏与申请人是否被培养以及学习的意义完全无关。因此，在申请时，如果面对一个相对较低的GPA，我们该如何解决呢？我想到的办法是申请成绩单中那些取得高分的课程突出自己的优势，并让低分课程的老师写推荐信解释（虽然让低分课程的老师给我写推荐信纯属巧合，我非常感谢在申请季愿意为我写推荐信的老师们）。开源节流，开源用高分课程突出优势，节流避开低分课程，并用老师的推荐信弥补。这可能并不是非常有效，但你可以看到下面两个链接中不断强调推荐信没有多大作用或者推荐信很无聊，但我注意到一个现象，推荐信被审阅的概率非常高，无论是被检查（查找问题）还是常规浏览，因此我们可以充分利用这部分内容。</p>

<p>但我觉得以上分析都是瞎猜，如果是一个几千人申请的大项目，这些信息是不可能被仔细阅读的。</p>

<p>这里转载两篇文章，不重复造轮子。</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">从审材料的角度谈谈研究生申请</span><span class="o">|</span><span class="n">一亩三分地研究生申请版</span>
<span class="nl">https:</span><span class="c1">//www.1point3acres.com/bbs/thread-463109-1-1.html</span>
</code></pre></div></div>

<p>另外一篇在小红书，作者Shangtong Zhang，UVa的24年新的AP</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Shangtong</span> <span class="nc">Zhang发布了一篇小红书笔记</span><span class="err">，</span><span class="n">快来看吧</span><span class="err">！</span> <span class="err">😆</span> <span class="n">hlMl41cracI9LVC</span> <span class="err">😆</span> <span class="nl">http:</span><span class="c1">//xhslink.com/Vcd5CH，复制本条信息，打开【小红书】App查看精彩内容！</span>
<span class="n">下面是Shangtong</span> <span class="nl">Zhang的个人网站:</span>
<span class="nl">https:</span><span class="c1">//shangtongzhang.github.io/</span>
</code></pre></div></div>

<p>为了防止上面的post被删除，我复制了所有的文本在以下的section中，如果有侵权，请务必联系我删除[notmyemailcode@gmail.com]，不胜惶恐。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">去年新入职被放到了</span><span class="n">graduation</span> <span class="n">admission</span> <span class="n">committee</span><span class="err">里全程参与了</span><span class="n">PhD</span><span class="err">和</span><span class="n">master</span><span class="err">的录取</span><span class="p">,</span> <span class="n">phD</span><span class="err">的录取感觉跟我想象的差不多，但</span><span class="n">master</span><span class="err">的录取和我想象的有一些差别很大的地方，跟大家分享一下。</span><span class="n">Disclaimer</span><span class="o">:</span><span class="err">这只是我个人经历，不见得通用。而且这个就算能</span><span class="n">generalize</span><span class="err">，也绝对只适用于</span><span class="n">master</span><span class="err">不适用于</span> <span class="n">undergraduate</span><span class="err">和</span><span class="n">PhD</span><span class="p">.</span>

<span class="err">总的流程大概是一个</span><span class="n">senior</span><span class="err">的大佬出任</span><span class="n">committee</span> <span class="n">chair</span><span class="err">制定一个评分标准</span><span class="p">(</span><span class="err">比如用以</span>
<span class="err">的</span><span class="p">)</span><span class="err">，然后若干</span><span class="n">AP</span><span class="err">被拉进</span><span class="n">committee</span><span class="err">，是具体干活的人。大佬给每个人分配任务，每个</span>
<span class="n">appication</span> <span class="n">package</span><span class="err">有</span><span class="n">N</span><span class="err">个人</span><span class="n">review</span><span class="p">,</span><span class="err">最后取均分。所有的</span><span class="n">application</span><span class="err">都</span><span class="n">review</span><span class="err">完之后，系主任划一个录取的分数线，</span><span class="n">done</span><span class="err">。</span>

<span class="err">重点来了，我们每个人分到了大概</span><span class="mi">200</span><span class="err">个</span><span class="n">application</span> <span class="n">package</span><span class="err">，需要在大概</span><span class="mi">7</span><span class="err">个星期内</span><span class="n">review</span><span class="err">完。所以这个任务相当重。文书？我记得我本科申请</span><span class="n">master</span><span class="err">的时候写</span><span class="n">personal</span> <span class="n">statement</span><span class="err">那叫一个精雕细琢。但你猜我能花多少时间去读</span><span class="n">PS</span><span class="err">？而且</span><span class="n">PS</span><span class="err">好坏这是个非常主观的东西。我只能去看一些关键的点</span><span class="p">(</span><span class="err">具体是什么我就不方便说了</span><span class="p">)</span><span class="err">，你英语写的再</span>
<span class="n">fancy</span><span class="err">，句式再高级，故事再</span><span class="n">telling</span><span class="err">，我也没空看。我觉得你有</span><span class="n">typo</span><span class="err">我都不一定看的出来。</span>

<span class="err">本科学校</span> <span class="n">vs</span> <span class="n">GPA</span><span class="o">?</span> <span class="err">我一直以为本科学校会很重要，比如一个复旦的总得比蓝翔的得分高一点吧？但我问大家一个问题，印度除了</span><span class="n">IIT</span><span class="err">之外最好的学校是哪个？</span><span class="n">IIT</span><span class="err">的这些校区哪个好？伊朗最好的学校是什么？但</span><span class="n">GPA</span><span class="err">是一个很客观的</span><span class="n">number</span><span class="err">，只有地球人都知道的好学校才会有额外加分。而且学校好坏也是一个非常主观的东西。</span>

<span class="err">推荐信？这个相信大家都知道，推荐人对细节的描述和跟</span><span class="n">peer</span><span class="err">的比较最重要。我见过的最搞</span>
<span class="err">笑的是一个人有三个</span><span class="n">letter</span><span class="err">，但这三个</span><span class="n">letter</span><span class="err">除了签名完全一样。。</span>
<span class="err">暂时只想到这些，如果大家有问题欢迎在评论里提，能回答的我会尽量回答。其实很多问题</span>
<span class="err">只要换位思考一下加上下面几个</span><span class="n">fact</span><span class="err">就很容易得到答案。</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="n">AP</span><span class="err">都很忙</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="err">隔行如隔山</span> 
<span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">越主观的判断越花费时间</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">读</span><span class="n">Master</span><span class="err">是要交学费的</span>

<span class="err">有评论提到</span><span class="n">CV</span><span class="err">和</span><span class="n">SOP</span><span class="err">哪个重要，之前忘了写了，我认为</span><span class="n">CV</span><span class="err">远远重要的多，因为从</span><span class="n">reviewer</span><span class="err">的角度看，从</span><span class="n">SOP</span><span class="err">获取信息太麻烦了，</span><span class="n">CV</span><span class="err">就简单很多。</span>
</code></pre></div></div>

<p><strong>以上是我对美国学校录取的总体认知，当然还有很多细小的点, 在下面的section中想到哪里讲到哪里, 每个subsubtitle没有明确的连续上的意义。</strong></p>

<h4 id="英国欧洲">英国+欧洲</h4>

<p>说到英国，感觉信息有点碎片化。学校列表、均分等信息都有，甚至细分到一些特定项目的学校列表，有些过于零散。</p>

<p>比如剑桥，有针对不同地区的院校列表，比如对岸，台湾的清华大学和交通大学，还有伊朗的Sharif理工大学，土耳其的Bilkent大学。这里我想提一个有趣的小插曲，有人申请时把浙江大学(zhejiang uni)写成了镇江大学(zhenjiang uni)，结果收到了拒信。这个信息是通过申请人向拒信方发邮件争辩后得到的。说到学校名称，之前KCL还是UCL在发布中国学生的背景统计时，XJTLU的全拼缺了a少了d，真是挺搞笑的。</p>

<p>想提一嘴ETH, 这个学校非常非常神奇和清高, 和大多数学校不一样的list操作,这个学校有一份内部的reputation网站, 按一定时间更新, 我还查到了这个网址, 但是只有ETH的在读phd, 访问学者,ap, professor可以access, 看不了一点. 这个文档会记录下, ETH的学者和各个大学的学生,phd,教职的合作后的评价,  我猜大部分应该是主观的, 正向的,我是是指留下的评价. 所以,如果你校是blank的,或者说remark的条数非常非常少,那么就很寄. 希望以后我校的uu们可以解密这一份文档.</p>

<p>对于欧洲，大家可能比较感兴趣？我一度对欧洲很感兴趣，但最终放弃了。除了瑞士双e和KTH比较难录，还有一些其他学校的cs是比较好申请的，比如丹麦的奥胡斯大学、瑞典的CTH、林雪平和KI（诺贝尔奖颁奖学校）、荷兰的阿姆斯特丹、代尔夫特理工、埃因霍芬理工、意大利的都灵理工、芬兰的Aalto和赫尔辛基大学。</p>

<p>在申请瑞典的学校时，需要注意项目的优先顺序，不是平行志愿。在申请系统上，瑞典的不同学校的优先次序会影响录取结果，简单来说，不是平行志愿。</p>

<p>另外，今年好像是Erasmus计划或者EIT计划的最后一年。如果不了解的话，这些计划可以让你在一年内换两到三个学校，可以获得奖学金。中期的时候, 奖学金发放得很慷慨，但考虑到搬家等问题可能会有些麻烦。</p>

<p>我最终放弃欧洲的申请，主要是因为受不了北欧的天气。其实我已经注册了瑞典和荷兰的系统，选好了学校，都到了最后一步，但最后还是放弃了。因为我觉得我很可能不会去，那这样做只会浪费我的精力。在申请季节，我浪费了大量无意义的精力，包括写这篇文档。</p>

<h4 id="cashcow的逻辑">Cashcow的逻辑</h4>

<p>匹配很重要，包括分数、GPA、申请背景等，其实缘分到了就录了,不然为什么叫抽奖呢,喜欢的都投, 万一扩招了呢。</p>

<p>硕士本身就是作为“cashcow”来消费的。请买得起的最绚烂的珠宝吧，即使买不起，也要试试（提交你的申请）。</p>

<p>大部分硕士课程的逻辑是，学校有声誉和好的课程，你进来后提升实力，然后你交学费，学校赚钱，你毕业后进入中国或者学校所在地的工业界，为学校赚取声誉，使好的企业和组织认识到这个项目/学校的优秀，更愿意招收该项目的毕业生。学校在你毕业后会利用你的人脉和就业情况作为背书，以吸引更多的“cashcow”，earn buck for research ,phd, facility, but not for U.</p>

<h4 id="后置更新update提交材料">后置（更新，update）提交材料</h4>

<p>在申请过程中，有些操作是后续进行的，比如雅思成绩单后交、成绩单更新等，在提交申请后，最好只多做一次。美国的申请系统，很多由外包公司制作的，有些系统每次新的提交都会导致之前所有材料的重复。我认为你可以将其理解为数组的复制，当数组已满时，添加一个新元素会复制原数组再寻找一个新地址来存储。想象一下招生团队在阅读四五份重复材料时的表情吧。推荐信应该可以后交，没问题。虽然也有评论表示，这种更新不会导致材料重复，但很多学校也声明了更新后的材料基本不会被考虑。因此，在这方面我建议最多只更新一次，包括写作样本、成绩单、语言材料等。不过我自己也更新了好几次然后也收到很多学校中的梦校录取了</p>

<p>好像这个section有点乱，我也搞不太清楚, 不懂了,搞不明白。</p>

<h4 id="申请投递的时机">申请投递的时机</h4>

<p>时机的重要性,说实话我在申请季开始之前完全没意识到, 后来才发现这个的<font color="red">重要性就比gpa差一点点</font> , 时机非常重要。</p>

<p>举个例子，西北的CE专业较早投递会相对容易些，越晚越难。</p>

<p>再比如，NYU一开始9月要求GRE成绩，但后来发现不太好招到学生，一堆其他比NYU还好的项目和学校都不需要GRE。</p>

<p>NYU的雅思要求相反，我12月申请时豁免了雅思，1月我offer都下了, 但朋友1月卡DDL提交申请时，NYU因为申请量过大而取消了豁免语言。另一个例子是NEU的不同校区，基本上是先到先得，晚了就要转校区了。当然，也有例外，比如NYU的CE项目在DDL后仍有人被录取。</p>

<p>时机还包括申请的项目新旧, 相当于打新, 你要是上车了一个一开始bar低,后来水涨船高的项目,那就很赚.</p>

<p>时机还与历史经验有关，利用上一届的案例来定位自己。这种做法通常很好，因为基本上八九不离十，但也不是十全十美的。项目本身会有细微的变化, 比如rice mcs这个项目, 在22fall 时候gre required, 但是在23fall 改成了highly  recommend, 然后23fall拒绝了所有没有提交gre成绩的人. 类似做法在23fall还有brown的cs, which在24fall就不这样了.  本人超级后悔没申请rice mcs…这里的时机指的是参考历史经验，但如果真的对某个项目很感兴趣，一定要申请，不要因为觉得会浪费申请费而放弃。</p>

<h4 id="投递数量策略海投">投递数量策略——海投</h4>

<p>两个字, 海投. 甚至是多国家投, 多档次投, 多rolling投. 投Dream school, 也投认真研究后的保底</p>

<p>在上一个section我有提到, 申请的时间非常重要, 申请2-3个项目, 一旦这个这几个项目今年的招生计划, 对学生的bg品味有较大幅度的变化, 那你就寄了, 所以使用海投来规避风险是较好的策略, 我之前在xhs看到过一个申请季推荐信的神, 是一个211本国内研一的bg, 在23fall申请季申请了40+个项目, 真牛逼, 我是说推荐信数量. 我记得最后去向是uw pmp.</p>

<h4 id="不吝惜申请费用">不吝惜申请费用</h4>

<p>多花这个钱, 我就踩坑了, 想着这个肯定申请不上,然后就扩招了, 申请赌徒应该付出全部的钱买全部的筹码, 给大家建议是应申尽申, yale harvard等，不妨多花钱提高申请几率。当然，申请费用总计1.5-2万元人民币左右（我的申请费用应该在7000多人民币），申请20所学校应该就够了。如果觉得心疼申请费，可以关注学校的申请活动，有时会提供免费申请码。还可以考虑加入一些美国的学术组织，有些组织的会费大约20美元, 就可以免除多个学校的申请费用。</p>

<h4 id="硕士msc与工程硕士meng">硕士(MSc)与工程硕士(Meng)</h4>

<p>在申请季节，有些人对这两个学位的区别很在意，尤其是在想继续申请博士项目时。但我个人认为区别并不大，更重要的是关注项目本身。项目之间的差异才是更值得考虑的因素。对了在UK, 这两个确实有区别, meng有看到ucl和Bristol本科可以直升硕士发一个meng学位. 但对于外校的本科生来说, 卖的一般是MSc学位, 这点确实有一定区别，国内就业这个点几乎不关注。另外，还有一个有趣的news，剑桥大学本科毕业后5年或7年（具体记不清了），学校会直接授予一个艺术硕士学位，这是不是很有趣呢？</p>

<h4 id="论坛及社交媒体">论坛及社交媒体</h4>

<p>各种论坛和社交媒体(xhs/地/知乎/留学圈)都是很有用的平台，但要善于筛选对自己有用的信息，尤其是不要被一些过于优秀的背景所影响。</p>

<h4 id="项目的招生规模">项目的招生规模</h4>

<p>之前很少有人在申请时考虑一个项目的招生规模，但我觉得这是相当重要的因素，它反映了学校的培养态度。是真正用心培养学生，还是只当他们是cashcow？大班授课的体验我们已经有所了解，一个教授面对200个学生，讲台上游走，学生们人山人海一般。我曾看过耶鲁大学的一个社会学公开课，每个学生坐在圆桌上，教室里不超过10个学生，教授在中间讲课。我想这是我一辈子都无法体验的了，但这反映了一个问题，学校是如何对待学生的。许多质量好的项目通常班级规模较小，10人以下算是小规模，20-60人左右是正常规模. 但是近年来有, 200人甚至400人以上的项目，虽然这些项目和学校也很好，但我个人不太喜欢。读完两年书，同学名字都认不全，这不太像是来上学的感觉。我交了学费，教授你至少也该用心点吧？虽然学费不是直接给你的，但是我交学费是在为学校的建设和研究项目做贡献。虽然上课本身并不是最重要的，但是我觉得至少应该提供一个合适的学习环境。</p>

<h4 id="一些小建议">一些小建议</h4>

<p>在申请的项目都ddl之前, 不要交流各自申请的项目. 保护自己也不影响他人. 你自己要是90分,在ddl之前, 和一个70分的人去说我申了什么什么项目, 这不是给人上压力吗…项目很多都是同校竞争, 同校同专业竞争, 所以大家都安全一点呗. 但是在ddl之后交流, 就不会出现这个问题, 原来大家眼光一样,我感觉还挺惺惺相惜的. <strong>人总是在美化自己不能改变的事实, 那些已经过去的东西.</strong> 其实就算这样都发现很多撞申请的, 你应该不想进了一个项目最后发现可以开一个50个人的西浦校友会吧? 笑死, 这种情况比较少, 但是某个项目冲到人多, 你有可能真的会被ab掉.</p>

<h4 id="推荐信">推荐信</h4>

<p>推荐信至关重要，越多越好。早期建立联系，及早联络。如果自己撰写推荐信，注意使用不同的IP和设备，换不同的作者身份。目前已知，纽约大学会检查此类信息。利物浦大学的计算机科学和电子工程项目对推荐信数量要求越来越严格，请多向相关老师寻求帮助。若推荐信不足，仍然建议提交一些相对一般的申请，因为明尼苏达大学、德克萨斯A&amp;M大学和纽约大学等学校会审查推荐信不足的申请。敢于尝试的话，可以考虑一些不要求推荐信或允许手动提交推荐信的项目，但这并不被推荐，灰色手段不建议使用，但有时不得已而为之…</p>

<h4 id="小补-学长的post">小补: 学长的post</h4>

<p>由于已被删除，我也不愿透露他人信息，我对这篇文章的印象主要包括以下三点：</p>

<ol>
  <li>从3.7到3.8的GPA提升, 对申请的帮助是巨大的,(补充, 比如3.79和3.81是两个水平)。</li>
  <li>强大的软实力对许多项目而言相当重要（学长bg和水平我真的流口水🤤）。</li>
  <li>在录取时，许多项目存在同校竞争的情况（我补充，中外合作项目的竞争，英国本科的竞争，甚至同一所学校的竞争）。</li>
</ol>

<p>DKU本科 2023年秋季的一个申请总结post，因为我不认识他，我直接写了，而且也删除了, 反正很难对应到一个具体的人。</p>

<ol>
  <li>作者大概描述了自己辉煌的本科经历和研究经历，主要集中在金融领域（这里我真想说，DKU的资源确实独特，我顺着论文进去，惊讶地发现有10多个人均参与研究，老师甚至在英国创办了小公司，带领全组发表论文，把我这个小年轻看得一愣一愣的）不过这个po主在这里干了很多工作, 没话说, 有机会人也要中用啊, 我看到这个公司里面一半的人以上都是数据标注,数据处理</li>
  <li>一段实习经历似乎是家里安排在本地银行分行。</li>
  <li>后来的实习经历显然更为出色，水平和本科声誉在线。</li>
  <li>然后就是接近于大满贯大申请结果, 我依稀记得是, ETH, cambridge, 应该有牛津, 不知道有没有duke ece了,应该有, 这个基本是dku本科水平稍微好一点的保底, 最后去向是西北 msai, yyds。</li>
</ol>

<h4 id="天气">天气</h4>

<p>好吧我又来写了, 这在选校的时候还是要考虑一下, 我在英国读了两年, 是真的浑身难受, 整个人都不好了,感觉整个心情和心态都变了很多</p>

<h4 id="dmt">DMT</h4>

<p>快到最后了, 简单的说一下我的专业DMT, 这个专业基本上就是一个CST, 95%相同, 但是更加不合理一点, 到了利物浦以后专业名字变成了CSEE(dmt pathway), OK我可以接受, title说完了. 说说课设, 我其实觉得如果2+的话, DMT的课程设置比CST好一些, 好在压力比CST小一些, 轻松一些. 然后DMT课程的整体设计我的评价是不知道在干什么, ee也想教, cs也想教, 还有一个虚幻的游戏track. 往年dmt的title不能吸引到大一的童鞋, 加上不能2+申请的出路比较惨淡(但是有中过Upenn cggt好像也不能说惨淡), 今年20届莫名其妙吸引到一批人,其实出路还挺好看的, 认识的人里面有Brown CS, Upenn EE, ic bme, USC CS(game dev), ic Analogue and Digital Integrated Circuit Design MSc, nu ce, Cornelltech ece meng, Duke ece. 能在dmt成绩好的话, 我觉得和cst无二, 甚至更好, 当然两个项目的课设我真是无力吐槽, cs的track没os和net, 甚至连选修课的option也无. 我整个本科阶段选修课的数量为…2节课,  year3上c++, xp大一和利物浦year2的课有大量重复的设计, 还有不知道在干什么的强行塞入的信号处理/系统, cs没什么project无数的report, 说说做游戏year2的intro game是必修, 然后就没有了, 再year3的 adv game是不可以选的… 吐槽起来三天三夜也讲不完, 但是dmt录取的门槛比cst低, 加上我个人觉得整体上dmt课程设计稍微比cst好那么一点(50笑百), 更靠近ai一点, cst没进去dmt也还不错, 只比cst输名字, 反正就这样吧.</p>

<h4 id="再谈英国录取">再谈英国录取?</h4>

<p>英国的学校, 什么项目录取了多少人,有多少人申请, 甚至可以看到按种族区分的报告. 这些可以在这个 <strong>whatdotheyknow</strong> 网站上找到. 但是学校是ucl, lse,ic, 牛剑,曼大, 爱丁堡这些, 因为中介只对这些学校感兴趣. 我觉得这个网站有点像论坛，很多都是同一个中国的中介(好像叫kiki)在网站上发问题，要求学校公布项目的录取数据。由于各种原因，学校一定会回复一个像样的报告，但是有些数据是模糊处理的,每个人都可以access,然后在xhs和各种地方就传开了。需要注意的是，申请量和录取人数的对照，不能客观反映项目的录取难度，但如果申请量很大，比如3000+只录取了200+人，那么项目确实是比较难的。我举一个反例，像剑桥大学的pure math part iii作为世界上最著名的硕士项目，申请量实际上并不是非常庞大，每年大约500到700人，尽管现在帝国昔日辉煌已经过去，但是这个项目吸引的申请者基本上都是来自美国本科前20中排名靠前的学校、或者伦敦大学学院/帝国理工学院/华威大学排名前3%的学生？其他的英国本科基本都需要排名第一或第二。我甚至看到过哈佛本科生来申请这个项目，还有申请成功了普林斯顿大学的数学博士然后推迟一年来入读这个项目的。之前30-40年前的part iii的毕业生基本上都是教授，总之很多有学术抱负的数学人才都在申请吧。所以申请这个项目的基本上都是数学排名第一或第二的本校学生，很多都是排名第一或第二的，你说难不难吧。今年我看到UIC和XJTLU都有学生申请到part iii纯数，真的很厉害。据我不负责任的猜测，应该是中外合办第一次接触到part iii纯数。</p>

<h4 id="选校恰饭">选校(恰饭)</h4>

<p>这个section的大部分内容被我删除了，作为有偿分享的部分。价格为303人民币（which = 我在北京办签证时候的第一顿烤肉的费用），可以在付款完成之后，将支付记录和名字发送至以下邮箱：notmyemailcode@gmail.com，使用<strong>学校邮箱(@xjtlu.student.cn/@liverpool.ac.uk)</strong>。提供的信息越详细越好（名字、专业、账号名字、付款时间）。我会尽量在48小时内发送文档。我只是想看看到底能不能收到钱，嘿嘿，玩一下。</p>

<p>但是前景(钱景)貌似比较悲观😭.</p>

<p>另外这个section直接分享出来容易被人骂, 申请季已经被人上嘴脸了, 类似于“这个项目很nb, 你为什么这么说它”, “某某项目明明不错, 你为什么这么评价”. 我想说这些评价本来就很主观应该没有什么对错. 也没有说某个学校的某个项目就比某个学校的某个项目好, bar高的项目也不是肯定就比bar低的项目好, 有很多客观因素要考虑, 比如费用, 天气, 生活的城市, 就业的期望, 课程项目的压力…等等 但是选校恰恰是bar为前提的, 不然没有意义. 所以多种原因吧, 我最后决定不公开共享了, 看看能不能恰到饭和避免引起争议.</p>

<div style="text-align: center;">
  <img src="../assets/images/master-apply/payment.jpg" alt="payment" style="zoom:20%;" />
</div>

<p><strong>如果购买你会得到什么?</strong> 你只会得到一个我编辑的PDF，其中包含对许多项目的主观评价和我自己对一些项目bar的认知 (1w+字)。其实有接近60%的内容来自openCS, 不是100%完全是因为openCS上没有很多ee,ce,ece的项目, 不保证绝对正确，但是是我申请季的一连贯感受和记录。其中包含了2个2025年秋季值得打新的项目和一个录取难度较低的项目。</p>

<p><img src="../assets/images/master-apply/listforXJTLUsele.png" alt="listforXJTLUsele" style="zoom:37%;" /></p>

<p>我觉得这个list/pdf 卖303人民币挺贵的。或者按照某些人的话说就是太不要脸了, 反正你可以理解成我不太想直接分享, 这样?</p>

<p>但是总之, 选校和选项目是申请最重要的步骤, 也是我花费最多时间的步骤,因为这其实是申请季可以唯一应该稍微认真的地方, 因为GPA已经是定数了. 另外其实你本科GPA(3.0以下)完全寄了其实也有办法拯救, 花一年时间可以和西浦cs的3.8+申请结果差不多. 但是选校list还是自己总结整理比较靠谱，选一些自己喜欢的项目，和申请到后肯定会去的保底学校，这样就差不多了。</p>

<p>anyway，想免费拿list也OK。</p>

<p>使用<strong>学校邮箱(@xjtlu.student.cn/@liverpool.ac.uk)</strong>发送邮件到notmyemailcode@gmail.com，简单阐述一下如下主题：</p>

<p><strong>自己准备diy/已经做了什么</strong></p>

<p>好尬…我希望我的选校list可以帮助真正有用的人，而不是一边报了机构一边还想稳一手到处看看的uu，申到了最后又被拿去发一些夸张的录取广告，吸引一波又一波的新韭菜们。然后, 其实我在<strong>后记</strong>中放了大量的链接，很有价值。</p>

<p>anyway，我真的觉得我其实挺菜的。</p>

<p>所有的文本我会在2025年1月15日重新完整更新发在这个page上，如果我还记得的话…</p>

<p><strong>可能有些人有咨询的需求</strong>（笑死，真的有吗），但是我暑假比较忙，就不恰这个钱了。但是可以用email沟通聊上几嘴。另外我的小红书 id是454336362。</p>

<h4 id="提醒"><font color="blue">提醒</font></h4>

<p>如果你报中介的时候发现了如下项目，</p>

<font color="red">UPenn ee、哥大ee、NYU ce、UW ee pmp、UCL Scientific and Data Intensive Computing MSc，其实还有很多但是以上这几个太著名了</font>

<font color="red">还有neu is（几乎是有认知的美国学校的stem研究生项目bar的鞋底）</font>

<p>那么我只能说，你的大几万中介费有很大可能性要打水漂了，因为这些项目对GPA符合要求的西浦选手几乎是来者不拒。在往年，往往年有不断尝试申请和ad的很大数量的cases。就<strong>录取难度</strong>来说，在保证GPA的前提下申请这些<strong>项目难度不大</strong>的（虽然有点太夸张了，但是夸张点说，文书不要骂学校就行）。所以如果你报了中介，可以在申请计划上删除这些学校然后自己申请得了，因为这些项目是中介赚钱的保底 :) 但是，这些项目的质量，我感觉都还是很不错的。</p>

<p>另外关于offer们，我觉得，收到太多平级offer可能没什么意义，比如说，收到3个匹配，或者说3个保底. 比较好的申请结果是一个冲刺（彩票），一个匹配一个保底，所以选校的梯度比较重要，很多申请季认识的朋友除了抱怨中介useless之外，都有点后悔没有申请某某彩票项目. 其实我也是，有些项目投了不就是买个念想，不要在10年以后说“要是当年表白就好了~”，乐。</p>

<h5 id="什么是好项目">什么是好项目</h5>

<p>看美本在申请什么，去美本在去的项目，看大家是如何拿脚投票就行。也注意自己要什么，有的人注重title，有的人注重费用，有的人注重课程设计，都没什么不好的。就其实大学，还是要读出自己的想法上的路子，GPA这种东西申请完废纸一张，西浦GPA4.0社会认可度不如北大2.0一根毛。找工作也不看GPA。而且GPA也不代表知识水平高，考完一年我早忘完了学了什么，大厂也不会因为你GPA高觉得你nb…真的完全没用，导致我现在特别慌。而且申请结束后, 其实成绩已经没有意义了, 相信我真的没有意义了.  到最后，我想到了之前在大二时候看到的《上海交通大学生存指南》中的句子，作者是08年的侯晓迪，是上交低绩点直博Caltech的真神（我一直想不明白为什么有这么神的人，印象最深的一句话是“熬夜最难的是前72小时.”）。不是文章开头的“中国本科教育早已崩溃…”，而是作者在谈博士申请的时候，说“简单的话就读一个硕吧，只要出钱就好”。无限感慨，作者当时轻描淡写的一笔，到现在对我来说还挺难的，在无限担心去gt挂科的各种后果…本人成绩和姿势水平一般，而且记忆力也一般（但是不知道为什么这种申请时候看到的细碎的消息我可以记住然后搜出链接）。</p>

<h4 id="4月25日-2024年-记"><strong>4月25日 2024年 记</strong></h4>

<p>我写的时候一直骂自己，写这种东西干什么，我自己的申请季已经结束了，这种文本的意义对我来说是无效的，可能还要被申请到一些项目的人骂，说“你凭什么这么说这个项目，这个项目挺好的，你配申请到么” 云云。我自己想的是，当我回想半年前，当我开始diy的时候，我是多么希望有一篇这样的东西（<font color="brown">但是我现在知道为什么没有了，又累又对自己没用，吃力不讨好</font>），给xjtlu这种奇怪的本科定定位，我打扰了好多个学长学姐，问出来的消息虽然对我很有帮助, 但是都非常非常零碎。现在我就是想把东西都一股脑的写下来，也许很多都是错的，<font color="red">但是我本身是无所谓，因为我的申请季已经结束了，我拿我写fyp的时间写1w+字（没想到现在2w+了，过3w了，但是会检查删掉敏感内容）的东西不是找人来骂我的，所以希望骂我的人少点。</font> 加上我成绩也没有很好，<strong>也不配给各位大佬指指点</strong>，申请完研究生也远远不代表找工作/申博的成功，而且我个人越来越感觉项目和项目之间的差距没申请前想象的这么大，其实还是人和人之间的差距，因为这个差距实在是太大了， ————删掉了———— 我也发现了好多bg超强和水平的学长学姐…仰望！也非常非常感谢在留学圈加的各位学长学姐给我无私帮助和给我一些建议。</p>

<h4 id="final">final….</h4>

<p>其实我对以后的发展也很迷茫, 西浦给我的高峰, 对我来说就是出申请结果的时候, 我也明白自己平平无奇, 利物浦/西浦的本科毕业证=破纸一张, GPA的作用对找工作可能有个那么1%的作用吧哈哈哈, 而且也有点不想学cs了, 申请了这么多ece, cs, ce也是顺着惯性再走, 研究生上课再难再硬, 对找到一个适合的工作帮助有限甚至是负分. 这也解释了很多master项目的偏水的原因, 因为这些是对职业发展没有帮助的东西, master院校的目的和你的目的都很明确… 说实话, 反正现状和我预想的差距有点大. 但是就目前的现状来看, 我学习的大部分阶段都好幸运, 申请季也超级顺利(补充,美签也过了,yeah!!!), 也认识了愿意帮助我的好多好多好多陌生朋友, 希望剩下的日子也能侥幸和幸运下去~</p>

<p>这下真的到最后了, 也祝大家都有美好的前程…  于 Apr. 27th 2024, Liverpool, Merseyside(写这句话的时间)</p>

<p>好像埋了一个小坑, 没有写如何写ps, cv和sop, 如果这个文章有热度的话可以补一补, 估计又是几千字,有点不想写这个section…会让大家又发现我是真的菜.</p>

<h2 id="后记">后记</h2>

<p>放一些可能有帮助的link, 和当reference用, 我把这些link放在我了我主页的collection的部分中<a href="https://bokehforu.github.io/collection-archive/">点击跳转</a></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">刘未鹏:</span><span class="mi">7</span><span class="n">年在南大生活</span>
<span class="nl">https:</span><span class="c1">//mindhacks.cn/2009/05/17/seven-years-in-nju/</span>
<span class="nl">胡津铭:</span><span class="n">硕士毕业半年的茫茫社招路</span>
<span class="nl">https:</span><span class="c1">//conanhujinming.github.io/post/thoughts_of_hunting_jobs/</span>
<span class="nl">胡津铭:</span><span class="n">高效学习的几个技巧</span>
<span class="nl">https:</span><span class="c1">//conanhujinming.github.io/post/the_art_of_learning/</span>
<span class="nc">Lvmin</span> <span class="nl">Zhang:</span><span class="n">苏大直博斯坦福</span><span class="o">,</span><span class="n">个人主页</span>
<span class="nl">https:</span><span class="c1">//lllyasviel.github.io/Style2PaintsResearch/lvmin</span>
<span class="mi">2019</span><span class="n">南大商科转CS申请总结</span><span class="o">(</span><span class="n">绷不住</span><span class="o">,</span><span class="n">cs专业课比我半科班还多</span><span class="o">)</span>
<span class="nl">https:</span><span class="c1">//github.com/Jason003/19fall-CS-Application-Conclusion</span>
<span class="no">Y</span><span class="o">-</span><span class="no">H</span><span class="o">(</span><span class="n">作者对岸人</span><span class="o">,</span><span class="n">从Upenn科学计算转学GT</span> <span class="no">CSE</span><span class="o">):</span><span class="n">聊聊CSE</span> <span class="n">in</span> <span class="nc">Gatech</span> <span class="o">&amp;</span> <span class="nc">Others</span>
<span class="nl">https:</span><span class="c1">//yuho-yhhsieh.medium.com/%E8%81%8A%E8%81%8Acse-in-gatech-others-40ec3a519089</span>
<span class="n">經驗分享</span> <span class="mi">2024</span> <span class="nc">Fall</span> <span class="n">美國</span> <span class="no">CS</span> <span class="n">碩士申請心得</span> <span class="no">CMU</span> <span class="no">MSAII</span><span class="o">/</span><span class="no">UCSD</span> <span class="no">CS75</span>
<span class="nl">https:</span><span class="c1">//howard0100000.medium.com/2024-fall-%E7%BE%8E%E5%9C%8B-cs-%E7%A2%A9%E5%A3%AB%E7%94%B3%E8%AB%8B%E5%BF%83%E5%BE%97-a6cb08e2817a</span>
<span class="nl">北大:</span><span class="n">出国申请总结</span><span class="err">（</span><span class="n">pure</span> <span class="nc">Computer</span> <span class="nc">Science</span><span class="err">）</span>
<span class="nl">https:</span><span class="c1">//github.com/ZhenbangYou/University-Application--Computer-Science-Graduates-</span>

<span class="nc">Open</span> <span class="no">CS</span><span class="o">,</span> <span class="n">但是注意是陆本的定位</span><span class="o">,</span> <span class="n">主要关注在于项目的录取的bar而不是项目的具体质量</span>

<span class="n">另外</span><span class="o">,</span><span class="n">各位可以看看浙大</span><span class="o">,</span><span class="n">华科历年的飞跃手册</span><span class="o">,</span><span class="n">里面一些对项目的评价总结得很全面</span><span class="o">,</span> <span class="n">虽然bar已经是物是人非了</span>
   
<span class="n">上海交通大学生存手册_新版</span>
<span class="nl">https:</span><span class="c1">//survivesjtu.gitbook.io/survivesjtumanual</span>
<span class="n">上海交通大学生存手册_08年_旧版</span><span class="o">(</span><span class="n">历久弥新</span><span class="o">),</span> <span class="n">曾经推荐给小巴们</span><span class="o">,</span> <span class="n">反响不大hh</span><span class="o">,</span> <span class="n">我一厢情愿了</span>
<span class="nl">http:</span><span class="c1">//www.houxiaodi.com/assets/misc/manual.pdf</span>
<span class="nc">Randy</span> <span class="nc">Pausch</span> <span class="nl">最后一课:</span> <span class="nc">Achieving</span> <span class="nc">Your</span> <span class="nc">Childhood</span> <span class="nc">Dreams</span>
<span class="nl">https:</span><span class="c1">//www.youtube.com/watch?v=ji5_MqicxSo</span>
<span class="no">CARRIE</span> <span class="nl">ANNE:</span> <span class="nc">Crash</span> <span class="nc">Course</span> <span class="nc">Computer</span> <span class="nf">Science</span><span class="o">(</span><span class="n">我大三才看到</span><span class="o">,</span> <span class="n">对了解计算机学科非常有帮助</span>
<span class="nl">https:</span><span class="c1">//www.bilibili.com/video/BV1EW411u7th/?share_source=copy_web&amp;vd_source=827dfb109fc21cf17537658558bd420a</span>
<span class="n">小众宝藏项目</span><span class="err">：</span><span class="nc">Cornell医学院Biostats</span> <span class="o">&amp;</span> <span class="nc">Data</span> <span class="nc">Science</span><span class="err">，</span><span class="n">体验</span><span class="o">/</span><span class="n">经验</span><span class="o">/</span><span class="nl">就业情况https:</span><span class="c1">//www.1point3acres.com/bbs/thread-730072-1-1.html</span>
<span class="o">[</span><span class="n">申请总结</span><span class="o">]</span> <span class="o">[</span><span class="n">长篇申请经验分享</span><span class="o">]</span> <span class="err">【</span><span class="n">转码之路</span><span class="err">——</span><span class="n">我的22</span> <span class="nc">Fall申请季总结</span><span class="err">】（</span><span class="n">万字长文</span><span class="err">，</span><span class="n">内含大量干货</span><span class="err">）</span>                                      <span class="nl">https:</span><span class="c1">//www.1point3acres.com/bbs/thread-892753-1-1.html</span>
<span class="n">如何选择美国CS</span> <span class="nc">Master项目</span><span class="err">？</span><span class="o">(</span><span class="mi">2018</span><span class="n">年</span><span class="o">)</span> <span class="nl">https:</span><span class="c1">//zhuanlan.zhihu.com/p/19908606                                           </span>
</code></pre></div></div>

<p>Finally, 如果你觉得这篇文章对你有帮助的话, 感谢支持,下面的支付button适合任何国际credit/debit card.</p>

<script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="yanjiaqiid5" data-color="#FFDD00" data-emoji="" data-font="Cookie" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff"></script>

<h4 id="声明"><strong>声明</strong></h4>

<p>我尽量去除了敏感信息, 如果还有希望删除的内容, 请使用邮件提示我删除</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">申请总结是根据我本人兴趣自发撰写完成</span><span class="err">，</span><span class="n">版权属于我本人</span><span class="err">。</span><span class="n">在本总结撰写过程中</span><span class="o">,</span> <span class="n">我尽量客观</span><span class="o">,</span> <span class="n">没有接受其他任何组织任何形式的支持</span><span class="err">。</span><span class="n">未经我许可</span><span class="err">，</span><span class="n">任何组织或个人不得违反相应的版权条例抄袭</span><span class="err">、</span><span class="n">转载</span><span class="err">、</span><span class="n">摘编</span><span class="err">、</span><span class="n">修改内容</span><span class="err">；</span><span class="n">不得将本文章用于商业目的</span><span class="err">；</span><span class="n">不得对本文章原意进行曲解</span><span class="err">、</span><span class="n">修改和未授权的大范围分发</span><span class="err">。</span>

<span class="n">本文章并不规定任何明确的行动建议</span><span class="err">，</span><span class="n">只做简单的推荐</span><span class="err">，</span><span class="n">因此作者不承担由此产生的衍生责任</span><span class="err">。</span>

<span class="n">本文章作者不能保证手册内容中没有对其他组织的误解和偏见</span><span class="o">,</span><span class="n">或者是潜在的误解和偏见</span><span class="err">。</span><span class="n">本文章内容的正确性并没有经过权威审查</span><span class="err">，</span><span class="n">本文章作者无法保证内容</span><span class="o">,</span><span class="n">方法始终有效</span><span class="err">。</span><span class="n">本文章作者亦无力确认是否违反了读者所在地的各种法规</span><span class="err">，</span><span class="n">请参照当地行政规定</span><span class="err">。</span><span class="n">如有违反</span><span class="err">，</span><span class="n">请您停止阅读并立即销毁本文章的任何副本</span><span class="err">。</span><span class="n">对于未经授权传播本文章而造成的各种问题</span><span class="err">，</span><span class="n">本文章作者概不负责</span><span class="err">。</span><span class="n">本文章作者无法确定文章内容是否会对读者身心健康产生不良影响</span><span class="err">。</span><span class="n">如果您未满18岁</span><span class="err">，</span><span class="n">或因阅读本文章而产生不适</span><span class="err">，</span><span class="n">请立即停止阅读并咨询心理医生</span><span class="err">。</span>

<span class="n">本文章欢迎接受您的指教</span><span class="err">。</span> <span class="n">如果您对文章内容有任何问题</span><span class="err">、</span><span class="n">或建议</span><span class="o">,</span> <span class="n">请联络我</span><span class="err">：</span>

<span class="n">notmyemailcode</span><span class="nd">@gmail</span><span class="o">.</span><span class="na">com</span><span class="o">(</span><span class="n">真的是我邮箱</span><span class="o">)</span>

<span class="n">我并不保证回复每一封建议邮件</span><span class="err">，</span><span class="n">但是我会认真接受并思考您的意见</span><span class="o">,</span> <span class="n">并在后续md内容中做出相应的改进和更新</span><span class="err">。</span>
</code></pre></div></div>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Inner producted 一些问题</title><link href="http://localhost:4000/inner-producted/" rel="alternate" type="text/html" title="Inner producted 一些问题" /><published>2023-10-09T00:00:00-04:00</published><updated>2023-10-09T00:00:00-04:00</updated><id>http://localhost:4000/inner%20producted</id><content type="html" xml:base="http://localhost:4000/inner-producted/"><![CDATA[<p>A record of some simple ideas.</p>

<h2 id="vector-inner-product">vector inner product</h2>

<p><strong>向量的内积</strong></p>

<ul>
  <li>内积的定义:
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>设A和B为两个向量,它们的内积定义为A在B上的投影长度,用公式表示为&lt;A,B&gt; =</td>
              <td>A</td>
              <td> </td>
              <td>B</td>
              <td>cosθ,其中θ是两向量之间的角度。</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>内积的几何意义:内积反映了两个向量间的相似程度,当两个向量方向相同时内积最大;when两向量垂直时内积为0。</p>
  </li>
  <li>
    <p>如何计算两个向量的内积:设两个n维向量为A=(a1,a2,…,an),B=(b1,b2,…,bn),则两向量的内积为&lt;A,B&gt; = a1b1 + a2b2 + … + anbn,即对应元素相乘并求和。</p>
  </li>
  <li>内积为何等于零:当两个向量垂直时,cosθ=0,从内积公式可知此时&lt;A,B&gt;=0。也就是说,内积等于零表示两个向量互相垂直。</li>
</ul>

<h2 id="matrix-inner-product">matrix inner product</h2>

<ul>
  <li>矩阵内积的定义:对于两个矩阵A和B,它们的内积定义为:&lt;A,B&gt; = tr(A^TB),即矩阵A与B转置矩阵的乘积的<strong>迹</strong>,什么是迹，就是从左到右的对角线。</li>
  <li>矩阵内积与迹的关系:矩阵内积用矩阵迹来表达,迹反映了矩阵的特征,内积刻画了两个矩阵间的相关性。</li>
  <li>如何计算两个矩阵的内积:对两个矩阵A和B,计算A^TB,然后求出其迹(对角元素之和)即可。</li>
  <li>矩阵内积的性质:
    <ul>
      <li>对称性 &lt;A,B&gt; = &lt;B,A&gt;</li>
      <li>双线性形式</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>范数不等式$</td>
              <td>&lt;A,B&gt;</td>
              <td>&lt;=</td>
              <td> </td>
              <td>A</td>
              <td> </td>
              <td>·</td>
              <td> </td>
              <td>B</td>
              <td> </td>
              <td>$ <font color="red">这啥</font></td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>matrix的变换。</li>
</ul>

<h2 id="fx-and-gx-inner-product">f(x) and g(x) inner product</h2>

<ul>
  <li>
    <p>函数内积的定义:对于区间[a,b]上的连续函数f(x)和g(x),它们的内积定义为\(\langle f, g\rangle=\int_a^b f(x) g(x) d x\)</p>
  </li>
  <li>
    <p>如何利用积分计算函数内积:将函数相乘后对区间[a,b]积分,即可计算内积。</p>
  </li>
  <li>
    <p>函数内积的双线性形式:满足α&lt;f,g&gt; = &lt;αf,g&gt; = &lt;f,αg&gt;</p>
  </li>
  <li>
    <p>函数内积与区间长度的关系:内积与区间长度成正比,因此也会normalize由 $\int ab$  改为 $\int \frac{ab}{L}$。</p>
  </li>
  <li>
    <p>函数内积的应用:反映函数间相关性,应用于信号处理、模式识别等领域。</p>
  </li>
</ul>

\[\langle f, g\rangle=\int_a^b f(x) g(x) d x\]

<p>or another choice</p>

\[\langle f, g\rangle=\frac{1}{b-a} \int_a^b f(x) g(x) d x\]

<p>第一种表示法:</p>

\[\langle f, g\rangle=\int_a^b f(x) g(x) dx\]

<p>直接对函数的乘积在区间[a,b]上进行积分即可得到内积。</p>

<p>第二种表示法:</p>

\[\langle f, g\rangle=\frac{1}{b-a}\int_a^b f(x) g(x) dx\]

<p>在积分中额外引入了比例系数$\frac{1}{b-a}$,目的是归一化区间[a,b]的长度,使得内积不直接依赖于区间长度。</p>

<h2 id="应用傅立叶级数">应用：傅立叶级数</h2>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[A record of some simple ideas.]]></summary></entry><entry><title type="html">Discrete Mathematics</title><link href="http://localhost:4000/CMU-Discrete-mathematics-2001-notes/" rel="alternate" type="text/html" title="Discrete Mathematics" /><published>2023-08-30T00:00:00-04:00</published><updated>2023-08-30T00:00:00-04:00</updated><id>http://localhost:4000/CMU%20Discrete%20mathematics%202001%20notes</id><content type="html" xml:base="http://localhost:4000/CMU-Discrete-mathematics-2001-notes/"><![CDATA[<p>虎头蛇尾…</p>

<h1 id="离散数学-cmu-2001-notes">离散数学 CMU 2001 notes</h1>

<h1 id="lec1">Lec1</h1>

<h2 id="intro">intro</h2>

<p>…</p>

<h2 id="set">Set</h2>

<ol>
  <li>
    <p>首先定义空集的概念  $\empty$ <strong>Definition</strong>: the only set include no elements.</p>
  </li>
  <li>
    <p>交并补的概念    <font color="red">补充</font></p>
  </li>
</ol>

<h2 id="the-sum-principle补充">The Sum Principle<font color="red">补充</font></h2>

<h2 id="proof-of-ramseys-theorem">Proof of Ramsey’s Theorem</h2>

<p>你想证明的这个等式可以通过组合数的性质和帕斯卡三角形来解释和证明。以下是证明的一种方式：</p>

<p>首先，我们知道组合数 $\binom{n}{m}$ 表示从 $n$ 个元素中选择 $m$ 个元素的组合数。这可以表示为：</p>

\[\binom{n}{m} = \frac{n!}{m!(n-m)!}\]

<p>同样，$\binom{n}{m+1}$ 表示从 $n$ 个元素中选择 $m+1$ 个元素的组合数：</p>

\[\binom{n}{m+1} = \frac{n!}{(m+1)!(n-m-1)!}\]

<p>然后，我们来看左边的等式：</p>

\[\binom{n}{m} + \binom{n}{m+1}\]

<p>将上述两个组合数的表达式代入，得到：</p>

\[\frac{n!}{m!(n-m)!} + \frac{n!}{(m+1)!(n-m-1)!}\]

<p>现在，我们的目标是将这个式子变形成 $\binom{n+1}{m+1}$ 的形式。我们注意到，$\binom{n+1}{m+1}$ 也是从 $n+1$ 个元素中选择 $m+1$ 个元素的组合数：</p>

\[\binom{n+1}{m+1} = \frac{(n+1)!}{(m+1)!(n-m)!}\]

<p>我们希望将左边的式子变形成 $\binom{n+1}{m+1}$ 的形式。为此，我们可以考虑如何将两个分数相加，使得分母部分与 $\binom{n+1}{m+1}$ 相同。我们观察到：</p>

\[\frac{n!}{m!(n-m)!} + \frac{n!}{(m+1)!(n-m-1)!} = \frac{(n+1)!}{(m+1)!(n-m)!}\]

<p>上述等式成立是因为分子部分相等。这就完成了证明。</p>

<p>因此，我们证明了：</p>

\[\binom{n}{m} + \binom{n}{m+1} = \binom{n+1}{m+1}\]

<p>这个等式在组合数学中被称为 Pascal’s Rule（帕斯卡规则），它在帕斯卡三角形中有重要的几何解释。</p>

<h2 id="下面笔记使用北理莫斯科的lec-notes">下面笔记使用北理莫斯科的lec notes</h2>

<h2 id="fri-18th">Fri. 18th</h2>

<h2 id="32-集合的概念">3.2 集合的概念</h2>

<p><strong><font color="green">集合 </font></strong></p>

<p><strong>定义</strong> 我们指元素的组合。</p>

<p><strong>数学描述</strong><font color="red">latex打不出空格</font>{} 
\(A={a:a满足specific的性质}\)
<strong><font color="green">两个集合的差集 </font></strong></p>

<p><strong>定义</strong></p>

<h3 id="322-关系">3.2.2 关系</h3>

<h4 id="二元关系">二元关系</h4>

<font color="red">什么是二元关系，没有被定义</font>

<font color="blue">我觉得是两个未知数的关系就是2元关系</font>

<font color="red">问:满足函数关系的本事是不是要满足映射关系，映射关系set A 到set  B，从一个A的element出发，只对应一个set B中的b，但是没有说是满射(满射)的英文是什么onto？</font>

<p><strong>onto</strong> 是set B 中的b elements at least 对应一个 set A中的a</p>

<h2 id="8-20th-计数">8 20th 计数</h2>

<p>例 3.16. 定义 $[n]^{(r)}={T \subseteq{1,2, \ldots, n}:|T|=r}$. 设 $\mathcal{A} \subseteq[n]^{(r)}$. 设 $s&gt;r$ 。定义
\(\mathcal{B}=\left\{B \in[n]^{(s)}: \exists A \in \mathcal{A}, \text { s.t. } A \subseteq B\right\} .\)
$|\mathcal{B}|$ 有多大呢（当然 $|\mathcal{B}|$ 依赖于 $|\mathcal{A}|)$ ?
解答. 上界：根据定义 $\mathcal{B} \subseteq[n]^{(s)}$ ，所以 $|\mathcal{B}| \leq\left|[n]^{(s)}\right|=\left(\begin{array}{l}n \ s\end{array}\right)$.
下界：考虑如下集合
\(M=\{(A, B) \in \mathcal{A} \times \mathcal{B}: A \subseteq B\} .\)
分别采用 $\mathcal{A}$ 和 $\mathcal{B}$ 的观点来计算 $|M|$ 。</p>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>从 $\mathcal{A}$ 的观点：对每个 $A \in \mathcal{A}, A$ 包含在 $\left(\begin{array}{l}n-r \ s-r\end{array}\right)$ 个不同的 $B$ 中。因此, $</td>
          <td>M</td>
          <td>=</td>
          <td>\mathcal{A}</td>
          <td>\left(\begin{array}{l}n-r \ s-r\end{array}\right)$.</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>从 $\mathcal{B}$ 的观点：对每个 $B \in \mathcal{B}, B$ 最多包含 $\left(\begin{array}{l}s \ r\end{array}\right)$ 个不同的 $A$ 。因此, $</td>
          <td>M</td>
          <td>\leq</td>
          <td>\mathcal{B}</td>
          <td>\left(\begin{array}{l}s \ r\end{array}\right)$.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="解释">解释</h3>

<font color="red">$[n]^{(r)}=\{T \subseteq\{1,2, \ldots, n\}:|T|=r\}$</font>

<p>对这个定义的明晰</p>

<table>
  <tbody>
    <tr>
      <td>$[ ]$ and $()$ 都是对set的描述，其中集合中元素的个数的表示方法是$</td>
      <td>A</td>
      <td>$ ，比如$</td>
      <td>\mathcal{P}(A)</td>
      <td>=2^{</td>
      <td>A</td>
      <td>}$</td>
    </tr>
  </tbody>
</table>

<p>${T \subseteq{1,2, \ldots, n}}$</p>

<p>则表示$T$ 被这个set包含，T中可能有1-n之间的元素，</p>

<table>
  <tbody>
    <tr>
      <td>$</td>
      <td>T</td>
      <td>=r$</td>
    </tr>
  </tbody>
</table>

<p>说明T的size就是r</p>

<p>$[n]^{(r)}$</p>

<p>说明有r组n这个set要配对，T中的元素分别输出到n值</p>

<p>$[n]^{(r)}$ 表示从集合 ${1, 2, \ldots, n}$ 中选取$r$个元素的所有可能集合。而不是 “有r组n这个set要配对，T中的元素分别输出到n值”。</p>

<p>$[n]^{(r)}$ 表示的是从集合 ${1, 2, \ldots, n}$ 中选取$r$个元素的所有可能集合，而不是将元素与n进行配对。</p>

<h2 id="康尔托对角线证法">康尔托对角线证法</h2>

<p>主要的构造方法是在[0,1]中，使用小数表示一个自然数，或者说使用一个双射来连接关系的情况下，特使得$x_{ij}(j=i)$ 的位置设置一个不同数，使用这个方式，当一个数字的每个数上的位置，不可以被对角线上对应位置的数字表示的时候，就说明他</p>

<h2 id="图-tue">图 Tue.</h2>

<h3 id="定义41">定义4.1</h3>

<p><strong>欧拉通路</strong>：经过图中的每一条边一次且仅一次。</p>

<p><strong>欧拉回路</strong>：经过图中的每一条边一次且仅一次，且回到出发点。</p>

<h3 id="定义42">定义4.2</h3>

<p>设 v 是图中的某个顶点，与 v 连接的边的数目叫做 v 的度数，记作 d(v)。</p>

<p>###命题 4.3</p>

<p>对任意的图 G，如果图 G 中存在一条欧拉<strong>通路</strong>，则<strong>最多</strong>只有<strong>两个</strong>点的度数是奇数。</p>

<h3 id="命题-44">命题 4.4</h3>

<p>对任意的图 G，如果图 G 中存在一条欧拉<strong>回路</strong>，则<strong>每个</strong>点的度数都是<strong>偶数</strong></p>

<p><em>命题4.4和4.3 只可以判断在本身存在时，这里的检测方法就是说，</em></p>

<h3 id="定义-45">定义 4.5</h3>

<p>一个（无向，即边没有方向）图 $G$  由点和边组成，点的集合通常用$V$   表示，边的集合用 $E$  表示。图 $G$ 一般写作
\(G = (V, E)\)
<strong>点的相邻</strong> 两个<strong>点</strong>有边</p>

<p><strong>边的相邻</strong> 两个边之间有点</p>

<p><strong>点的度数</strong> 点发散或者接收的条数</p>

<p><strong>简单图</strong> 两点之间最多一条边（不会不复杂，但是会没有来回</p>

<font color="red">**通路** 从一点到另一点由边连接的序列（点和边均允许重复）</font>

<font color="red">**路径** **点**<font color="green">不重复</font>的通路</font>

<font color="red">**回路** 起点和终点相同的通路</font>
<p><strong>(到底是一个成环的路还是？首尾链接的路可以)</strong></p>

<p><strong>连通图</strong> 任意两点之间均有通路连接</p>

<p><strong>子图</strong> 由图的某些点和这些点上某些边组成的图</p>

<p>导出子图：由图的某些点和这些点上所有的边组成的图/<em>感觉没什么用，就是选了一些线和点呗</em></p>

<p>连通分支：</p>

<h3 id="定理47">定理4.7</h3>

<p>对任意的连通图 G，</p>

<ul>
  <li>图 G 中存在一条欧拉通路，<strong>当且仅</strong>当要么每个点的度数都是偶数，要么恰有两点的度数是奇数。</li>
  <li>图 G 中存在一条欧拉回路，<strong>当且仅当</strong>每个点的度数都是偶数。</li>
</ul>

<p><strong><em>充分必要？</em></strong></p>

<h3 id="定理48-49握手定理和其的推论">定理4.8 &amp;4.9握手定理和其的推论</h3>

<p>有点问题</p>

<p>使用对称理论证明</p>

<h2 id="树与环-aug-25th">树与环 Aug. 25th</h2>

<p>定义</p>

<h2 id="aug-26th-图的同构">Aug. 26th 图的同构</h2>

<p><strong>定义</strong></p>

<p>对有些问题而言，我们只关心边的相互关系，并不对顶点做过多区分，数学上我们考虑一个新的概念，叫做同构。</p>

<p>满足双射，在两个图$G=(V,E)$ 和$H=(V’,E’)$中，</p>

<p>三个算法</p>

<h3 id="1-贪心算法-最小生成树-kruskal-算法">1. 贪心算法 最小生成树 Kruskal 算法</h3>

<p>具向的理解是首先把最短到最长的权重的line升序排列取出，再使用这些line上的权重值进行连接，在连接时观察是否连结成环，如果成环，则取消</p>

<h3 id="2-信息熵算法">2. 信息熵算法</h3>

<h3 id="3-dijkstra-算法">3. Dijkstra 算法</h3>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[虎头蛇尾…]]></summary></entry></feed>