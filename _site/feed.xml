<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-05-27T13:41:20+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chia-ch’i‘s Web page</title><subtitle> </subtitle><author><name>Chia-ch&apos;i</name></author><entry><title type="html">2025-05-23 Leetcode 146.LRU 5433字记录思考的过程</title><link href="http://localhost:4000/146.-lru/" rel="alternate" type="text/html" title="2025-05-23 Leetcode 146.LRU 5433字记录思考的过程" /><published>2025-05-23T00:00:00+08:00</published><updated>2025-05-23T00:00:00+08:00</updated><id>http://localhost:4000/146.%20lru</id><content type="html" xml:base="http://localhost:4000/146.-lru/"><![CDATA[<p><em>使用 GPT refine 了文章</em></p>

<p>2025-05-25</p>

<p>读完题目, 我们需要设计一个支持以下操作的数据结构：<code class="language-plaintext highlighter-rouge">get</code> 和 <code class="language-plaintext highlighter-rouge">put</code>，并且这两个操作都要在 $O(1)$ 时间内完成。为了实现这一点，我们结合使用了 <strong>哈希表（dict）</strong> 和 <strong>双向链表（Doubly Linked List, DLList）</strong>, 这里补充的时候, 刚做这个题目的难点的, 这两个操作同时还要实现在时序上的 order.</p>

<p><strong>为什么需要链表, 而且是 DDList</strong>？单用 Python 中的 <code class="language-plaintext highlighter-rouge">dict</code> 虽然查找快，但无法保持数据的访问顺序；而使用 <code class="language-plaintext highlighter-rouge">list</code> 虽然可以维护顺序，却无法在 $O(1)$ 时间内删除任意节点。而另外一个基础结构, 链表, 实现一个 stack 的时候, 我们在头结尾上添加和删除, 这就都是 O1 的,但是这个时候我们想到了, 我们这个题的逻辑在删除上是也是要 O1 的, 而且应该是从 tail 上删除, 这相当于实现了一个可以前进后出的队列, 但是链表的尾部删除是是 On 的, 就算我们有一个 tail 指针也是一样, 因为我们不知道 tail 这个 node 的前面是什么位置是哪个 node, tail 在被删除之后, 要重新遍历一遍找到新的 tail, , 除非我们在访问的一个节点的时候, 我们可以知道这个 node 的前面是是哪个节点, 方法呼之欲出了—- 使用 <strong>双向链表</strong> 来存储所有的缓存节点，并维护最近访问的顺序。最近使用的节点放在链表头部，最久未使用的节点在链表尾部；当容量超限时，我们就移除尾部节点。</p>

<p>然后, 我们想一下如何建立链表, 简单, 使用一个 node class 就行了, 于是我们开了一个新的 class, 如下</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span> <span class="c1"># why? 
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>这里的关键点是：<strong>为什么节点中还要记录 <code class="language-plaintext highlighter-rouge">self.key</code>？</strong>
这是因为我们在删除最久未使用节点的时候（也就是链表尾部节点），需要从哈希表中同步删除对应的项。我们能通过链表找到这个节点 <code class="language-plaintext highlighter-rouge">node</code>，但要从哈希表中 <code class="language-plaintext highlighter-rouge">O(1)</code> 时间地删除 <code class="language-plaintext highlighter-rouge">table[key]</code>，就必须知道它对应的 key。</p>

<blockquote>
  <p>你可能会问，为什么不能直接使用这个 node 本身作为哈希表的 key 呢？这是 Python 和 Java 的一个差异。在 Python 中，字典的 key 默认是通过对象的 id（即地址）来计算的 hash 值，除非手动重写 <code class="language-plaintext highlighter-rouge">__hash__</code> 和 <code class="language-plaintext highlighter-rouge">__eq__</code> 方法。而且即使两个节点 <code class="language-plaintext highlighter-rouge">Node(key=1, val=100)</code> 看起来值一样，它们的实例地址是不同的。因此不能指望用节点本身作为哈希表的 key 来查找。</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>  <span class="c1"># False
</span></code></pre></div></div>

<blockquote>
  <p>这意味着，即使两个 node 的内容一样，它们不是同一个 key。所以我们不能用 node 当 key，只能用原始输入的 <code class="language-plaintext highlighter-rouge">key</code>。</p>
</blockquote>

<p>从功能逻辑上再解释一次：</p>

<ul>
  <li>哈希表 <code class="language-plaintext highlighter-rouge">table</code> 提供 $O(1)$ 的 key 到节点的映射。</li>
  <li>双向链表记录访问顺序，支持 $O(1)$ 的插入和删除操作。</li>
  <li>当我们访问一个 key（<code class="language-plaintext highlighter-rouge">get</code> 或 <code class="language-plaintext highlighter-rouge">put</code> 更新已有 key）时，我们需要：
    <ol>
      <li>在哈希表中快速找到对应的 node。</li>
      <li>把这个 node 移到链表的头部（代表最近访问）。</li>
    </ol>
  </li>
  <li>当容量满了时：
    <ol>
      <li>我们从链表尾部拿到最旧的节点 <code class="language-plaintext highlighter-rouge">node</code>。</li>
      <li>通过 <code class="language-plaintext highlighter-rouge">node.key</code> 在哈希表中删除对应条目。</li>
    </ol>
  </li>
</ul>

<p>所以我们必须在每个 <code class="language-plaintext highlighter-rouge">Node</code> 中保留 <code class="language-plaintext highlighter-rouge">self.key</code>，因为这是唯一能让我们在 $O(1)$ 时间内，从哈希表中同步删除那一项的手段。</p>

<p>这个结构的设计核心就是：<br />
**哈希表用于快速定位，双向链表用于维护访问顺序。两者结合才能实现整体的 $O(1)$ 性能目标。</p>

<p>更加高屋建瓴地讲, 从 <a href="https://xiaobot.net/post/1354728a-277d-4429-a163-2212ef171a3a">Infra 面试之数据结构六：LRU</a> 文章来说, 解这道题的关键是如何管理复杂度, 把这个难的问题拆开来(难, 只是因为拆的不够简单)
宏观上，代码组织思路：</p>
<ol>
  <li>将该数据结构分为<strong>数据和索引</strong>两部分</li>
  <li>数据用链表组织，可动态维护时间先后。可保证替换时间复杂度为 $O(1)$</li>
  <li>索引用哈希表组织，用于快速查找删除。可保证增删时间复杂度为 $O(1)$ 
这种数据、索引分离考虑的思想，借鉴数据库的聚集索引|和二级索引.</li>
</ol>

<p>当然还有题目实现上的细节需要考虑
OK, 我们继续
从下面的这个题目中的空代码出发</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        


<span class="c1"># Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value
</span>
</code></pre></div></div>

<h1 id="original-分步骤部分-这个部分用-gpt-gemini-refine-之后发现变化特别大-保留原始部分了">original 分步骤部分 (这个部分用 GPT Gemini refine 之后发现变化特别大, 保留原始部分了)</h1>
<p>现在我们已经写好了, 这里除了一些算法上的实现细节, 其实有两种大的逻辑, 实现同样的功能,</p>
<ol>
  <li>是在比对了有 key 之后使用原来的内存地址上的点, 进行 detach, 再使用同一个移动到最前面的位置,</li>
  <li>是在对比有了 key 之后, 直接删除, 然后新创建一个 node 连在 head 后面, 这样会使用更加多的内存开销, 但是实现上更加简单, 而第二种其实代码更加复杂来避免反复的新建, 使用大量的内存, 所以我觉得第一种是第二种的优化, 所以我先写第二种, 再从优化的角度写第一种</li>
</ol>

<p>OK, 我们现在有, <font color="red">这里有一个初始值设定的问题, 有些会写 key = None 是什么的</font> , 继续写下面的代码,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">node</span><span class="p">:</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="n">val</span><span class="p">):</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    	<span class="c1"># table
</span>    	<span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>
        
        <span class="c1"># DDlist
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>
        
        <span class="c1"># input capacity
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
</code></pre></div></div>
<p>OK, 继续是初始化的步骤, 在这个位置想的是什么呢, 第一个是我们要 table , 第二个是我们要有链表啊, OK, 这就是所有了, 当然还有一个在使用链表做题时候一个 tricky 的地方, 就是
OK,在写了之后, 要继续想, 就是我们具体其实要操作的是数据结构本身, 那么, 其实, 这个要在上面画什么的决策树其实是 table 的添加和删除, 还有链表的添加和删除, 但是字典的添加和删除很简单, python 中都已经有接口实现了, 这时候注意, 我们的链表是我们本身创建的结构, 这个删除和添加的逻辑 python 并没有给我们,</p>

<blockquote>
  <p><strong>很多题解都写在 class LRUCache 下,</strong> 我的疑问是能不能写在 node 中, 好像是可以的, <code class="language-plaintext highlighter-rouge">_delete</code> 操作删除 node, 哦哦哦不行? class 中的方法, 可以删除自己吗, 应该可以吧, 再想想插入的方法, 我一般要插入的话要干什么, 都是更新在最新的位置, 那么就是说, 好像和 table 也没什么关联, 那么, 问题就剩下, 如果, 写在本身的话, 插入和删除的输入可不可以是自己, 应该可以是自己的吧, 因为递归的输入就是自己,</p>
</blockquote>

<p>OK 上面的问题的产生是因为我把 <code class="language-plaintext highlighter-rouge">class node</code> 和 <code class="language-plaintext highlighter-rouge">class doublelinkedlist</code> 弄混淆了, 也就是说, 其实这里我们的面向对象编程也省略掉了要创造 doublelinkedlist 这一步, 所以这里这个问题会出现是因为, 我没有思考过的. 继续, 我们先在 <code class="language-plaintext highlighter-rouge">class LRUCache</code> 中写我们的方法</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
	<span class="s">'''
	ignore upper codes
	'''</span>
	
	<span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
	<span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
</code></pre></div></div>
<p>其中删除的逻辑很简单, 就交给 python 的内存回收机制就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
	<span class="c1"># node.prev
</span>	<span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
	<span class="c1"># node.next 
</span>	<span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>
</code></pre></div></div>
<p>但是,这里的 ` _update<code class="language-plaintext highlighter-rouge"> 要使用 key 吗, 不清楚, 但是可以先写, 首先理解这个逻辑是, 如果存在在 DLList 中, 就 ... 如果不在那么就可以直接加在 head 的后面, OK, 从这个逻辑出发, 我们的 </code> _update` 方法是需要 key 的, 不然, 如何用 table $O(1)$ 时间地来判断重复呢? (这里也说明这个方法要在)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 错了吗
</span></code></pre></div></div>

<p>所以我们认为这个 <code class="language-plaintext highlighter-rouge">_update</code> 方法需要我们的 key, 在没有做这个题之前, 我觉得我确实想不出来, 因为这些关系都是交织的, 很难一下子直接分割到最小, 所以写成 <code class="language-plaintext highlighter-rouge">def _update(self, node, key): </code> 哦是这样吗? 错了, 只是更新一个 node, 但是 key 不更新的话, 那么其实我们也不需要这个 key 了, OK,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1"># 对的?
</span></code></pre></div></div>

<p>其实, 我现在感觉没有这个对错, 问题的关键在于这个 key 的作用, 是什么作用, 要不要想不想切割到最小, 这个感觉, OK, 那先按照现在的思路继续写
然后想一下, 这个方法要干什么, 现在排除掉了检测, 其实就是什么呢, 就是要实现了一个链表的插入节点的操作, 一共有三个节点的状态应该考虑, 分别是 head, head.next, node</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>

	<span class="c1"># 从 head位置, 插入
</span>	<span class="n">headnxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
	
	<span class="c1"># node的前后
</span>	<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
	<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">headnxt</span>
	
	<span class="c1"># 原先的head后面的node的prev要接上新的node
</span>	<span class="n">headnxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>

<p>OK, 那么现在就剩下题目原来的 put 和 get 方法了, 现在, 想一想这个方法要干什么, get 是要检查有没有(注意更新最近使用), 然后 put 是要完成插入的逻辑, 同时要注意更新最近的逻辑, 同时要注意整体的 size, 因为这个 cache 有 capacity. 
get 比较简单, 先写 get, 大的框架是有 or 没有的逻辑, 这是很简单想到的,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
	
	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>OK, 那么继续实现一下</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		
		<span class="c1"># 返回那个对应table[key]
</span>		<span class="c1"># 要在前面更新
</span>	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
	<span class="c1"># 有
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="c1"># 创建
</span>		<span class="n">tempnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		
		<span class="c1"># 删除
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="c1"># 要吗?
</span>		<span class="c1"># 新建?
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempnode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempnode</span> <span class="c1"># 其实前面不要删除更新一下就行了
</span>		<span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
	<span class="c1"># 没有
</span>	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>那么还剩下一个 put 的方法了, 想一想逻辑,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
</code></pre></div></div>
<p>把决策树都画出来,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">输入key</span>
	<span class="n">如果在其中有key的话</span>
		<span class="n">删除原先的node在链表和table中</span>
		<span class="n">添加这个新的node到head后面</span>
		<span class="n">更新table</span>
	<span class="n">如果在其中没有key的话</span>
		<span class="n">现在的node放在head后面</span>
		<span class="n">table更新一下</span>
	<span class="n">最后检查size</span><span class="p">,</span> <span class="n">如果超过capacity就从tail开始删除一个</span>
	
</code></pre></div></div>

<p>写, 这里要注意 table 和链表删除的顺序, 应该先从链表上删除, 因为使用 table 可以用 $O(1)$ 的时间访问对应的节点, 但是如果先在 table 上把这个节点删除掉的话, 那么我们会丢失这个用 key 快速访问的能力, 但是相反的, 我们的删除逻辑本身运行后, 不会影响我们 table 的逻辑, 因为我们是改变 key 对应的 node 的前后连接关系, 而不是说让这个 node 本身变成 None, 但是好像即使是变成 None 也没什么关系, OK, 这里就说完了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
		
	<span class="k">else</span><span class="p">:</span> <span class="c1"># no key in self.table
</span>		<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>
	
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="n">delnode</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
		
		<span class="c1"># del 
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">delnode</span><span class="p">)</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">delnode</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></div>

<p>OK 现在都写完了, 那么, 整体的全部代码如下,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1"># table
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># DLList
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>

        <span class="c1"># input capacity
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>

    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">headnxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">headnxt</span>
        <span class="n">headnxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="c1"># 有key的情况下
</span>        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="c1"># 创建
</span>            <span class="n">tempnode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span><span class="p">)</span>

            <span class="c1"># 删除
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="c1"># del self.table[key]  # 不需要删除，table 直接覆盖
</span>
            <span class="c1"># 新建并更新
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempnode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempnode</span>

            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
        <span class="c1"># 没有key的情况下
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># no key in self.table
</span>            <span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
            <span class="n">delnode</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>

            <span class="c1"># del
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">delnode</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">delnode</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>

</code></pre></div></div>

<p>对于代码本身的优化, 这里的一个细节和 two sum 题很像, 就我感觉是 code 层面上的剪枝, 对于 put 方法而言, 很容易的就看到, 在 <code class="language-plaintext highlighter-rouge">self.table</code> 中在判断完是否有 key 后, 这个条件判断中, 每一个子部分, 都有, <code class="language-plaintext highlighter-rouge">建立 tempNode</code>, 然后是因为刚刚存入, 所以要更新到 <code class="language-plaintext highlighter-rouge">head</code> 后, 放置到最新的位置,这都是合理的, 哦那其实, 我们有代码重复在了一个两个不同的地方, 那么只要提出来就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="c1"># 想什么时候要额外, 就是有key的时候, OK
</span>	<span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
	<span class="c1"># 合并了
</span>	<span class="n">tempNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
	
	
	<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempNode</span> <span class="c1"># table
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">_update</span><span class="p">(</span><span class="n">tempNode</span><span class="p">)</span><span class="c1"># 更新到最新
</span>	
	<span class="c1"># size检查
</span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="n">del_target</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="c1"># del_target 
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">del_target</span><span class="p">.</span><span class="n">key</span><span class="p">])</span>
		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">del_target</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></div>

<p>OK, 在这个部分写完之后, 我们可以发现, 我们不需要对于 ` put<code class="language-plaintext highlighter-rouge"> 方法和 </code>get` 方法在每一步都建立一个新的 node, 在创建一个 node 的时候, 会在计算机上 grab 一个新的内存地址, 然后, 相当于 put 和 get 方法都需要频繁的内存操作,</p>
<blockquote>
  <p><strong>deepseek- 14b 分析</strong>
比如 malloc 和 free 或者垃圾回收的压力。此外，当缓存容量达到上限时，需要替换掉旧
的节点，这时候如果一直有新的节点被插入，老节点可能已经被移除或仍在链表中，这
可能会导致一些问题，比如内存泄漏或者其他逻辑错误。
   -
2第二种方法 <strong>优点</strong>：实现相对直接，不需要复杂的指针调整。<strong>缺点</strong>：每次访问都创建新节点，导致更多的内存分配和释放操作，可能影响性能。此外，管理旧节点的引用可能会增加代码复杂度。</p>
</blockquote>

<ol>
  <li><strong>建立新节点的影响</strong>：
    <ul>
      <li><strong>内存开销</strong>：频繁的新建会导致更多的内存分配，增加了垃圾回收或内存管理
的压力。</li>
      <li><strong>性能影响</strong>：内存分配操作可能成为性能瓶颈，尤其是在高并发场景下。</li>
    </ul>
  </li>
</ol>

<p>OK 现在如果我们只是操作原来在内存上已经建立的节点的话, 那么我们只是用原来已经被创建的对象, 这样可以大幅减小使用内存的开销.
一开始我以为只需要改变 <code class="language-plaintext highlighter-rouge">put</code> 方法和 ` get<code class="language-plaintext highlighter-rouge"> 方法, 但是现在我感觉 </code>_update`  方法也应该被更新</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="err">···</span> 
    <span class="n">ignoring</span>
    <span class="err">···</span>
    <span class="k">def</span> <span class="nf">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    	<span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
    	<span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>
    	
	<span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		
		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="n">node</span>
		
		<span class="c1"># head
</span>		<span class="n">original_head_nxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">temp_pointer</span>
		
		<span class="c1"># node(temp_pointer)
</span>		<span class="n">temp_pointer</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
		<span class="n">temp_pointer</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">original_head_nxt</span>
		
		<span class="c1"># original_head_nxt
</span>		<span class="n">original_head_nxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">temp_pointer</span>
		
	<span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> 
		<span class="c1"># 剪枝
</span>		<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
		<span class="c1"># key in table
</span>		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
		<span class="c1"># update logic
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">temp_pointer</span><span class="p">)</span> <span class="c1"># self._move_to_after_head(self.table[key]) both OK ?
</span>		
		<span class="c1"># table 不需要动, only 节点的联系在变化就可以了
</span>		<span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span>
	
	<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
		

</code></pre></div></div>

<p>对于 put 方法而言, 我们还是按照原始的 flow 就好了</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
	<span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
		<span class="n">newNode</span> <span class="o">=</span> <span class="n">node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
		
		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">newNode</span><span class="p">)</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">newNode</span>
	<span class="k">else</span><span class="p">:</span> <span class="c1"># key in table 
</span>		<span class="c1">#dict value 更新
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span> <span class="c1"># 
</span>		<span class="c1"># 删除
</span>			
		<span class="n">temp_pointer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>  <span class="c1"># 指针
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="c1"># 原先断掉
</span>		<span class="c1"># 更新
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_add_to_after_head</span><span class="p">(</span><span class="n">temp_pointer</span><span class="p">)</span> <span class="c1"># 放到新位置
</span>		
	<span class="c1"># size, 实现lru
</span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
		<span class="c1"># READ, find
</span>		<span class="n">the_lru_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
		
		<span class="c1"># DELETE
</span>		<span class="bp">self</span><span class="p">.</span><span class="n">_delete</span><span class="p">(</span><span class="n">the_lru_node</span><span class="p">)</span> <span class="c1"># list
</span>		<span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">the_lru_node</span><span class="p">.</span><span class="n">key</span><span class="p">]</span> <span class="c1"># table
</span></code></pre></div></div>

<p>GPT 说的, 对 <code class="language-plaintext highlighter-rouge">_add_to_after_head</code> 方法的优化, 很简单, 其实我们不需要 <code class="language-plaintext highlighter-rouge">tempnode</code> 和 <code class="language-plaintext highlighter-rouge">original_head_nxt</code></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
		<span class="c1"># head
</span>		<span class="n">original_head_nxt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
		<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
		
		<span class="c1"># node(temp_pointer)
</span>		<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
		<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">original_head_nxt</span>
		
		<span class="c1"># original_head_nxt
</span>		<span class="n">original_head_nxt</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>
<p>然后可以再简化一下</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_add_to_after_head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node</span><span class="p">):</span>
	<span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
	<span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
	<span class="c1"># 上一次最新的节点(self.head.next), or现在head后一个的节点
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
	<span class="c1"># head
</span>	<span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>
</code></pre></div></div>

<p>OK, 那么新的使用原始节点复用的 <code class="language-plaintext highlighter-rouge">LRUCache</code> 代码如下(下面的代码是 gpt 生成的, 有些名字不一样)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>      <span class="c1"># 用于反查哈希表
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>      <span class="c1"># 实际存储的值
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c1"># 指向前一个节点
</span>        <span class="bp">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>    <span class="c1"># 指向后一个节点
</span>
<span class="k">class</span> <span class="nc">LRUCache</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># key -&gt; Node
</span>
        <span class="c1"># 虚拟头尾节点，便于统一操作
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="nf">_remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="s">"""从链表中断开某个节点"""</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">prev</span>

    <span class="k">def</span> <span class="nf">_add_to_front</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="s">"""把节点加到链表头部（head后面）"""</span>
        <span class="n">node</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span>
        <span class="n">node</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="n">prev</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>         <span class="c1"># 从原位置断开
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>   <span class="c1"># 移动到最前面
</span>        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>

    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">:</span>
            <span class="c1"># 已存在：更新值，并移动到最前面
</span>            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 不存在：判断是否超容量
</span>            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">capacity</span><span class="p">:</span>
                <span class="c1"># 删除最久未用（链表尾部的前一个）
</span>                <span class="n">lru</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">prev</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">_remove</span><span class="p">(</span><span class="n">lru</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">lru</span><span class="p">.</span><span class="n">key</span><span class="p">]</span>

            <span class="c1"># 新建节点并放入头部
</span>            <span class="n">new_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_add_to_front</span><span class="p">(</span><span class="n">new_node</span><span class="p">)</span>

</code></pre></div></div>

<h1 id="最后谈谈-简单写法用-ordered_dict">最后谈谈, 简单写法用 ordered_dict</h1>

<p>这个 title 是一开始全空白的时候留下的, 就是什么都没写的时候. 我一开始以为我这个部分没有写过, 会到时候写不出来, 但是现在实现了 python 版本的 lru 之后, 我发现这个如果用 ordered_dict 方法实现非常简单, 而且在 python3.6 之后, 我们的 dict 就已经默认是有 order 的了, 那感觉就太简单了就是想象一下头和尾可以 $O(1)$ 时间取到的有 append 的先后顺序的 dict 呗, 就留下一个坑吧</p>

<h1 id="appendix">Appendix</h1>

<h3 id="original-开头部分">original 开头部分</h3>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先是背的, 使用链表, 而且是双向链表, 这里, 为什么是要用链表呢, 因为我们想实现 $O(1)$ 时间的删除, 如果使用 arr or 直接使用字典就是 $O (n)$ 了, 这里的这个 trade off 使用了这个性质, 是用 DLList 实现的. 而且因为单链表不行, 

这里的时候我其实对 key 有疑问, 就是, 什么是要在 `node` 这个 `class` 中, 写 `self.key` , 这个的 intuition 呢, 还有一个问题是我在第二次写的时候, 不知道 or 没有这个直接来判断在 dict 中使用的 key 是什么, 是那个输入的 key, 还是可以使用 node 本身呢 (这里有个疑问中的小疑惑, python 中的对象是和 java 一样会使用一个 hashcode 吗, 还是直接是地址, java 直接 print 是 hashcode 吗还是对象的内存地址), OK, 继续, 我自己想的是, 如果用 node 本身作为 table 的 key, 那么 value 一样的时候, key是不一样的, 会找不到对应的值, 所以这里, 可能应该要用本身 func 中输入的 key 作为 table 的 key, 

还有是为什么 DLList 的 node class 中要加入 `self.key`  这里要回到删除机制的概念了, 想到删除, 这里想到的是从 table 上删除, 但是 table 只是作为一个 $O(1)$ 时间访问的功能, table 的访问和删除, 我们可以很快的使用 key 来实现, 但是双向链表呢, 需要在链表上删除和添加对应的 node 的操作, 这个时候, 按照题目的要求, 我们也要 $O(1)$, 想起来(这里是背的), 我们怎么直接取到这个 node 呢, 为什么不可以就是 `table[key]` 然后在里面放一个正常形式的 node 呢? 我们已经是拿到了对应的 node, 为什么还要 key 呢, 对于正常的删除, 这里正常的意思是我们使用 put 方法的时候, 如果本身的 size 在添加的时候超出了 capacity 的话,~~那确实是不需要这个使用 node 中的 self.key,~~ 对就是在这个超出的 capacity 的功能上, 我们可以使用 $O(1)$ 的时间删除在链表上的点, 但是, 我们如果使用原始的 node class 的样式的话, 在 table 上如何删除对应的对象呢, 这里, table 要 O1 只能使用 key 来进行访问, 那么如果我们在访问到一个节点的时候, 我们没有 key 这个值的话, 我们就不可以在得到 node 的情况下, 用 O1 的时间定位到(查询到?)这个 node 在 table 上, 所以我们在设计这个 node 的时候, 我们加上了 self.key 这个参数
</code></pre></div></div>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[使用 GPT refine 了文章]]></summary></entry><entry><title type="html">2025-05-01 Dot products点积 and duality Chapter 9/16</title><link href="http://localhost:4000/Dot-products%E7%82%B9%E7%A7%AF-and-duality-Chapter-9/" rel="alternate" type="text/html" title="2025-05-01 Dot products点积 and duality Chapter 9/16" /><published>2025-05-01T00:00:00+08:00</published><updated>2025-05-01T00:00:00+08:00</updated><id>http://localhost:4000/Dot%20products%E7%82%B9%E7%A7%AF%20and%20duality%20Chapter%209</id><content type="html" xml:base="http://localhost:4000/Dot-products%E7%82%B9%E7%A7%AF-and-duality-Chapter-9/"><![CDATA[<p>3Blue1Brown</p>

<p><strong>后记前置: 还挺沮丧的, 这个15min的视频, 我学了快三个小时. 从sc到lib的电脑屏幕前坐下, 已经3小时了</strong> 不过看评论区说也有物理phd常看常新, 还有花了几小时才理解的comments, 给我安慰就是说我虽然笨还不是那么笨hh, 然后虽然要逃出和他人比较的逻辑, 但是我好像还是在这个体系中啊, 哎… 我觉得难的原因是(claude refine)</p>
<ol>
  <li>教学视频受到时长限制，3Blue1Brown为了保持视频简洁，往往需要压缩内容，这就导致某些关键解释可能被简化或省略, 或者是被快速的讲解。</li>
  <li>作为斯坦福数学博士，Grant对数学概念的理解已经达到了非常深入的层次。这种专业洞察力有时会让他无意识的忽略初学者的思维盲区，使他在解释时跳过了对新手来说可能至关重要的中间步骤。</li>
  <li>一个视频需要面向不同水平的受众，从初学者到专业人士，这使得内容很难同时满足所有人的需求。</li>
</ol>

<p><strong>2025-05-02记:</strong> 又花了差不多4小时, 不过一半的时间在svg gpt作图上, 这个时候我想搭一个agent工具, or找找有没有现成的好的工具, 我觉得现在有的一个问题是现在LLM识别图像的能力非常非常弱, 我的截图对gpt输入, 让他使用svg来复刻, 基本无法识别, OK, 在打字的时候问题来了, 我输入一个png的截图, GPT是怎么读取的我的图片的, 这么短的时间内读取我的每一个像素点嘛, 不太可能, 应该还是Transformer 或者vit之类的, 我觉得我输入prompt如果是要求OCR识别的话, 好像都还蛮准的, 这里如果做agent的话, 要从原始目的出发研究一下. 或者说增强图片, 改变图片的分割方法. 为了减小文件体积, 和冗余, 文章尽量不使用任何png截图, 使整体md文档更加干净.</p>

<p>哎好失落啊, 这点东西配学这么久吗</p>

<p><strong>概念回顾</strong>
什么是线性变换linear transformation, 核心的两个<strong>形式性定义（formal properties）</strong>，也叫<strong>线性性公理</strong>：
 ① <strong>加法保持性（preservation of addition）</strong>：</p>

\[L(\vec{v} + \vec{w}) = L(\vec{v}) + L(\vec{w})\]

<p>② <strong>数乘保持性（preservation of scalar multiplication）</strong>：</p>

\[L(c \vec{v}) = c \cdot L(\vec{v})\]

<h2 id="第一个有疑问的地方对于对称性-我没有理解3blue1brown这里对于对称性的困惑">第一个有疑问的地方对于对称性, 我没有理解3Blue1Brown这里对于对称性的困惑</h2>

<h3 id="经过想之后的理解是">经过想之后的理解是</h3>

<p>在一开始简单说了一下点乘的概念, 但是在2:17的时候, 说不对称, 没有理解这里不对称的意思, 其实是, 我们知道点乘是可以交换的, 但是这里交换后, 我们的几何意义改变了, 但是对于2维的vector点乘, 我们对于同样的对象(两个都是vector), 我们对于这个变化下, 其实两个vector的地位是不一样的, 一个是变化方, 一个是作为ground, 理论上我们交换位置, 这个formula应该会变好, 这里在几何意义上不同的object在交换后, 没有发生改变, 这里神奇的对称了. 顺序好像不重要了</p>

<h3 id="gpt回复below">GPT回复below</h3>

<blockquote>
  <p>📌 <strong>“这里说的不对称是说，两个向量，但是操作好像是不同的地位。”</strong></p>
</blockquote>

<p>没错，作者用 “weirdly asymmetric（奇怪地不对称）” 来形容的，就是这种 <strong>心理上的不对等感</strong>，虽然实际上点积是数学上对称的操作。我们来把这个“不对称感”彻底拆清楚。 数学上：点积是对称的, 公式永远成立：</p>

<p>\(\vec{v} \cdot \vec{w} = \vec{w} \cdot \vec{v}\)
这说明：</p>
<ul>
  <li>两个向量在<strong>数学上的地位是完全一样的</strong>；</li>
  <li>交换它们顺序，计算结果不会变。</li>
</ul>

<blockquote>
  <p>但是几何解释上会让人感觉不一样</p>
</blockquote>

<p><strong>让我们回顾那个几何解释的套路：</strong>
把 $\vec{w}$ 投影到 $\vec{v}$ 所在的直线上，然后乘上 $|\vec{v}|$。这个解释其实默认了两件事：$\vec{v}$ 是被投影的参考方向，而 $\vec{w}$ 是主动参与投影的对象。它把两者的角色区分成了不同的几何意义：$\vec{v}$ 作为投影的目标、坐标轴和参考方向，而 $\vec{w}$ 则是被投影的向量和参与者。
所以你心里可能会产生这个疑问：为什么 $\vec{v}$ 是坐标轴一样的东西，而 $\vec{w}$ 是被压上去的？
如果你说：”那我反过来，把 $\vec{v}$ 投影到 $\vec{w}$ 上，不也一样吗？”当然可以，而且你最终也会得到：$\vec{w} \cdot \vec{v} = \vec{v} \cdot \vec{w}$。但你会发现，这时候你投影的路径、过程完全不一样，虽然数值结果相等。就像你走了另一条路，但是到了同一个终点。
为什么这种”不对称”让人不舒服？因为我们习惯上会以为：如果两边平等，那解释方式也应该是平等的。但这里几何上的投影，总要选择一个方向来作为参考（轴），另一个投过去。这就导致你在心里赋予了一个向量”更高的地位”，这跟数学上的”完全对称”感觉不一致。这就是作者说的 “weirdly asymmetric” 的来源。</p>

<h2 id="下面是看到一半时候-我的疑惑后来解决了">下面是看到一半时候, 我的疑惑(后来解决了)</h2>
<p>后续在视频里面说, 如果 $\vec{v}$ 和 $\vec{w}$ 是本身对称的话, 这个投影的长度, 无论谁对谁, 好像值是不好变的, 然后如果改变一点的话, 比如,  $2\times \vec{v} \times \vec{w}$ 如果按照原来的理解的话,  $\vec{v}$ 变成了原来的两倍, 这个时候$\vec{w}$ 去逼近 $2\vec{v}$这个vector的话, 感觉应该值是不会变的, 因为对于ground vector来说, 肯定不可以影响阴影啊</p>

<h1 id="gpt回答-使用claude-refine">gpt回答… 使用Claude refine</h1>

<p>上面的问题切中了 <strong>点积几何解释中投影与向量长度的关系</strong> 的核心。</p>

<p>你提出的疑问总结成一句话：”我感觉点积是 ‘影子长度’，那如果我把地面（ground vector） $\vec{v}$ 变长，比如变成 $2\vec{v}$，那影子的长度不应该变啊，因为地面变长不影响投影到它的 ‘影子长度’ —— 为什么点积的值却变了呢？”</p>

<p>这其实是一个常见直觉误区，也是这个视频中解释得最细致的地方。我们来用物理类比和直觉来破解这个问题：</p>

<p>先把点积的几何解释再说清楚：点积 = 投影长度 × 被投影方向的长度。也就是说：</p>

\[\vec{v} \cdot \vec{w} = \left|\vec{v}\right| \cdot \text{(投影长度 of } \vec{w} \text{ onto } \vec{v})\]

<p>如果我们换个方式写：</p>

\[\vec{v} \cdot \vec{w} = \left|\vec{v}\right| \cdot \left|\vec{w}\right| \cdot \cos\theta\]

<p>这里的意思是：你把 $\vec{w}$ 投影到 $\vec{v}$ 上（或反过来）；然后乘上 $\vec{v}$ 的长度（或 $\vec{w}$ 的长度）；得到一个带符号的投影值。</p>

<hr />

<p><strong>类比一：投影 ≠ 影子</strong></p>

<p>你在想：”如果我只是测影子长度，地板变长了（$\vec{v}$ 变成 $2\vec{v}$），影子不该变啊！” —— 对！如果你只是测 “影子长度”，确实不变。但问题是：点积不是 “影子长度”，而是 <strong>“影子长度 × 地板的长度”</strong>。</p>

<p>你可以把它类比成：<strong>力 × 位移 = 做的功（Work）</strong>。力 $\vec{F}$ 施加在一个方向；位移 $\vec{d}$ 在另一个方向：</p>

\[\vec{F} \cdot \vec{d} = \left|\vec{F}\right| \cdot \left|\vec{d}\right| \cdot \cos\theta\]

<p>如果你把 $\vec{F}$ 加大一倍，虽然 $\vec{d}$ 没有变，角度没有变，做功变成了两倍。因为你推得更用力了。</p>

<hr />

<p>回到你的问题：</p>

<ul>
  <li>原来：$\vec{v} \cdot \vec{w} = L$</li>
  <li>改成：$2\vec{v} \cdot \vec{w} = ?$</li>
</ul>

<p>发生了什么？投影长度（$\vec{w}$ onto $\vec{v}$）不变；但 $\vec{v}$ 的长度变成了两倍，所以最终点积值也变成原来的两倍：</p>

\[2\vec{v} \cdot \vec{w} = 2 \cdot (\vec{v} \cdot \vec{w}) = 2L\]

<p>这并不奇怪，因为你换了参考线：你不是只测 “影子的长度”，而是 “影子长度 × 地板的长度”，自然会变大！</p>

<hr />

<p><strong>类比二：放大尺子</strong></p>

<p>想象你用尺子测一个影子长度。这个 “尺子” 就是 $\vec{v}$：</p>

<ul>
  <li>原来：尺子是 1 米；你投影 $\vec{w}$，影子是 0.7 米；点积 = 0.7</li>
  <li>你把尺子放大两倍：尺子变成 2 米；同样的影子 0.7 “尺”，但现在 1 尺 = 2 米 → 点积 = 1.4</li>
</ul>

<p>因为你改变了参考系！点积确实是关于 “投影” 的操作，<strong>但它还乘了一个 “参考向量的长度”</strong>，所以当你改变参考（地板）的时候，值当然会变。</p>

<p>不能把点积误认为是 “单纯的影子长度” —— 它其实是 <strong>“影子 × 标尺的大小”</strong>。</p>

<h2 id="继续">继续</h2>

<p>视频中的另外一个疑问(是作者本身的提问), 我之前没有注意到这个问题, 为什么下面这个形式, 乘以对并将它们相加的数值过程与投影有关？
\(\begin{bmatrix} 2 \\ 7 \\ 1 \\ \end{bmatrix} \cdot \begin{bmatrix} 8 \\ 2 \\ 8 \\ \end{bmatrix} = 2 \cdot 8 + 7 \cdot 2 + 1 \cdot 8 = 16 + 14+8= 38\)
于是, 在这里, 引出了<strong>duality</strong></p>

<p>OK, 还要讨论 <strong>linear transformations</strong> from multiple dimensions to one dimension：</p>

<p>\(\vec{v} =
\begin{bmatrix}
2 \\
7
\end{bmatrix}
\xrightarrow{\quad L(\vec{v}) \quad}
\begin{bmatrix}
1.8
\end{bmatrix}\)
在这里, 我们的  $\begin{bmatrix}2 \ 7\end{bmatrix}$ 从二维变成了一个数(which is 一维的), 
就是  $[1 \quad  3]$ 这种样子, 可以认为是在一维上的两个值, 从原点出发, 指到了1和指到了3, 这样.</p>

<svg viewBox="0 0 500 120" xmlns="http://www.w3.org/2000/svg">
<!-- Number line -->
<line x1="50" y1="60" x2="450" y2="60" stroke="black" stroke-width="2" />
<!-- Ticks and labels -->
<g>
<!-- Origin (0) -->
<line x1="250" y1="55" x2="250" y2="65" stroke="black" stroke-width="2" />
<text x="250" y="80" text-anchor="middle" font-family="Arial" font-size="14">0</text>

<!-- Negative numbers -->
<line x1="210" y1="55" x2="210" y2="65" stroke="black" stroke-width="1" />
<text x="210" y="80" text-anchor="middle" font-family="Arial" font-size="14">-1</text>

<line x1="170" y1="55" x2="170" y2="65" stroke="black" stroke-width="1" />
<text x="170" y="80" text-anchor="middle" font-family="Arial" font-size="14">-2</text>

<line x1="130" y1="55" x2="130" y2="65" stroke="black" stroke-width="1" />
<text x="130" y="80" text-anchor="middle" font-family="Arial" font-size="14">-3</text>

<line x1="90" y1="55" x2="90" y2="65" stroke="black" stroke-width="1" />
<text x="90" y="80" text-anchor="middle" font-family="Arial" font-size="14">-4</text>

<line x1="50" y1="55" x2="50" y2="65" stroke="black" stroke-width="1" />
<text x="50" y="80" text-anchor="middle" font-family="Arial" font-size="14">-5</text>

<!-- Positive numbers -->
<line x1="290" y1="55" x2="290" y2="65" stroke="black" stroke-width="1" />
<text x="290" y="80" text-anchor="middle" font-family="Arial" font-size="14">1</text>

<line x1="330" y1="55" x2="330" y2="65" stroke="black" stroke-width="1" />
<text x="330" y="80" text-anchor="middle" font-family="Arial" font-size="14">2</text>

<line x1="370" y1="55" x2="370" y2="65" stroke="black" stroke-width="1" />
<text x="370" y="80" text-anchor="middle" font-family="Arial" font-size="14">3</text>

<line x1="410" y1="55" x2="410" y2="65" stroke="black" stroke-width="1" />
<text x="410" y="80" text-anchor="middle" font-family="Arial" font-size="14">4</text>

<line x1="450" y1="55" x2="450" y2="65" stroke="black" stroke-width="1" />
<text x="450" y="80" text-anchor="middle" font-family="Arial" font-size="14">5</text>
</g>

<!-- Vector 1 (blue, pointing to 1) -->
<line x1="250" y1="60" x2="290" y2="60" stroke="blue" stroke-width="3" />
<polygon points="290,60 285,55 285,65" fill="blue" />
<text x="275" y="45" font-family="Arial" font-size="14" fill="blue">v₁</text>

<!-- Vector 2 (red, pointing to 3) -->
<line x1="250" y1="60" x2="370" y2="60" stroke="red" stroke-width="3" />
<polygon points="370,60 365,55 365,65" fill="red" />
<text x="320" y="45" font-family="Arial" font-size="14" fill="red">v₂</text>
</svg>
<p>所以, 我们几乎可以认为, 1和3是纯数值, 然后这个躺下来的 vector其实 T 一下, 就是一个正常的vector, 这个非常common的操作, 其实建立起了数值 和 vector(2维/3维下的坐标点)之间的关系,</p>

<p>就是说, 如果我们忘记对于 dot product 公式机械的记忆, 从几何意义开始探讨的话, 那个$[x_1 \quad  x_2 \dots x_n]$ (个数未定义) 的横向的object, 可以被认为是一个 $f(x)$ 把我们可观察的vector们(当然也包括不可观察的), 从2维3维空间, 拉到一个一维的穿过原点的坐标轴上(这里  $x_1\dots x_n$在上面, 就是实际值),这个过程or变化是线性的, 注意这个 $f(x)$ 的output是 1个值.</p>

<p>一开始对10:04对称的那个截图, 有疑惑, 为什么这里  $\vec{u}$ 我们就默认是1, 哦, 这里又是这个数轴上的单位向量, 然后,  x横线的  $[x_1 \quad x_2 ]$ 其实是什么呢, 是我们的2D的坐标系下的单位向量  $\vec{i} , \vec{j}$ , 投影到那个数轴上时候, 得到的数值,</p>
<svg viewBox="0 0 500 400" xmlns="http://www.w3.org/2000/svg">
<defs>
<!-- 更小的蓝色箭头 -->
<marker id="blueArrow" markerWidth="4" markerHeight="2.8" refX="4" refY="1.4" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 4 1.4, 0 2.8" fill="blue" />
</marker>

<!-- 更小的红色箭头 -->
<marker id="redArrow" markerWidth="4" markerHeight="2.8" refX="4" refY="1.4" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 4 1.4, 0 2.8" fill="red" />
</marker>

<!-- 黑色数轴箭头保持不变 -->
<marker id="axisArrow" markerWidth="6" markerHeight="4.2" refX="6" refY="2.1" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 6 2.1, 0 4.2" fill="black" />
</marker>
</defs>

<!-- 坐标轴背景 -->
<line x1="50" y1="200" x2="450" y2="200" stroke="#888" stroke-width="1.5" stroke-dasharray="5,5" />
<polygon points="450,200 440,195 440,205" fill="#888" />
<text x="460" y="205" font-family="Arial" font-size="14" fill="#888">x</text>

<line x1="250" y1="350" x2="250" y2="50" stroke="#888" stroke-width="1.5" stroke-dasharray="5,5" />
<polygon points="250,50 245,60 255,60" fill="#888" />
<text x="255" y="50" font-family="Arial" font-size="14" fill="#888">y</text>

<circle cx="250" cy="200" r="4" fill="#888" />
<text x="235" y="220" font-family="Arial" font-size="14" fill="#888">O</text>

<!-- 斜向数轴 -->
<line x1="100" y1="300" x2="400" y2="100" stroke="black" stroke-width="2" marker-end="url(#axisArrow)" />

<!-- 数轴刻度 -->
<g font-family="Arial" font-size="12" fill="black">
<circle cx="150" cy="266" r="2" /><text x="140" y="260">-5</text>
<circle cx="170" cy="253" r="2" /><text x="160" y="247">-4</text>
<circle cx="190" cy="240" r="2" /><text x="180" y="234">-3</text>
<circle cx="210" cy="227" r="2" /><text x="200" y="221">-2</text>
<circle cx="230" cy="214" r="2" /><text x="220" y="208">-1</text>
<circle cx="250" cy="200" r="2" /><text x="240" y="194">0</text>
<circle cx="270" cy="186" r="2" /><text x="270" y="176">1</text>
<circle cx="290" cy="172" r="2" /><text x="290" y="162">2</text>
<circle cx="310" cy="158" r="2" /><text x="310" y="148">3</text>
<circle cx="330" cy="144" r="2" /><text x="330" y="134">4</text>
<circle cx="350" cy="130" r="2" /><text x="350" y="120">5</text>
</g>

<!-- 红色向量 v₂ -->
<line x1="250" y1="200" x2="310" y2="158" stroke="red" stroke-width="3" stroke-opacity="0.6" marker-end="url(#redArrow)" />
<text x="295" y="150" font-family="Arial" font-size="14" fill="red">v₂</text>

<!-- 蓝色向量 v₁ -->
<line x1="250" y1="200" x2="270" y2="186" stroke="blue" stroke-width="3" marker-end="url(#blueArrow)" />
<text x="255" y="180" font-family="Arial" font-size="14" fill="blue">v₁</text>
</svg>

<p>OK, 这里我们记住了这个特性之后, 会发现对于 2D的空间来说, $[x_1 \quad x_2 ]$ 是我们的单位向量  $\vec{i} , \vec{j}$ 在那个数轴上的投影, 那么现在, 我们比如有一个正常的arbitrary的matrix后, 比如 $\begin{bmatrix}2 \7\end{bmatrix}$ 我们当然发现2和7就是对于x_1和x_2的, 而没有之前的vector地位不等价的疑惑了, 因为从分开的角度来说, 我们的2确实就和 $\vec{i}$ 有关系, 我们的7确实就和 $\vec{j}$ 有关系, 这是最后发生在一个数轴上的</p>

<p>在之前 乘 3, 其实对于  $\vec{i},\vec{j}$ 来说, 我们对于每一行都乘了3, which 回到之前的问题, $2\times \vec{v} \cdot \vec{w}$这个地方, 我们其实是$\begin{bmatrix}2 \cdot v_{row1} \ 2 \cdot v_{row2}\end{bmatrix}$ 所以, 这里二维的单位向量都乘了3,</p>

<p>这个横向的vector又是怎么竖过来的呢?</p>

<h2 id="claude-回答">Claude 回答</h2>

<p>点积的本质可以从两个角度理解：几何投影和线性变换。
从几何角度看，当我们计算 $\vec{v} \cdot \vec{w}$ 时，可以理解为 $\vec{w}$ 在 $\vec{v}$ 方向上的投影长度乘以 $\vec{v}$ 的长度。这就是为什么当我们把 $\vec{v}$ 放大两倍变成 $2\vec{v}$ 时，点积值会变成原来的两倍 - 因为参考向量的长度变了。</p>

<p>从线性变换的角度看，横向的向量 $[a \quad b]$ 定义了一个从二维到一维的映射规则：把空间中的任何向量 $\begin{bmatrix} v_1 \ v_2 \end{bmatrix}$ 映射到数轴上的 $av_1 + bv_2$ 这个点。这不是描述空间中的一个位置，而是描述如何将其他向量映射到一维空间。</p>

<p>当我们计算点积 $[a \quad b] \cdot \begin{bmatrix} v_1 \ v_2 \end{bmatrix} = av_1 + bv_2$ 时，实际上是在应用这个线性变换。当我们把 $[a \quad b]$ 变成 $[2a \quad 2b]$ 时，我们改变了映射规则，所以结果自然变为原来的两倍。</p>

<p>这种视角消除了点积中向量角色不对称的困惑 - 它们本来就是不同的：一个是变换规则，另一个是被变换的对象。这就是线性代数中”对偶性”的本质 - 同一个数学对象可以有两种不同但等价的解释。</p>

<p>我们得出来, 下面的想法, 不是把向量当作空间中一支“箭头”, 而是把它理解为“某种线性变换的具象表现” ,它代表的是一个<strong>作用规则</strong>，不是一个位置或方向</p>

<p>到12:37学不动了, 又回到了duality</p>

<h2 id="2025-05-02-新的一天-图书馆继续">2025-05-02 新的一天, 图书馆继续</h2>

<p>首先是回顾, 我在refine完上面的文章之后, 我感觉又回到了之前的问题, 在这个文章中, 哪些内容, 还不够有intuition, 我感觉从二维到1维的时候, 还是有点困惑是, 为什么  $[x_1 \quad x_2 ] \cdot \begin{bmatrix} x_m \ x_n \end{bmatrix}$ 为什么这里 $x_m$ 只需要和  $x_1$ 乘,  $x_n$ 只需要和  $x_2$ 乘, 这里还是有点疑惑</p>
<h2 id="claude-say">Claude say</h2>

<p>从二维到一维的映射
首先，让我们回顾一下点积的核心问题：为什么在 $[x_1 \quad x_2] \cdot \begin{bmatrix} x_m \ x_n \end{bmatrix}$ 中，$x_1$ 只与 $x_m$ 相乘，$x_2$ 只与 $x_n$ 相乘？
这个问题涉及到向量的对偶性理解。从传统视角看，点积似乎是一个神奇的规则，但从线性变换的角度来看，这个规则非常自然。</p>

<h2 id="从线性变换的角度理解点积">从线性变换的角度理解点积</h2>

<p>当我们把行向量 $[x_1 \quad x_2]$ 看作是一个<strong>线性变换</strong>时，它定义了一种从二维空间到一维数轴的映射规则：</p>

<p>$f([a, b]) = x_1 \cdot a + x_2 \cdot b$</p>

<p>这个函数 $f$ 将二维空间中的任何向量映射到数轴上的一个点。这里的直觉是：</p>

<ol>
  <li>行向量 $[x_1 \quad x_2]$ 不再是空间中的”箭头”，而是一个<strong>变换规则</strong></li>
  <li>这个规则告诉我们如何将二维空间压缩到一维空间</li>
  <li>$x_1$ 和 $x_2$ 分别是基向量 $\hat{i}$ 和 $\hat{j}$ 在这个映射下的”影像”</li>
</ol>
<font color="red">OK,上面这个概念出现不懂, or 有问题, 跳</font>
<p>当我们计算 $[x_1 \quad x_2] \cdot [x_m \\ x_n]$ 时，我们实际上是在应用这个变换规则到向量 $[x_m, x_n]$ 上： $f([x_m, x_n]) = x_1 \cdot x_m + x_2 \cdot x_n$</p>

<h2 id="对于-3-x_1-和-x_2-分别是基向量-hati-和-hatj-在这个映射下的影像-不懂-再想">对于 3. $x_1$ 和 $x_2$ 分别是基向量 $\hat{i}$ 和 $\hat{j}$ 在这个映射下的”影像”, 不懂, 再想</h2>

<p>点积的本质理解
点积 $[x_1 \quad x_2] \times \begin{bmatrix} x_m \ x_n \end{bmatrix} = x_1x_m + x_2x_n$ 之所以是这样计算，本质上是因为这是标准内积的定义方式。
但为什么是这样定义的呢？</p>

<p><strong>1.从坐标分解的角度</strong></p>

<p>标准基向量 $\hat{i}$ 和 $\hat{j}$ 是相互正交的。当我们将向量 $\vec{v} = \begin{bmatrix} x_m \ x_n \end{bmatrix}$ 表示为 $x_m\hat{i} + x_n\hat{j}$ 时，$x_m$ 和 $x_n$ 实际上是向量在这两个基方向上的投影长度。</p>

<p>同样，向量 $\vec{u} = [x_1 \quad x_2]$ 也可以视为 $x_1\hat{i} + x_2\hat{j}$。</p>

<p>当我们计算 $\vec{u} \cdot \vec{v}$ 时，我们在计算： $(x_1\hat{i} + x_2\hat{j}) \cdot (x_m\hat{i} + x_n\hat{j})$</p>

<p>展开后得到： $x_1x_m(\hat{i} \cdot \hat{i}) + x_1x_n(\hat{i} \cdot \hat{j}) + x_2x_m(\hat{j} \cdot \hat{i}) + x_2x_n(\hat{j} \cdot \hat{j})$</p>

<p>由于 $\hat{i} \cdot \hat{i} = 1$，$\hat{j} \cdot \hat{j} = 1$，而 $\hat{i} \cdot \hat{j} = 0$（正交性），所以结果简化为： $x_1x_m + x_2x_n$</p>

<p>这就是为什么我们只需要将对应分量相乘并求和 - 正交基消除了交叉项！</p>

<h3 id="2-从线性变换的角度">2. 从线性变换的角度</h3>

<p>当我们将 $[x_1 \quad x_2]$ 视为线性变换时，它完全由对基向量的作用确定：</p>

<ul>
  <li>将 $\hat{i}$ 映射到 $x_1$</li>
  <li>将 $\hat{j}$ 映射到 $x_2$</li>
</ul>

<p>对任意向量 $\begin{bmatrix} x_m \ x_n \end{bmatrix} = x_m\hat{i} + x_n\hat{j}$ 的作用是： $x_m$ 的部分贡献 $x_m \cdot x_1$ $x_n$ 的部分贡献 $x_n \cdot x_2$</p>

<p>总和是 $x_1x_m + x_2x_n$</p>

<p>我感觉这里LLM模型的解释是shit, 我觉得从svg的地方再开始自己理清楚一下应该可以清楚.
我们得到了一个数轴上的1和3, 和 $[1 \quad 3]$ 然后这个数轴是在二维坐标系上的, 我重复一遍这个svg如下, 那么, 其实在这个数轴上, 等于1和等于3的vector本身, 就是使用二维平面上的标准基向量 $\hat{i}$ 和 $\hat{j}$ 构建的,</p>
<svg viewBox="0 0 500 400" xmlns="http://www.w3.org/2000/svg">
<defs>
<!-- 更小的蓝色箭头 -->
<marker id="blueArrow" markerWidth="4" markerHeight="2.8" refX="4" refY="1.4" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 4 1.4, 0 2.8" fill="blue" />
</marker>

<!-- 更小的红色箭头 -->
<marker id="redArrow" markerWidth="4" markerHeight="2.8" refX="4" refY="1.4" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 4 1.4, 0 2.8" fill="red" />
</marker>

<!-- 黑色数轴箭头保持不变 -->
<marker id="axisArrow" markerWidth="6" markerHeight="4.2" refX="6" refY="2.1" orient="auto" markerUnits="strokeWidth">
<polygon points="0 0, 6 2.1, 0 4.2" fill="black" />
</marker>
</defs>

<!-- 坐标轴背景 -->
<line x1="50" y1="200" x2="450" y2="200" stroke="#888" stroke-width="1.5" stroke-dasharray="5,5" />
<polygon points="450,200 440,195 440,205" fill="#888" />
<text x="460" y="205" font-family="Arial" font-size="14" fill="#888">x</text>

<line x1="250" y1="350" x2="250" y2="50" stroke="#888" stroke-width="1.5" stroke-dasharray="5,5" />
<polygon points="250,50 245,60 255,60" fill="#888" />
<text x="255" y="50" font-family="Arial" font-size="14" fill="#888">y</text>

<circle cx="250" cy="200" r="4" fill="#888" />
<text x="235" y="220" font-family="Arial" font-size="14" fill="#888">O</text>

<!-- 斜向数轴 -->
<line x1="100" y1="300" x2="400" y2="100" stroke="black" stroke-width="2" marker-end="url(#axisArrow)" />

<!-- 数轴刻度 -->
<g font-family="Arial" font-size="12" fill="black">
<circle cx="150" cy="266" r="2" /><text x="140" y="260">-5</text>
<circle cx="170" cy="253" r="2" /><text x="160" y="247">-4</text>
<circle cx="190" cy="240" r="2" /><text x="180" y="234">-3</text>
<circle cx="210" cy="227" r="2" /><text x="200" y="221">-2</text>
<circle cx="230" cy="214" r="2" /><text x="220" y="208">-1</text>
<circle cx="250" cy="200" r="2" /><text x="240" y="194">0</text>
<circle cx="270" cy="186" r="2" /><text x="270" y="176">1</text>
<circle cx="290" cy="172" r="2" /><text x="290" y="162">2</text>
<circle cx="310" cy="158" r="2" /><text x="310" y="148">3</text>
<circle cx="330" cy="144" r="2" /><text x="330" y="134">4</text>
<circle cx="350" cy="130" r="2" /><text x="350" y="120">5</text>
</g>

<!-- 红色向量 v₂ -->
<line x1="250" y1="200" x2="310" y2="158" stroke="red" stroke-width="3" stroke-opacity="0.6" marker-end="url(#redArrow)" />
<text x="295" y="150" font-family="Arial" font-size="14" fill="red">v₂</text>

<!-- 蓝色向量 v₁ -->
<line x1="250" y1="200" x2="270" y2="186" stroke="blue" stroke-width="3" marker-end="url(#blueArrow)" />
<text x="255" y="180" font-family="Arial" font-size="14" fill="blue">v₁</text>
</svg>

<p>OK, 再回过来注意什么, 我们的 标准基向量 $\hat{i}$ 和 $\hat{j}$ 在所谓的第一次变换后, 变成了1, 在第二次变换后变成了3(我觉得这里还是可以按照一列一列来理解, 只不过这里一列就一个数字, 有两列), 那么是怎么在这个位置上的, OK, 这是我之前没解决的点, 我重新看了视频, 虽然, 在这个位置上, 我的意思是, 虽然  $v_1$  $v_2$ 在那个位置上好像要用到标准基向量 $\hat{i}$ 和 $\hat{j}$ 来固定, 但是想想是怎么固定的, 就是应该被怎么算出来在那个位置, 好像怎么都想不到只有一行的raw的 $[1 \quad 3]$</p>

<p><strong>视频5:46到6:04</strong>, 这里说想象一个线性变换, 然后直接把j拉到一个一维的数轴上-2位置, i还保持原来的位置(1,0), 只不过刚好是数轴的1, 这里的i的0其实没有体现出来</p>
<ul>
  <li>基向量 $\hat{i} = \begin{bmatrix} 1 \ 0 \end{bmatrix}$ 被映射到数轴上的位置1</li>
  <li>
    <p>基向量 $\hat{j} = \begin{bmatrix} 0 \ 1 \end{bmatrix}$ 被映射到数轴上的位置-2
这是因为这个变换将二维空间压缩成了一维空间，所以必然会丢失一些信息。
这个线性变换可以用行向量 $[1 \quad -2]$ 来表示，意味着：</p>
  </li>
  <li>任何向量 $\begin{bmatrix} a \ b \end{bmatrix}$ 会被映射到数轴上的 $1 \cdot a + (-2) \cdot b = a - 2b$
问题… 如果按照 列空间的想法的话, 这里 $[1 \quad-2] \times \begin{bmatrix} a \ b \end{bmatrix}$ 然后,  $a * [1] + a*[-2]$ , 哦这里混淆了, 不可以这样写, 这个矩阵乘法是不可以成立的, 点乘和矩阵乘法理论上是两种东西?</li>
</ul>

<svg viewBox="0 0 700 225" xmlns="http://www.w3.org/2000/svg">
  <!-- 背景 -->
  <rect width="100%" height="100%" fill="black" />

  <!-- Transform 标签 -->
  <text x="60" y="40" font-size="28" fill="skyblue" font-family="Courier New">Transform</text>

  <!-- Transform 行向量 -->
  <text x="50" y="100" font-size="36" fill="white" font-family="Courier New">[</text>
  <text x="80" y="100" font-size="36" fill="lightgreen" font-family="Courier New">1</text>
  <text x="120" y="100" font-size="36" fill="salmon" font-family="Courier New">-2</text>
  <text x="160" y="100" font-size="36" fill="white" font-family="Courier New">]</text>

  <!-- Vector 列向量大括号实现 -->
  <!-- 左中括号 -->
  <line x1="210" y1="59" x2="210" y2="161" stroke="white" stroke-width="2" /> <!-- 长竖线 -->
  <line x1="210" y1="60" x2="220" y2="60" stroke="white" stroke-width="2" />
  <line x1="210" y1="160" x2="220" y2="160" stroke="white" stroke-width="2" />

  <!-- 右中括号 -->
  <line x1="260" y1="59" x2="260" y2="161" stroke="white" stroke-width="2" />
  <line x1="250" y1="60" x2="260" y2="60" stroke="white" stroke-width="2" />
  <line x1="250" y1="160" x2="260" y2="160" stroke="white" stroke-width="2" />

  <!-- 列向量内容，使用等宽字体 -->
  <text x="235" y="95" font-size="36" fill="lightgreen" font-family="Courier New" text-anchor="middle">4</text>
  <text x="235" y="145" font-size="36" fill="salmon" font-family="Courier New" text-anchor="middle">3</text>

  <!-- Vector 标签 -->
  <text x="215" y="190" font-size="28" fill="gold" font-family="Courier New">Vector</text>

  <!-- 等号 -->
  <text x="300" y="110" font-size="36" fill="white" font-family="Courier New">=</text>

  <!-- 点积展开式 -->
  <text x="350" y="110" font-size="36" font-family="Courier New">
    <tspan fill="lightgreen">4</tspan>
    <tspan fill="white">·</tspan>
    <tspan fill="lightgreen">1</tspan>
    <tspan fill="white"> + </tspan>
    <tspan fill="salmon">3</tspan>
    <tspan fill="white">·</tspan>
    <tspan fill="salmon">-2</tspan>
  </text>
</svg>

<p>寄了, 我感觉我没法在逻辑上理解为什么这个转秩一下是一样的</p>

<p>虽然过程混乱, 但是问题被总结为, 为什么对于$\begin{bmatrix} 3 \ 4 \end{bmatrix} \times \begin{bmatrix} 5 \ 2 \end{bmatrix}$和 $\begin{bmatrix} 3 \ 4 \end{bmatrix} \cdot \begin{bmatrix} 5 \ 2 \end{bmatrix}$ 是不是地位等价?  为什么3 只可以和5乘呢? 这个从2维到1维的变换中,  $\begin{bmatrix} 3 \ 4 \end{bmatrix}$ 只被认为是变换器的角色</p>

<p>视频的8:45</p>

<svg viewBox="0 0 700 300" xmlns="http://www.w3.org/2000/svg">
  <!-- 黑色背景 -->
  <rect width="100%" height="100%" fill="black" />

  <!-- 标题 -->
  <text x="50" y="155" font-size="28" fill="white" font-family="Courier New">Projection matrix:</text>

  <!-- 左中括号 -->
  <line x1="380" y1="130" x2="380" y2="170" stroke="white" stroke-width="2" />
  <line x1="380" y1="130" x2="390" y2="130" stroke="white" stroke-width="2" />
  <line x1="380" y1="170" x2="390" y2="170" stroke="white" stroke-width="2" />

  <!-- 右中括号 -->
  <line x1="490" y1="130" x2="490" y2="170" stroke="white" stroke-width="2" />
  <line x1="480" y1="130" x2="490" y2="130" stroke="white" stroke-width="2" />
  <line x1="480" y1="170" x2="490" y2="170" stroke="white" stroke-width="2" />

  <!-- 矩阵元素问号 -->
  <text x="400" y="160" font-size="36" fill="lightgreen" font-family="Courier New">?</text>
  <text x="450" y="160" font-size="36" fill="salmon" font-family="Courier New">?</text>

  <!-- 上箭头（î） -->
  <line x1="410" y1="80" x2="410" y2="120" stroke="lightgreen" stroke-width="3" marker-end="url(#arrowGreen)" />
  <text x="410" y="75" font-size="18" fill="lightgreen" font-family="Courier New">Where î lands</text>

  <!-- 下箭头（ĵ） -->
  <line x1="460" y1="210" x2="460" y2="175" stroke="salmon" stroke-width="3" marker-end="url(#arrowRed)" />
  <text x="460" y="235" font-size="18" fill="salmon" font-family="Courier New">Where ĵ lands</text>

  <!-- 箭头定义 -->
  <defs>
    <marker id="arrowGreen" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto">
      <polygon points="0,0 6,3 0,6" fill="lightgreen" />
    </marker>
    <marker id="arrowRed" markerWidth="6" markerHeight="6" refX="3" refY="3" orient="auto">
      <polygon points="0,0 6,3 0,6" fill="salmon" />
    </marker>
  </defs>
</svg>

<p>为什么要这样, 就是在这个穿过原点的数轴被建立之后, 这里的 $[x_1,x_2]$ 其实就是下面的 $\hat{u}$ 的作为在二维坐标轴上的值, 但是注意同时也是标准基向量 $\hat{i}$ 和 $\hat{j}$ 到那个一维数轴上的投影长度,</p>

<svg width="600" height="300" viewBox="-150 -170 300 300" xmlns="http://www.w3.org/2000/svg" style="background-color: black;">

  <defs>
    <marker id="arrowhead_yellow" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="yellow" />
    </marker>
    <marker id="arrowhead_dk_yellow" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="lightgreen" />
    </marker>
    <marker id="arrowhead_salmon" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="salmon" />
    </marker>
    <symbol id="tick" viewBox="-1 -5 2 10">
        <line x1="0" y1="-4" x2="0" y2="4" stroke-width="1" />
    </symbol>
  </defs>

  <g id="grid" stroke="#add8e6" stroke-width="0.5">
     <line x1="-300" y1="-300" x2="-300" y2="300" /> <line x1="-200" y1="-300" x2="-200" y2="300" /> <line x1="-100" y1="-300" x2="-100" y2="300" /> <line x1="0" y1="-300" x2="0" y2="300" stroke-width="1" /> <line x1="100" y1="-300" x2="100" y2="300" /> <line x1="200" y1="-300" x2="200" y2="300" /> <line x1="300" y1="-300" x2="300" y2="300" /> <line x1="-300" y1="-300" x2="300" y2="-300" /> <line x1="-300" y1="-200" x2="300" y2="-200" /> <line x1="-300" y1="-100" x2="300" y2="-100" /> <line x1="-300" y1="0" x2="300" y2="0" stroke-width="1" /> <line x1="-300" y1="100" x2="300" y2="100" /> <line x1="-300" y1="200" x2="300" y2="200" /> <line x1="-300" y1="300" x2="300" y2="300" /> </g>

  <g id="lines">
    <line x1="-300" y1="124.2" x2="300" y2="-124.2" stroke="white" stroke-width="2.2" stroke-dasharray="5, 5" />
    <text x="-210" y="130" fill="white" font-family="Courier New" font-size="16" transform="rotate(-22.5 -280 130)" text-anchor="start">Line of symmetry</text>

    <line x1="-300" y1="300" x2="300" y2="-300" stroke="lightblue" stroke-width="2.2" />
  </g>

  <g id="blue_axis_markings" fill="grey" font-family="Courier New" font-size="20" text-anchor="middle">
         <g transform="translate(282.8, -282.8)"> <use href="#tick" stroke="white" />
             <text dx="10" dy="-10">2</text>
        </g>
        <g transform="translate(-141.4, 141.4)"> <use href="#tick" stroke="white" transform="rotate(-45) rotate(90)" />
             <text dx="-10" dy="10">-1</text>
        </g>
        <g transform="translate(-282.8, 282.8)"> <use href="#tick" stroke="white" />
             <text dx="-10" dy="10">-2</text>
        </g>
   </g>

  <g id="vectors_projections">
     <line x1="0" y1="0" x2="200" y2="0" stroke="lightgreen" stroke-width="2" marker-end="url(#arrowhead_dk_yellow)" />
    <text x="205" y="-5" fill="lightgreen" font-family="serif" font-style="italic" font-size="28">î</text>

    <line x1="0" y1="0" x2="140" y2="-140" stroke="yellow" stroke-width="2" marker-end="url(#arrowhead_yellow)" />
    <text x="146" y="-146" fill="yellow" font-family="serif" font-style="italic" font-size="28">û</text>
    
    <line x1="141.4" y1="-141.4" x2="141.4" y2="0" stroke="grey" stroke-width="1" stroke-dasharray="3, 3" />
    
    <line x1="200" y1="0" x2="100" y2="-100" stroke="grey" stroke-width="1" stroke-dasharray="3, 3" />
    
    <line x1="0" y1="0" x2="100" y2="-100" stroke="salmon" stroke-width="2" stroke-dasharray="4,4" opacity="1.0" marker-end="url(#arrowhead_salmon)" />
    <text x="105" y="-85" fill="salmon" font-family="sans-serif" font-style="italic" font-size="16">u<tspan baseline-shift="sub" font-size="12">x</tspan></text>
    
    <line x1="0" y1="0" x2="141.4" y2="0" stroke="salmon" stroke-width="2" stroke-dasharray="4,4" opacity="1.0" marker-end="url(#arrowhead_salmon)" />
     <text x="120.7" y="-15" fill="salmon" font-family="sans-serif" font-style="italic" font-size="16" text-anchor="middle">u<tspan baseline-shift="sub" font-size="12">x</tspan></text>

  </g>

  <g id="text_labels" fill="white" font-family="sans-serif">
    <text x="-290" y="-280" font-size="16">Where do <tspan font-family="serif" font-style="italic">î</tspan> and <tspan font-family="serif" font-style="italic">ĵ</tspan> land?</text>
    <text x="-270" y="-260" font-size="16" font-family="monospace">[ </text>
    <text x="-220" y="-260" font-size="16" font-family="monospace">]</text>
    <text x="5" y="15" font-size="20">o</text> <text x="200" y="20" font-size="20" text-anchor="middle">1</text>
    <text x="-200" y="20" font-size="20" text-anchor="middle">-1</text>
    <text x="-5" y="-193" font-size="20" text-anchor="end">1</text>
    <text x="-5" y="207" font-size="20" text-anchor="end">-1</text>
  </g>

</svg>

<p>![[Screenshot 2025-05-02 at 11.10.30 PM.png]]</p>

<p>OK, 那问题好像解决了, 就对于二维 $\begin{bmatrix} a \ b \end{bmatrix}$ 来说, 它中作为一个点or一个箭头, 我们的 $a$ 和 $b$ 各是标准基向量 $\hat{i}$ 和 $\hat{j}$ 构建的, 如果要 onto 到我们的数轴上, 当然, 只能 grab 我们对应的数值</p>

<svg viewBox="0 0 650 280" xmlns="http://www.w3.org/2000/svg">
  <!-- 背景 -->
  <rect width="100%" height="100%" fill="black" />

  <!-- “Transform” 标签 -->
  <text x="55" y="90" font-size="28" fill="skyblue" font-family="Courier New">Transform</text>

  <!-- 行向量 [uₓ uᵧ] -->
  <text x="60" y="132" font-size="36" fill="white" font-family="Courier New">[</text>
  <text x="90" y="130" font-size="36" font-family="Courier New">
    <tspan fill="#CCCC66">u</tspan>
    <!-- 下标微调 -->
    <tspan dx="-20px" dy="2px" baseline-shift="-10%" font-size="24" fill="#88CC88">x</tspan>
  </text>
  <text x="150" y="130" font-size="36" font-family="Courier New">
    <tspan fill="#CCCC66">u</tspan>
    <tspan dx="-20px" dy="2px" baseline-shift="-10%" font-size="24" fill="#E59494">y</tspan>
  </text>
  <text x="190" y="132" font-size="36" fill="white" font-family="Courier New">]</text>

  <!-- 列向量 [x; y] 用中括号和线条 -->
  <!-- 左中括号 -->
  <line x1="230" y1="80" x2="230" y2="180" stroke="white" stroke-width="2" />
  <line x1="230" y1="80" x2="240" y2="80" stroke="white" stroke-width="2" />
  <line x1="230" y1="180" x2="240" y2="180" stroke="white" stroke-width="2" />
  <!-- 右中括号 -->
  <line x1="290" y1="80" x2="290" y2="180" stroke="white" stroke-width="2" />
  <line x1="280" y1="80" x2="290" y2="80" stroke="white" stroke-width="2" />
  <line x1="280" y1="180" x2="290" y2="180" stroke="white" stroke-width="2" />
  <!-- 列向量内容 -->
  <text x="260" y="110" font-size="36" fill="#CC88CC" font-family="Courier New" text-anchor="middle">x</text>
  <text x="260" y="160" font-size="36" fill="#CC88CC" font-family="Courier New" text-anchor="middle">y</text>

  <!-- “Vector” 标签 -->
  <text x="210" y="220" font-size="28" fill="#CC88CC" font-family="Courier New">Vector</text>

  <!-- 等号 -->
  <text x="310" y="135" font-size="36" fill="#EEEEEE" font-family="Courier New">=</text>

  <!-- 点积展开式 uₓ·x + uᵧ·y，紧凑且饱和度降低 -->
  <text x="340" y="135" font-size="36" font-family="Courier New">
    <tspan>
      <tspan fill="#CCCC66">u</tspan>
      <tspan dx="-20px" dy="2px" baseline-shift="-10%" font-size="24" fill="#88CC88">x</tspan>
    </tspan>
    <tspan fill="#EEEEEE" dx="-30px">·</tspan>
    <tspan fill="#CC88CC" dx="-12px">x</tspan>
    <tspan fill="#EEEEEE" dx="-4px"> + </tspan>
    <tspan>
      <tspan fill="#CCCC66">u</tspan>
      <tspan dx="-20px" dy="2px" baseline-shift="-10%" font-size="24" fill="#E59494">y</tspan>
    </tspan>
    <tspan fill="#EEEEEE" dx="-25px">·</tspan>
    <tspan fill="#CC88CC" dx="-12px">y</tspan>
  </text>
</svg>

<p>first projecting onto that vector</p>

<p>这里建立了数值和vector的联系, 就是说, 我们横向的一维度的object(指这里的 $u_x \dots to\dots u_y$), 可以认为是一个个变换运动(跳出2维), 但是同时, 这里把这个动作(们)对称回去, 也可以是我们的向量(也就是竖着的), 
这里从直觉上不对称的投影行为, 被我们整理成一个个可以理解的变换了, 然后注意, 对称也实现了如何实现的, 在倒数第二个截图的位置, 在$\hat{i}$ 在  $\hat{u}$ 所在的数轴上是一个数值(这描述一个变换), 同时 $\hat{u}$在 $\hat{i}$ 的方向上, 如果被表示成一个数, 是$\hat{u}$ 向量在二维坐标系中, $\hat{i}$方向上的分量. 
这里的数值是一样的, 这里的变换是对称的, 只是我们从图像上给他们赋予的实际意义不同, 太美了,这是duality.</p>

<h1 id="appendix">Appendix</h1>

<p>一张被淘汰的作图</p>

<svg width="600" height="600" viewBox="-300 -300 600 600" xmlns="http://www.w3.org/2000/svg" style="background-color: black;">

  <defs>
    <marker id="arrowhead_yellow" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="yellow" />
    </marker>
    <marker id="arrowhead_dk_yellow" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="lightgreen" />
    </marker>
    <marker id="arrowhead_salmon" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" markerUnits="strokeWidth">
      <polygon points="0 0, 7 2.5, 0 5" fill="salmon" />
    </marker>
    <symbol id="tick" viewBox="-1 -5 2 10">
        <line x1="0" y1="-4" x2="0" y2="4" stroke-width="1" />
    </symbol>
  </defs>

  <g id="grid" stroke="#add8e6" stroke-width="0.5">
     <line x1="-300" y1="-300" x2="-300" y2="300" /> <line x1="-200" y1="-300" x2="-200" y2="300" /> <line x1="-100" y1="-300" x2="-100" y2="300" /> <line x1="0" y1="-300" x2="0" y2="300" stroke-width="1" /> <line x1="100" y1="-300" x2="100" y2="300" /> <line x1="200" y1="-300" x2="200" y2="300" /> <line x1="300" y1="-300" x2="300" y2="300" /> <line x1="-300" y1="-300" x2="300" y2="-300" /> <line x1="-300" y1="-200" x2="300" y2="-200" /> <line x1="-300" y1="-100" x2="300" y2="-100" /> <line x1="-300" y1="0" x2="300" y2="0" stroke-width="1" /> <line x1="-300" y1="100" x2="300" y2="100" /> <line x1="-300" y1="200" x2="300" y2="200" /> <line x1="-300" y1="300" x2="300" y2="300" /> </g>

  <g id="lines">
    <line x1="-300" y1="124.2" x2="300" y2="-124.2" stroke="white" stroke-width="2.2" stroke-dasharray="5, 5" />
    <text x="-280" y="130" fill="white" font-family="sans-serif" font-size="14" transform="rotate(-22.5 -280 130)" text-anchor="start">Line of symmetry</text>

    <line x1="-300" y1="300" x2="300" y2="-300" stroke="lightblue" stroke-width="2.2" />
  </g>

  <g id="blue_axis_markings" fill="grey" font-family="sans-serif" font-size="20" text-anchor="middle">
        <g transform="translate(141.4, -141.4)"> <use href="#tick" stroke="white" />
             <text dx="10" dy="-10">1</text>
        </g>
         <g transform="translate(282.8, -282.8)"> <use href="#tick" stroke="white" />
             <text dx="10" dy="-10">2</text>
        </g>
        <g transform="translate(-141.4, 141.4)"> <use href="#tick" stroke="white" transform="rotate(-45) rotate(90)" />
             <text dx="-10" dy="10">-1</text>
        </g>
        <g transform="translate(-282.8, 282.8)"> <use href="#tick" stroke="white" />
             <text dx="-10" dy="10">-2</text>
        </g>
   </g>

  <g id="vectors_projections">
     <line x1="0" y1="0" x2="200" y2="0" stroke="lightgreen" stroke-width="2" marker-end="url(#arrowhead_dk_yellow)" />
    <text x="205" y="-5" fill="lightgreen" font-family="serif" font-style="italic" font-size="28">î</text>

    <line x1="0" y1="0" x2="140" y2="-140" stroke="yellow" stroke-width="2" marker-end="url(#arrowhead_yellow)" />
    <text x="146" y="-146" fill="yellow" font-family="serif" font-style="italic" font-size="28">û</text>
    
    <line x1="141.4" y1="-141.4" x2="141.4" y2="0" stroke="grey" stroke-width="1" stroke-dasharray="3, 3" />
    
    <line x1="200" y1="0" x2="100" y2="-100" stroke="grey" stroke-width="1" stroke-dasharray="3, 3" />
    
    <line x1="0" y1="0" x2="100" y2="-100" stroke="salmon" stroke-width="2" stroke-dasharray="4,4" opacity="1.0" marker-end="url(#arrowhead_salmon)" />
    <text x="105" y="-85" fill="salmon" font-family="sans-serif" font-style="italic" font-size="16">u<tspan baseline-shift="sub" font-size="12">x</tspan></text>
    
    <line x1="0" y1="0" x2="141.4" y2="0" stroke="salmon" stroke-width="2" stroke-dasharray="4,4" opacity="1.0" marker-end="url(#arrowhead_salmon)" />
     <text x="120.7" y="-15" fill="salmon" font-family="sans-serif" font-style="italic" font-size="16" text-anchor="middle">u<tspan baseline-shift="sub" font-size="12">x</tspan></text>

  </g>

  <g id="text_labels" fill="white" font-family="sans-serif">
    <text x="-290" y="-280" font-size="16">Where do <tspan font-family="serif" font-style="italic">î</tspan> and <tspan font-family="serif" font-style="italic">ĵ</tspan> land?</text>
    <text x="-270" y="-260" font-size="16" font-family="monospace">[ </text>
    <text x="-220" y="-260" font-size="16" font-family="monospace">]</text>
    <text x="5" y="15" font-size="20">o</text> <text x="200" y="20" font-size="20" text-anchor="middle">1</text>
    <text x="-200" y="20" font-size="20" text-anchor="middle">-1</text>
    <text x="-5" y="-193" font-size="20" text-anchor="end">1</text>
    <text x="-5" y="207" font-size="20" text-anchor="end">-1</text>
  </g>

</svg>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[3Blue1Brown]]></summary></entry><entry><title type="html">Linear Algebra Starting from Matrix Multiplication</title><link href="http://localhost:4000/%E4%BB%8EMatrix-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear-Algebra/" rel="alternate" type="text/html" title="Linear Algebra Starting from Matrix Multiplication" /><published>2025-04-25T00:00:00+08:00</published><updated>2025-04-25T00:00:00+08:00</updated><id>http://localhost:4000/%E4%BB%8EMatrix%20%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear%20Algebra</id><content type="html" xml:base="http://localhost:4000/%E4%BB%8EMatrix-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%87%BA%E5%8F%91%E7%9A%84Linear-Algebra/"><![CDATA[<p>好像写成一个的线代的内容了, 有很多未完待续的内容</p>

<p>我可以算出矩阵乘法的题目，但当涉及到矩阵乘法的<strong>交换顺序的意义</strong>，或者说矩阵乘法<strong>本身的内在含义</strong>时，我往往无法在第一时间作出直觉反应。</p>

<p>在做矩阵乘法的时候，我依赖的是一种背诵的技巧, 提醒自己这个东西叫 “行列式”, 所以“前一个矩阵的行, 乘以后一个矩阵的列”。但我并不知道这个操作<strong>实际上意味着什么</strong>。 经过自己的反思，我发现，我之所以缺乏这种直觉，是因为我对“矩阵乘法”这一概念没有真正理解。在除了得到一个结果外, 矩阵乘法到底在干什么。这个很基本的数学定义 or 数学概念想要解决现实中的什么问题?</p>

<p>这种基于死记硬背的方式，让我在进一步思考矩阵相关的概念时(如旋转、投影、缩放等操作, 或者是去括号, 转置, 求可逆矩阵的一些变式)，总是感觉模糊和经常出错。因为从最底层开始，我对矩阵的理解就是模糊的，甚至可以说是错的，导致我没法基于它构建准确的思维。</p>

<p>我想解决这个问题。</p>

<p>线性变换的复合 (Composition of Linear Transformations)</p>

<h3 id="出现问题的一个comment的场景">出现问题的一个comment的场景</h3>
<p>下面是一个 $5 \times 5$ 的矩阵相乘的例子, 这是一个很好的例子就是, 
\(\begin{bmatrix} A_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} &amp; a_{15} \\ A_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} &amp; a_{25} \\ A_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} &amp; a_{35} \\ A_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} &amp; a_{45} \\ A_{51} &amp; a_{52} &amp; a_{53} &amp; a_{54} &amp; a_{55} \\ \end{bmatrix} \times \begin{bmatrix} B_{11} &amp; b_{12} &amp; b_{13} &amp; b_{14} &amp; b_{15} \\ B_{21} &amp; b_{22} &amp; b_{23} &amp; b_{24} &amp; b_{25} \\ B_{31} &amp; b_{32} &amp; b_{33} &amp; b_{34} &amp; b_{35} \\ B_{41} &amp; b_{42} &amp; b_{43} &amp; b_{44} &amp; b_{45} \\ B_{51} &amp; b_{52} &amp; b_{53} &amp; b_{54} &amp; b_{55} \\ \end{bmatrix} = \begin{bmatrix} C_{11} &amp; c_{12} &amp; c_{13} &amp; c_{14} &amp; c_{15} \\ C_{21} &amp; c_{22} &amp; c_{23} &amp; c_{24} &amp; c_{25} \\ C_{31} &amp; c_{32} &amp; c_{33} &amp; c_{34} &amp; c_{35} \\ C_{41} &amp; c_{42} &amp; c_{43} &amp; c_{44} &amp; c_{45} \\ C_{51} &amp; c_{52} &amp; c_{53} &amp; c_{54} &amp; c_{55} \\ \end{bmatrix}\)</p>

<p>疑惑的点是, 如果认为任意一个matrix都是列向量的话, 那么其实在这个显而易见的式子中, $A   x = b$ 中, 一个认知是$A$  可以被认为是一个大的系统(如果是 n by m的matrix), $x$作为一个vector(拆分成竖直方向上的单列) (woc这里应该是 1 乘 多少的单列vector我不可以一秒判断出来), 由于疑惑, 我回到传统想法上的记住行列式的乘法的方法, 会发现, 这个结果也是一列的其实, 但是我对于怎么乘是模糊的, OK再想 行乘以列这个口诀, 也就是说, vector的第一个, 乘了A的第一个行, 这是也是第一个b上的结果, 那么这个第一个位置上的结果到底是什么东西呢, 不是最后要写的结果, 而是搞不明白代表什么东西</p>

<h1 id="3blue1brown-linear-transformations-and-matrices--chapter-3-essence-of-linear-algebra">{3Blue1Brown} Linear transformations and matrices | Chapter 3, Essence of linear algebra</h1>

<p>回到一个简单的问题, 下面是一个在二维平面中的vector,
\(\vec{v} = \begin{bmatrix} -1 \\ 2 \end{bmatrix}\) 如何看待这个对象呢, 可以认为是, 使用两个单位矩阵构造的, which is  $\hat{j} = \begin{bmatrix} 0\ 1 \end{bmatrix}$ 和$\hat{i}= \begin{bmatrix} 1\ 0 \end{bmatrix}$, 这里可以注意到, $\hat{j}$ 在 $y$ 轴上, 而 $\hat{i}$ 在 $x$ 轴上, 那么我们的 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ 是如何得到的呢?  使用线性变换(注:要补充)的概念非常简单, 我们可以得到
\(\vec{v} = (-1) \cdot \hat{i} + 2 \cdot \hat{j} = (-1) \cdot \begin{bmatrix} 1\\ 0 \end{bmatrix} + 2 \cdot \begin{bmatrix} 0\\ 1 \end{bmatrix} = \begin{bmatrix} -1 \\ 2 \end{bmatrix}\)</p>

<p>OK, 再进一步的视角是, 
\(\)</p>

<p>我原来以为, $\begin{bmatrix} -1 \ 2 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 是可以得到 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ , 但是现在发现我错了(而且这也是非法的矩阵相乘), 应该是$\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$因为和下面的逻辑混淆了, 3Blue1Brown说, 对于(这里我随机写了一个例子) $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 这里其实是让新的基底变成 $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix}$ 而不再是原来的 $\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 我在想是不是原来对于 $\begin{bmatrix} -1 \ 2 \end{bmatrix}$ 是不是后面都藏着一个 $\begin{bmatrix} 1 &amp; 0 \0 &amp;1 \end{bmatrix}$ 代表着原来的基底?</p>

<p>哦哦, 不是的, 应该说一个结果的基座向量会写在结果的前面, $I \cdot \vec{v} = \begin{bmatrix} 1 &amp; 0 \ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix} = \begin{bmatrix} -1 \ 2 \end{bmatrix}$, 这样反而是恰当的, 合乎逻辑的, 但是在前面乘一个单位矩阵太傻了, 但是可以发现的是, 在前面乘就是提供 一个要变换的指令, 只不过单位矩阵恰好是没有任何变化要求的那个. 而 $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 可以被认为是$\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} 1 &amp; 0 \ 0 &amp; 1 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$</p>

<font color="red">这个表述错了</font>
<p>$\rightarrow$ 其实在$\begin{bmatrix} -1 \ 2 \end{bmatrix}$的后面乘是逆变化, 不过这是后话了. <font color="red">变化可以认为就是在前面乘, 在前面乘就是在做各种线性操作, 比如转回去就是在前面的位置乘一个逆就行了</font></p>

<p>但是我好像还是没搞懂为什么能变成这样, $(-1) \cdot \begin{bmatrix} -1 \ 1\end{bmatrix} \cdot + 2 \cdot  \begin{bmatrix} 4 \ 2\end{bmatrix}$ 
3Blue1Brown的视频中, 是这样写的, $\begin{bmatrix} -1 \ 2 \end{bmatrix}$  被我们看成了单独放置的点 or 一个向量的箭头指向这个点的位置, 这样的意义也可以这样表示$\vec{v} = -1 \cdot \vec{i}_1 + 2 \cdot \vec{j}_2$,  这个点的表示分, 我突然看到感觉好陌生, 之前好像没有只是顺着写了一下, 自己不知道为什么可以这样写. OK, 如果可以这样写的话, 就相对清晰了, 就是, 直接换了一套基座, 对于这个式子而言, $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix} \cdot \begin{bmatrix} -1 \ 2 \end{bmatrix}$ 不是吗,</p>

<h2 id="再描述一个更加抽象的例子">再描述一个更加抽象的例子</h2>

\[A \cdot B = C\]

<p>这里的$A$ 和 $B$ 都是 $4 \times 4$ 的matrix</p>

<p>从列的角度看这个问题后, <font color="red">好吧, 突然我也不知道这里从列的角度看是什么意思</font>, 我姑且认为在做的开始, $A$ 和 $B$ 都被认为是一列一列呈现的</p>

<p>$A$就被我们看成从$$</p>

<p>A = \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; a_{14} \ a_{21} &amp; a_{22} &amp; a_{23} &amp; a_{24} \ a_{31} &amp; a_{32} &amp; a_{33} &amp; a_{34} \ a_{41} &amp; a_{42} &amp; a_{43} &amp; a_{44} \end{bmatrix}
\(​​​​
列向量视角的 $A$：\)
A = \left[ \vec{a}_1 \quad \vec{a}_2 \quad \vec{a}_3 \quad \vec{a}_4 \right]
$$</p>

\[\vec{a}_1 = \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix}, \quad
\vec{a}_2 = \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix}, \quad
\vec{a}_3 = \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix}, \quad
\vec{a}_4 = \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix}\]

<p>OK, 我们得到 $A = \left[ \vec{a}_1 \quad \vec{a}_2 \quad \vec{a}_3 \quad \vec{a}_4 \right]$ 后开始处理 $B$ , 同样列向量视角
​​​​
 从\(B = \begin{bmatrix} b_{11} &amp; b_{12} &amp; b_{13} &amp; b_{14} \\ b_{21} &amp; b_{22} &amp; b_{23} &amp; b_{24} \\ b_{31} &amp; b_{32} &amp; b_{33} &amp; b_{34} \\ b_{41} &amp; b_{42} &amp; b_{43} &amp; b_{44} \end{bmatrix}\)
​到
\(B = \left[ \vec{b}_1 \quad \vec{b}_2 \quad \vec{b}_3 \quad \vec{b}_4 \right]\)</p>

\[\vec{b}_1 = \begin{bmatrix} b_{11} \\ b_{21} \\ b_{31} \\ b_{41} \end{bmatrix}, \quad
\vec{b}_2 = \begin{bmatrix} b_{12} \\ b_{22} \\ b_{32} \\ b_{42} \end{bmatrix},
\quad

\vec{b}_3 = \begin{bmatrix} b_{13} \\ b_{23} \\ b_{33} \\ b_{43} \end{bmatrix},
\quad

\vec{b}_4 = \begin{bmatrix} b_{14} \\ b_{24} \\ b_{34} \\ b_{44} \end{bmatrix},
\quad\]

<p>写完后, 我们的 $B$ 作为之前的数值位置, $A$中的向量都是作为新的坐标系来构建, 那么我们可以得到</p>

<h2 id="3-列中列展开法的具体表示">3. “列中列”展开法的具体表示</h2>

<p>矩阵乘积 $C = A \cdot B$ 的完整展开形式：</p>

\[C = \left[ \begin{array}{cccc} b_{11} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{21} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{31} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{41} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{12} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{22} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{32} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{42} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{13} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{23} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{33} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{43} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} &amp; b_{14} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{24} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{34} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{44} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix} \end{array} \right]\]

<p>$\rightarrow$</p>

<p>\(\left[ \begin{array}{cccc} \begin{bmatrix} b_{11} a_{11} \\ b_{11} a_{21} \\ b_{11} a_{31} \\ b_{11} a_{41} \end{bmatrix} + \begin{bmatrix} b_{21} a_{12} \\ b_{21} a_{22} \\ b_{21} a_{32} \\ b_{21} a_{42} \end{bmatrix} + \begin{bmatrix} b_{31} a_{13} \\ b_{31} a_{23} \\ b_{31} a_{33} \\ b_{31} a_{43} \end{bmatrix} + \begin{bmatrix} b_{41} a_{14} \\ b_{41} a_{24} \\ b_{41} a_{34} \\ b_{41} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{12} a_{11} \\ b_{12} a_{21} \\ b_{12} a_{31} \\ b_{12} a_{41} \end{bmatrix} + \begin{bmatrix} b_{22} a_{12} \\ b_{22} a_{22} \\ b_{22} a_{32} \\ b_{22} a_{42} \end{bmatrix} + \begin{bmatrix} b_{32} a_{13} \\ b_{32} a_{23} \\ b_{32} a_{33} \\ b_{32} a_{43} \end{bmatrix} + \begin{bmatrix} b_{42} a_{14} \\ b_{42} a_{24} \\ b_{42} a_{34} \\ b_{42} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{13} a_{11} \\ b_{13} a_{21} \\ b_{13} a_{31} \\ b_{13} a_{41} \end{bmatrix} + \begin{bmatrix} b_{23} a_{12} \\ b_{23} a_{22} \\ b_{23} a_{32} \\ b_{23} a_{42} \end{bmatrix} + \begin{bmatrix} b_{33} a_{13} \\ b_{33} a_{23} \\ b_{33} a_{33} \\ b_{33} a_{43} \end{bmatrix} + \begin{bmatrix} b_{43} a_{14} \\ b_{43} a_{24} \\ b_{43} a_{34} \\ b_{43} a_{44} \end{bmatrix} &amp; \begin{bmatrix} b_{14} a_{11} \\ b_{14} a_{21} \\ b_{14} a_{31} \\ b_{14} a_{41} \end{bmatrix} + \begin{bmatrix} b_{24} a_{12} \\ b_{24} a_{22} \\ b_{24} a_{32} \\ b_{24} a_{42} \end{bmatrix} + \begin{bmatrix} b_{34} a_{13} \\ b_{34} a_{23} \\ b_{34} a_{33} \\ b_{34} a_{43} \end{bmatrix} + \begin{bmatrix} b_{44} a_{14} \\ b_{44} a_{24} \\ b_{44} a_{34} \\ b_{44} a_{44} \end{bmatrix} \end{array} \right]\) 
$\rightarrow$</p>

<p>其中我们拿出一条来
\(b_{11} \cdot \begin{bmatrix} a_{11} \\ a_{21} \\ a_{31} \\ a_{41} \end{bmatrix} + b_{21} \cdot \begin{bmatrix} a_{12} \\ a_{22} \\ a_{32} \\ a_{42} \end{bmatrix} + b_{31} \cdot \begin{bmatrix} a_{13} \\ a_{23} \\ a_{33} \\ a_{43} \end{bmatrix} + b_{41} \cdot \begin{bmatrix} a_{14} \\ a_{24} \\ a_{34} \\ a_{44} \end{bmatrix}\)
是这样的, 
\(\begin{bmatrix} b_{11}a_{11} \\ b_{11}a_{21} \\ b_{11}a_{31} \\ b_{11}a_{41} \end{bmatrix} + \begin{bmatrix} b_{21}a_{12} \\ b_{21}a_{22} \\ b_{21}a_{32} \\ b_{21}a_{42} \end{bmatrix} + \begin{bmatrix} b_{31} a_{13} \\ b_{31}a_{23} \\ b_{31} a_{33} \\ b_{31} a_{43} \end{bmatrix} +\begin{bmatrix} b_{41}a_{14} \\ b_{41}a_{24} \\ b_{41}a_{34} \\ b_{41}a_{44} \end{bmatrix}\)</p>

<p>再线性相加
\(= \begin{bmatrix} b_{11}a_{11} + b_{21}a_{12} + b_{31}a_{13} + b_{41}a_{14} \\ b_{11}a_{21} + b_{21}a_{22} + b_{31}a_{23} + b_{41}a_{24} \\ b_{11}a_{31} + b_{21}a_{32} + b_{31}a_{33} + b_{41}a_{34} \\ b_{11}a_{41} + b_{21}a_{42} + b_{31}a_{43} + b_{41}a_{44} \end{bmatrix}\)</p>

<p>这是一个$4\times 1$的矩阵, 然后我们有4条, 最后是 一个$4\times 4$ 的结果</p>

\[\begin{bmatrix} a_{11} b_{11} + a_{12} b_{21} + a_{13} b_{31} + a_{14} b_{41} &amp; a_{11} b_{12} + a_{12} b_{22} + a_{13} b_{32} + a_{14} b_{42} &amp; a_{11} b_{13} + a_{12} b_{23} + a_{13} b_{33} + a_{14} b_{43} &amp; a_{11} b_{14} + a_{12} b_{24} + a_{13} b_{34} + a_{14} b_{44} \\ a_{21} b_{11} + a_{22} b_{21} + a_{23} b_{31} + a_{24} b_{41} &amp; a_{21} b_{12} + a_{22} b_{22} + a_{23} b_{32} + a_{24} b_{42} &amp; a_{21} b_{13} + a_{22} b_{23} + a_{23} b_{33} + a_{24} b_{43} &amp; a_{21} b_{14} + a_{22} b_{24} + a_{23} b_{34} + a_{24} b_{44} \\ a_{31} b_{11} + a_{32} b_{21} + a_{33} b_{31} + a_{34} b_{41} &amp; a_{31} b_{12} + a_{32} b_{22} + a_{33} b_{32} + a_{34} b_{42} &amp; a_{31} b_{13} + a_{32} b_{23} + a_{33} b_{33} + a_{34} b_{43} &amp; a_{31} b_{14} + a_{32} b_{24} + a_{33} b_{34} + a_{34} b_{44} \\ a_{41} b_{11} + a_{42} b_{21} + a_{43} b_{31} + a_{44} b_{41} &amp; a_{41} b_{12} + a_{42} b_{22} + a_{43} b_{32} + a_{44} b_{42} &amp; a_{41} b_{13} + a_{42} b_{23} + a_{43} b_{33} + a_{44} b_{43} &amp; a_{41} b_{14} + a_{42} b_{24} + a_{43} b_{34} + a_{44} b_{44} \end{bmatrix}\]

<p>这时候有一些经典的问题, 就是从这个转动的性质出发了</p>

<ol>
  <li>
    <p><strong>矩阵相乘是否满足交换率?</strong> 当然不行, 都完全是两个东西了</p>
  </li>
  <li>
    <p><strong>矩阵相乘成立的条件是前一个matrix的什么要等于后一个matrix的什么?</strong> 完全不用急, 想着 $Ax = b$ 在这个时候,  $A$ 是我们的旋转/变换系统, 想象每一列都是独立的, rank是满秩的(其实不用只要操作的时候有那个维度就OK了), 那么在这个情况下, 我们的 $x$ 中的 $[x_1 \dots x_n]$ 当然是要和前面的 $A$ 有多少列要匹配了</p>
  </li>
  <li>
    <font color="red">这里理解错了, 说明有知识点没懂</font>
    <p>$Ax = b$ 中的 b是 几乘几点结果, 感觉x的维度是怎样, b就长怎样? 如果从 $A$ 是提供旋转功能的角度出发的话, 为什么会因为旋转 b相比原先旋转的对象 x 增加维度呢?
 这其实是更广义的「<strong>线性变换</strong>」，不仅仅是旋转, 不一定是严格的旋转，它可以是 <strong>旋转 + 拉伸</strong>(放大缩小) 投影 (把高维变低维) 嵌入 (把低维映射到高维) 剪切(shear)</p>
  </li>
  <li><strong>如果说 3 by 2的matrix, 如何0.5s内说出 2 是2行还是2列?</strong> 之前我是使用行列式这样的背住然后套的, 但是这里提供一种更加直觉的想法, 是, 我们定义这个名字的时候, 更加关注输出, 什么是输出, 变换后矩阵的维度, 那么变换后矩阵的维度是什么, 是由什么确定的, 这样想下去就是, 当然是  $A$ 这个提供变换的方案的matrix确定, 然后再想象一下, 这里的A的维度是什么, 是A的行数(row), 因为我们考虑的是A每一列vector的维度, 这样我们这个变化系统的row就确定了, 所以3 by 2的matrix的话, 3 $\rightarrow$  row, 所以是3 行 2 列的矩阵.</li>
</ol>

<p><strong>未完待续</strong></p>
<ol>
  <li>矩阵乘法的剩下三种理解方法</li>
  <li>变化的特色case, 为什么有些乘上有些矩阵的时候, 在一个维度上没有变动</li>
  <li>第二个问题在看3Blue1Brown发现他希望不动的x维度上, 对应的 A的位置, 好像都是单位矩阵的part, 虽然不知道再哪个位置(哪一层)放1</li>
  <li>之后要详细讨论的点是, 在3这个视频中, 所谓的 单个 $A$ 矩阵如果是变换作用的话, 居然直接是单位矩阵想要最后变成的固定状态(停在那个位置).</li>
  <li>左乘看成新坐标系的基向量，右边的原向量看成标量
    <h2 id="标准基底下的矢量">标准基底下的矢量</h2>
  </li>
</ol>

<svg width="400" height="400" viewBox="-100 -100 200 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 网格线 -->
  <g stroke="#ccc" stroke-width="0.5">
    <!-- 纵向 -->
    <line x1="-90" y1="-100" x2="-90" y2="100" />
    <line x1="-80" y1="-100" x2="-80" y2="100" />
    <line x1="-70" y1="-100" x2="-70" y2="100" />
    <line x1="-60" y1="-100" x2="-60" y2="100" />
    <line x1="-50" y1="-100" x2="-50" y2="100" />
    <line x1="-40" y1="-100" x2="-40" y2="100" />
    <line x1="-30" y1="-100" x2="-30" y2="100" />
    <line x1="-20" y1="-100" x2="-20" y2="100" />
    <line x1="-10" y1="-100" x2="-10" y2="100" />
    <line x1="10" y1="-100" x2="10" y2="100" />
    <line x1="20" y1="-100" x2="20" y2="100" />
    <line x1="30" y1="-100" x2="30" y2="100" />
    <line x1="40" y1="-100" x2="40" y2="100" />
    <line x1="50" y1="-100" x2="50" y2="100" />
    <line x1="60" y1="-100" x2="60" y2="100" />
    <line x1="70" y1="-100" x2="70" y2="100" />
    <line x1="80" y1="-100" x2="80" y2="100" />
    <line x1="90" y1="-100" x2="90" y2="100" />
    <!-- 横向 -->
    <line x1="-100" y1="-90" x2="100" y2="-90" />
    <line x1="-100" y1="-80" x2="100" y2="-80" />
    <line x1="-100" y1="-70" x2="100" y2="-70" />
    <line x1="-100" y1="-60" x2="100" y2="-60" />
    <line x1="-100" y1="-50" x2="100" y2="-50" />
    <line x1="-100" y1="-40" x2="100" y2="-40" />
    <line x1="-100" y1="-30" x2="100" y2="-30" />
    <line x1="-100" y1="-20" x2="100" y2="-20" />
    <line x1="-100" y1="-10" x2="100" y2="-10" />
    <line x1="-100" y1="10" x2="100" y2="10" />
    <line x1="-100" y1="20" x2="100" y2="20" />
    <line x1="-100" y1="30" x2="100" y2="30" />
    <line x1="-100" y1="40" x2="100" y2="40" />
    <line x1="-100" y1="50" x2="100" y2="50" />
    <line x1="-100" y1="60" x2="100" y2="60" />
    <line x1="-100" y1="70" x2="100" y2="70" />
    <line x1="-100" y1="80" x2="100" y2="80" />
    <line x1="-100" y1="90" x2="100" y2="90" />
  </g>

  <!-- 坐标轴 -->
  <line x1="-100" y1="0" x2="100" y2="0" stroke="black" stroke-width="1" />
  <line x1="0" y1="-100" x2="0" y2="100" stroke="black" stroke-width="1" />

  <!-- 标准基底 i -->
  <line x1="0" y1="0" x2="20" y2="0" stroke="green" stroke-width="2" marker-end="url(#arrow-green)" />
  <text x="22" y="0" fill="green" font-size="12">î (1,0)</text>

  <!-- 标准基底 j -->
  <line x1="0" y1="0" x2="0" y2="-20" stroke="red" stroke-width="2" marker-end="url(#arrow-red)" />
  <text x="2" y="-22" fill="red" font-size="12">ĵ (0,1)</text>

  <!-- 原始矢量 v = (1,2) -->
  <line x1="0" y1="0" x2="20" y2="-40" stroke="orange" stroke-width="2" marker-end="url(#arrow-orange)" />
  <text x="22" y="-42" fill="orange" font-size="12">v (1,2)</text>

  <!-- 箭头定义 -->
  <defs>
    <marker id="arrow-green" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="green" />
    </marker>
    <marker id="arrow-red" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="red" />
    </marker>
    <marker id="arrow-orange" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="orange" />
    </marker>
  </defs>
</svg>

<h2 id="变换基底后的矢量">变换基底后的矢量</h2>

<svg width="400" height="400" viewBox="-100 -100 200 200" xmlns="http://www.w3.org/2000/svg">
<!-- 网格线 -->
  <g stroke="#ccc" stroke-width="0.5">
    <!-- 纵向 -->
    <line x1="-90" y1="-100" x2="-90" y2="100" />
    <line x1="-80" y1="-100" x2="-80" y2="100" />
    <line x1="-70" y1="-100" x2="-70" y2="100" />
    <line x1="-60" y1="-100" x2="-60" y2="100" />
    <line x1="-50" y1="-100" x2="-50" y2="100" />
    <line x1="-40" y1="-100" x2="-40" y2="100" />
    <line x1="-30" y1="-100" x2="-30" y2="100" />
    <line x1="-20" y1="-100" x2="-20" y2="100" />
    <line x1="-10" y1="-100" x2="-10" y2="100" />
    <line x1="10" y1="-100" x2="10" y2="100" />
    <line x1="20" y1="-100" x2="20" y2="100" />
    <line x1="30" y1="-100" x2="30" y2="100" />
    <line x1="40" y1="-100" x2="40" y2="100" />
    <line x1="50" y1="-100" x2="50" y2="100" />
    <line x1="60" y1="-100" x2="60" y2="100" />
    <line x1="70" y1="-100" x2="70" y2="100" />
    <line x1="80" y1="-100" x2="80" y2="100" />
    <line x1="90" y1="-100" x2="90" y2="100" />
    <!-- 横向 -->
    <line x1="-100" y1="-90" x2="100" y2="-90" />
    <line x1="-100" y1="-80" x2="100" y2="-80" />
    <line x1="-100" y1="-70" x2="100" y2="-70" />
    <line x1="-100" y1="-60" x2="100" y2="-60" />
    <line x1="-100" y1="-50" x2="100" y2="-50" />
    <line x1="-100" y1="-40" x2="100" y2="-40" />
    <line x1="-100" y1="-30" x2="100" y2="-30" />
    <line x1="-100" y1="-20" x2="100" y2="-20" />
    <line x1="-100" y1="-10" x2="100" y2="-10" />
    <line x1="-100" y1="10" x2="100" y2="10" />
    <line x1="-100" y1="20" x2="100" y2="20" />
    <line x1="-100" y1="30" x2="100" y2="30" />
    <line x1="-100" y1="40" x2="100" y2="40" />
    <line x1="-100" y1="50" x2="100" y2="50" />
    <line x1="-100" y1="60" x2="100" y2="60" />
    <line x1="-100" y1="70" x2="100" y2="70" />
    <line x1="-100" y1="80" x2="100" y2="80" />
    <line x1="-100" y1="90" x2="100" y2="90" />
  </g>


  <!-- 坐标轴 -->
  <line x1="-100" y1="0" x2="100" y2="0" stroke="black" stroke-width="1" />
  <line x1="0" y1="-100" x2="0" y2="100" stroke="black" stroke-width="1" />

  <!-- 新基底 i -->
  <line x1="0" y1="0" x2="20" y2="0" stroke="green" stroke-width="2" marker-end="url(#arrow-green)" />
  <text x="22" y="0" fill="green" font-size="12">î' (1,0)</text>

  <!-- 新基底 j -->
  <line x1="0" y1="0" x2="20" y2="-20" stroke="red" stroke-width="2" marker-end="url(#arrow-red)" />
  <text x="22" y="-22" fill="red" font-size="12">ĵ' (1,1)</text>

  <!-- 变换后的矢量 v' = (3,2) -->
  <line x1="0" y1="0" x2="60" y2="-40" stroke="orange" stroke-width="2" marker-end="url(#arrow-orange)" />
  <text x="62" y="-42" fill="orange" font-size="12">v' (3,2)</text>

  <!-- 箭头定义 -->
  <defs>
    <marker id="arrow-green" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="green" />
    </marker>
    <marker id="arrow-red" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="red" />
    </marker>
    <marker id="arrow-orange" markerWidth="4" markerHeight="4" refX="3" refY="2" orient="auto">
      <path d="M0,0 L4,2 L0,4 Z" fill="orange" />
    </marker>
  </defs>
</svg>

<ol>
  <li>还有细节是对于提供变化的matrix $\begin{bmatrix} -1 &amp; 4 \ 1 &amp; 2 \end{bmatrix}$ , 我们可以直接认为其中$\begin{bmatrix} -1  \ 1  \end{bmatrix}$ 就是 unit vector $i$ 的新位置, 而$\begin{bmatrix} 4 \2 \end{bmatrix}$ 就是 unit vector $j$ 的新位置</li>
</ol>

<h3 id="-chapter-4-essence-of-linear-algebra-chapter-5-说了一下三维-没讲什么">#  Chapter 4, Essence of linear algebra, Chapter 5 说了一下三维, 没讲什么</h3>
<p>章节中对于$x$ 多维过程计算一个batch的过程, 其实就是拆开一步步的过程</p>

<p>$$ \begin{align*}
&amp;\underset{M_2}{\begin{bmatrix} \textcolor{purple}0 &amp; \textcolor{purple}2 \ \textcolor{purple}1 &amp; \textcolor{purple}0 \end{bmatrix}} 
\cdot 
\underset{M_1}{\begin{bmatrix} 
\color{green}{1} &amp; \color{orange}{-2} \ 
\color{green}{1} &amp; \color{orange}{0} 
\end{bmatrix}} 
= 
\begin{bmatrix} 
? &amp; ? \ 
? &amp; ? 
\end{bmatrix} 
\[10pt]</p>

<p>&amp;\begin{bmatrix} 
\textcolor{purple}0 &amp; \textcolor{purple}2 \ 
\textcolor{purple}1 &amp; \textcolor{purple}0 
\end{bmatrix} 
\cdot 
\begin{bmatrix} 
\color{green}{1}\ 
\color{green}{1}
\end{bmatrix} 
= \textcolor{green}{1} \cdot \begin{bmatrix} 
\textcolor{purple}0 \ 
\textcolor{purple}1
\end{bmatrix}</p>
<ul>
  <li>\textcolor{green}{1} \cdot 
\begin{bmatrix} 
\textcolor{purple}2 \ 
\textcolor{purple}0 
\end{bmatrix} 
= 
\begin{bmatrix} 
2 \ 
1 
\end{bmatrix}
\end{align<em>}
\(我们得出 $\rightarrow$\)
\begin{align</em>}
&amp;\underset{M_2}{\begin{bmatrix} \textcolor{purple}0 &amp; \textcolor{purple}2 \ \textcolor{purple}1 &amp; \textcolor{purple}0 \end{bmatrix}} 
\cdot 
\underset{M_1}{\begin{bmatrix} 
\color{green}{1} &amp; \color{orange}{-2} \ 
\color{green}{1} &amp; \color{orange}{0} 
\end{bmatrix}} 
= 
\begin{bmatrix} 
2 &amp; ? \ 
1 &amp; ? 
\end{bmatrix} 
\[10pt]
\end{align*}</li>
</ul>

<p>$$
这里其实有一个小疑惑, 就是$ABCDEF \cdot x$ 中, 第一个$F$, 对于 $x$ 的坐标映射, 是不是就是遵循$F$ 中的样子来就可以了, 但是对于剩下的步骤, 因为大概率不orthogonal, 所以其实多维的都有影响?</p>

<h3 id="1-矩阵乘法的剩下三种理解方法">1. 矩阵乘法的剩下三种理解方法</h3>

<p>图设计来自<a href="https://www.zhihu.com/people/gwave-22">gwave</a> 知乎答主, 使用svg重新绘制, 突出版权, 在重制中仍然保留水印.</p>

<p><strong>矩阵-向量乘法-列视角：矩阵右乘列向量，向量对矩阵的列进行线性组合</strong></p>
<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg">
  <!-- 3x3 矩阵列块 -->
  <!-- 红列 -->
  <rect x="10" y="50" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="10" y="80" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="10" y="110" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- 绿列 -->
  <rect x="40" y="50" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="40" y="80" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="40" y="110" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- 蓝列 -->
  <rect x="70" y="50" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="70" y="80" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="70" y="110" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 乘号 × -->
  <text x="110" y="105" font-size="24" font-family="Arial">×</text>
  
  <!-- 列向量 a b c -->
  <rect x="140" y="50" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="70" font-size="16" font-family="Arial">a</text>
  <rect x="140" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="100" font-size="16" font-family="Arial">b</text>
  <rect x="140" y="110" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="150" y="130" font-size="16" font-family="Arial">c</text>
  
  <!-- 等号 -->
  <text x="180" y="105" font-size="24" font-family="Arial">=</text>
  
  <!-- a * 红列 -->
  <rect x="230" y="50" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="230" y="80" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="230" y="110" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- a 方块在左侧，不覆盖 -->
  <rect x="200" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="210" y="100" font-size="16" font-family="Arial">a</text>
  
  <!-- 加号 -->
  <text x="270" y="105" font-size="24" font-family="Arial">+</text>
  
  <!-- b * 绿列 -->
  <rect x="320" y="50" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="320" y="80" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="320" y="110" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- b 方块在左侧，不覆盖 -->
  <rect x="290" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="300" y="100" font-size="16" font-family="Arial">b</text>
  
  <!-- 加号 -->
  <text x="360" y="105" font-size="24" font-family="Arial">+</text>
  
  <!-- c * 蓝列 -->
  <rect x="410" y="50" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="410" y="80" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="410" y="110" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <!-- c 方块在左侧，不覆盖 -->
  <rect x="380" y="80" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="390" y="100" font-size="16" font-family="Arial">c</text>
  
  <!-- 等号 -->
  <text x="450" y="105" font-size="24" font-family="Arial">=</text>
  
  <!-- 最终结果 粉灰色条 -->
  <rect x="480" y="50" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="480" y="80" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="480" y="110" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  
  <!-- 右下角水印 -->
  <text x="420" y="170" font-size="14" fill="#666">知乎 @waywa</text>
</svg>
<p><strong>矩阵-向量乘法-行视角：矩阵左乘行向量，向量对矩阵的行进行线性组合</strong></p>
<svg viewBox="0 0 700 230" xmlns="http://www.w3.org/2000/svg">
  <!-- 左侧 行向量 a b c -->
  <rect x="20" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="30" y="120" font-size="16" font-family="Arial">a</text>
  <rect x="50" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="60" y="120" font-size="16" font-family="Arial">b</text>
  <rect x="80" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="90" y="120" font-size="16" font-family="Arial">c</text>
  
  <!-- 乘号 × - 与第一个图保持一致的大小 -->
  <text x="125" y="125" font-size="24" font-family="Arial">×</text>
  
  <!-- 3x3 矩阵列块 -->
  <!-- 红行 -->
  <rect x="160" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="190" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="220" y="70" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <!-- 绿行 -->
  <rect x="160" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="190" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="220" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <!-- 蓝行 -->
  <rect x="160" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="190" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="220" y="130" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 等号 - 与第一个图保持一致的大小 -->
  <text x="290" y="125" font-size="24" font-family="Arial">=</text>
  
  <!-- 右侧计算过程 -->
  <!-- a * 红行 -->
  <rect x="340" y="40" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="60" font-size="16" font-family="Arial">a</text>
  <rect x="370" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="400" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  <rect x="430" y="40" width="30" height="30" fill="#e57373" stroke="black" stroke-width="1" />
  
  <!-- 加号（a和b之间） - 保持一致大小 -->
  <text x="380" y="95" font-size="24" font-family="Arial">+</text>
  
  <!-- b * 绿行 -->
  <rect x="340" y="100" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="120" font-size="16" font-family="Arial">b</text>
  <rect x="370" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="400" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  <rect x="430" y="100" width="30" height="30" fill="#81c784" stroke="black" stroke-width="1" />
  
  <!-- 加号（b和c之间） - 保持一致大小 -->
  <text x="380" y="155" font-size="24" font-family="Arial">+</text>
  
  <!-- c * 蓝行 -->
  <rect x="340" y="160" width="30" height="30" fill="white" stroke="black" stroke-width="1" />
  <text x="350" y="180" font-size="16" font-family="Arial">c</text>
  <rect x="370" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="400" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  <rect x="430" y="160" width="30" height="30" fill="#64b5f6" stroke="black" stroke-width="1" />
  
  <!-- 最后等号 - 保持一致大小 -->
  <text x="480" y="125" font-size="24" font-family="Arial">=</text>
  
  <!-- 最终结果 粉色行 -->
  <rect x="520" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="550" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  <rect x="580" y="100" width="30" height="30" fill="#f8bbd0" stroke="black" stroke-width="1" />
  
  <!-- 右下角水印 -->
  <text x="520" y="210" font-size="14" fill="#666">知乎 @waywa</text>
</svg>
<p>还没理解完, 未完待续</p>

<h2 id="rrefreduced-row-echelon-form">RREF(Reduced Row-Echelon Form)</h2>

<p>感觉是一个很小的概念不在ML中常用到, 
意思是“是不是高斯消元法最后让每个基向量尽可能简单”，那可以说是的。每一行代表一个单位基方向，其他方向全0, 可以理解成“最小单位向量”，但其实数学上是标准基, 但是注意，它们不一定是整个空间的 unit vector，而是 <strong>在矩阵的列空间或行空间中</strong>形成了一个基底。</p>

<p>彼此线性无关，数量就是行空间的维度，也就是矩阵的秩。
列空间的秩=行空间的秩, 这个概念好像是<strong>有点背的</strong>, 还有下面这个公式
\(rank(A)=rank(A^\top)\)
秩，GPT说其实代表这个系统“真正有多复杂”，而不是表面的行和列数量。</p>

<p><strong>Reference</strong></p>

<p>矩阵乘法核心思想（2）：行空间 - <em>gwave</em> 知乎 https://zhuanlan.zhihu.com/p/348551903
Essence of linear algebra <em>3Blue1Brown</em>  https://youtu.be/fNk_zzaMoSs?si=UlVZ_LHcoih4kQvu
NTU 线性代数 Hung-yi Lee (李宏毅) https://googly-mingto.github.io/LA_2022_fall/2022-fall.html
MIT18.06 Linear-Algebra  https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[好像写成一个的线代的内容了, 有很多未完待续的内容]]></summary></entry><entry><title type="html">Thinking and Re-thinking of Learning and Happiness</title><link href="http://localhost:4000/learning/" rel="alternate" type="text/html" title="Thinking and Re-thinking of Learning and Happiness" /><published>2025-04-22T00:00:00+08:00</published><updated>2025-04-22T00:00:00+08:00</updated><id>http://localhost:4000/%C2%A0learning</id><content type="html" xml:base="http://localhost:4000/learning/"><![CDATA[<p><strong><font color="red">Using LLMs to refine context through chaotic thinking, but I think GPT-4.5 (2025-04-22) is quite good.</font></strong></p>

<p>下面的内容是我胡乱打的, 也就是说想到什么写什么说什么, 但是大概follow了我在想一些事情时候的本意.</p>

<blockquote>
  <p>感觉学习递归的过程, 认为让我理解了学习为什么困难or为什么成绩不好什么的. 一个本质的问题是, 你是否认为一个人可以学会任何东西. 相信大脑的能力,相信神经. 我相信这一点, 不过在学习时间够长的情况下. 为什么在一个阶段学不懂, 我认为是之前其实有东西没学懂.  基础出现问题. (补充) 但是可能硬件不同, or正常理解框架下的智商, 我感觉是大脑全链路激活层的学习速度, 我觉得学习速度应该是真有快慢的, 这是事实. 有些人, 有些快, 在比较心理, 认为自己的不行的暗示下, 距离就逐渐拉开了. 知识没有被分成足够小的chuck.</p>

  <p>学习的目的非常重要, 我认为需要正反馈. 不可以骗自己, 可以骗一个月, 不可能骗10年, follow自己的内心, 非常重要. 感觉这也是另外一种版本的价值回归.</p>

  <p>回到递归, 做递归, 最忌讳的就是思考递归的细节, 但是学习为什么感觉都是一个逆过程, 追求成绩, 违反本身的追求真理的逻辑, 学习过程的正反馈是, 在相同时间内学的比别人快, 学的比别人多, 而不是增加探究世界现象的手段, 当然痛苦.</p>

  <p>我感觉学习, 读书, 好像在不断获得和学习认识这个时间的工具, 就像一个天生近视800度的人, 可以逐渐看清越来越远的东西, 像镜头的景深越来越深, 这个过程当然是快乐的, 而且是逐步快乐的, 这个时候检测 考试, 好像就是解读一些观察时候的corner case. 但是push的手段却是比较时间断内, 谁看到的世界比较大, 谁获得的知识比较多, 奇怪, 不过如果检测集足够大, 确实可以筛选出来那些本身获得正反馈的, 和本身速度就比较快的人…</p>
</blockquote>

<p>使用的简单prompt是,<code class="language-plaintext highlighter-rouge"> 这个是一个混乱的思路文稿,{上面的文本内容},解读,组织成一个结果完整的文章 </code></p>

<h1 id="claude-37">claude 3.7</h1>

<blockquote>
  <h1 id="递归学习与思维过程的反思">递归学习与思维过程的反思</h1>

  <p>您分享的文稿表达了对学习过程、特别是递归思维的一些深刻反思。我将整理您的想法，并从编程与学习思维的角度进行解构分析。</p>

  <h2 id="递归思维的本质与编程应用">递归思维的本质与编程应用</h2>

  <p>在编写代码时，尤其是面对递归问题时，人脑应该关注的核心不是递归的具体执行细节，而是问题的整体结构和解决方案的框架。这与您所说的”最忌讳的就是思考递归的细节”相呼应。</p>

  <p>在编程思维过程中，我们应该关注：</p>

  <ol>
    <li><strong>问题分解</strong> - 将复杂问题拆解为更小、更易管理的子问题</li>
    <li><strong>模式识别</strong> - 发现问题中的重复模式，这是递归的基础</li>
    <li><strong>边界条件</strong> - 明确递归的终止条件，防止无限循环</li>
    <li><strong>信任抽象</strong> - 相信子问题的解决方案，而不陷入执行细节</li>
  </ol>

  <h2 id="编码思维流程">编码思维流程</h2>

  <p>当我们编写递归代码时，思维流程通常是：</p>

  <ol>
    <li>首先识别问题是否适合递归解决（是否有重复的子问题结构）</li>
    <li>定义基本情况（边界条件）- 递归必须有终止点</li>
    <li>设计递归关系 - 如何将大问题分解为同类型的小问题</li>
    <li>实现递归逻辑，相信递归会正确处理子问题</li>
    <li>验证解决方案，检查边界情况</li>
  </ol>

  <p>这个过程与您提到的”学习的逆过程”有相似之处。递归编程要求我们相信函数能够完成其承诺，而不是纠结于每一层的执行细节。</p>

  <h2 id="学习过程的启示">学习过程的启示</h2>

  <p>您的文稿中提到了几个关于学习的重要观点：</p>

  <ol>
    <li><strong>学习基础的重要性</strong> - “在学习时间够长的情况下，为什么在一个阶段学不懂，我认为是之前其实有东西没学懂，基础出现问题”</li>
    <li><strong>内在动机与正反馈</strong> - “学习的目的非常重要，我认为需要正反馈”</li>
    <li><strong>知识分块</strong> - “知识没有被分成足够小的chuck”</li>
  </ol>

  <p>这些观点与有效的编程学习特别相关。编程学习也需要将复杂概念分解为可管理的小块，建立在坚实的基础上，并通过解决问题获得正反馈。</p>

  <h2 id="编程与学习的哲学联系">编程与学习的哲学联系</h2>

  <p>编写代码，尤其是递归代码，可以视为一种认知训练，它培养了以下思维能力：</p>

  <ol>
    <li><strong>抽象思维</strong> - 看到问题的本质而非表面细节</li>
    <li><strong>系统思考</strong> - 理解部分与整体的关系</li>
    <li><strong>信任机制</strong> - 相信系统各部分能够协同工作</li>
  </ol>

  <p>这与您描述的学习过程相似：”学习，读书，好像在不断获得和学习认识这个时间的工具，就像一个天生近视800度的人，可以逐渐看清越来越远的东西，像镜头的景深越来越深”。</p>

  <h2 id="实践建议">实践建议</h2>

  <p>在面对递归等复杂编程概念时：</p>

  <ol>
    <li>先理解问题的整体结构，而非实现细节</li>
    <li>确定最简单情况的解决方案（基本情况）</li>
    <li>设计递归关系，而不是试图在脑中跟踪整个执行过程</li>
    <li>编写代码时关注逻辑结构，而非执行顺序</li>
    <li>通过测试简单情况验证代码，建立对解决方案的信心</li>
  </ol>

  <p>这种方法类似于您所提倡的学习方式：关注整体理解，而非机械记忆；追求内在价值，而非外部评判；将复杂问题分解为可管理的部分。</p>

  <p>通过这种方式，编程不仅是一种技能获取，更是一种思维培养，帮助我们”看清越来越远的东西”，扩展我们认知的”景深”。</p>
</blockquote>

<h1 id="deepseek---r1">deepseek - R1</h1>

<blockquote>
  <h2 id="递归思维与学习困境一场关于认知本质的思辨">递归思维与学习困境：一场关于认知本质的思辨</h2>

  <p>在计算机科学的递归算法里，程序员最忌惮陷入函数调用的细节迷宫。这个编程隐喻恰如其分地揭示了人类认知的深层困境——当我们面对知识体系的建构时，常常迷失在表层现象的追逐中，却遗忘了思维递归的本质特征：每个层次的突破都建立在坚实基础之上。</p>

  <h3 id="一知识大厦的地基危机">一、知识大厦的地基危机</h3>

  <p>现代教育体系如同加速运转的传送带，将标准化知识模块源源不断地输送给学习者。在这个过程中，多数人陷入”知识假性完整”的认知陷阱：微积分公式的机械套用掩盖了极限概念的模糊，编程语法的熟练操作遮蔽了算法思维的缺失。这种基础性认知漏洞如同建筑地基的裂缝，在知识体系不断叠加的过程中产生级联效应，最终导致整个认知结构的崩塌。</p>

  <p>认知神经科学的最新研究证实，大脑新皮层的神经可塑性并非均匀分布。前额叶皮层与海马体构成的记忆环路，其信息处理效率直接影响知识模块的整合质量。当基础概念网络存在结构缺陷时，高阶认知功能的神经表征将出现拓扑紊乱，这正是”阶段式学习困境”的神经生物学基础。</p>

  <h3 id="二认知时钟的速率谜题">二、认知时钟的速率谜题</h3>

  <p>在慕尼黑大学的天才追踪研究中，发现顶尖学者的大脑白质纤维束呈现出独特的拓扑结构。这些增强的神经连接通道，使得他们的信息处理速度比常人快3-5个数量级。这种硬件差异如同CPU的时钟频率，决定了知识编译的基本速率。但神经可塑性研究同样表明，持续的正向刺激能使大脑胼胝体的髓鞘厚度每年增加0.5-1%，这意味着学习速度本身具有可塑性。</p>

  <p>教育评估体系制造的比较陷阱，本质上是将马拉松改造成百米冲刺的竞技场。当知识检测简化为碎片信息的提取速度测试，真正的认知深度反而被排除在评价体系之外。这种异化机制催生出大批”解题运动员”，他们熟练操作知识符号却丧失了概念建构能力。</p>

  <h3 id="三认知觉醒的正向递归">三、认知觉醒的正向递归</h3>

  <p>真正的学习革命始于元认知的觉醒。当学习者将注意力从外部评价转向内在建构，知识获取就转化为持续的正反馈循环。这个过程遵循着严格的递归逻辑：每个新概念必须完全内化为认知基元，才能支撑更高层级的思维跃迁。MIT媒体实验室的认知增强实验证明，采用这种递归学习法的被试者，其知识留存率是传统学习者的4.7倍。</p>

  <p>建立认知增强系统需要重构学习范式：将知识体系分解为原子化概念单元，通过间隔重复形成稳定的神经突触连接；构建概念之间的多维联结，形成抗干扰的认知拓扑网络；最终在问题求解中实现知识的创造性重组。这个过程如同3D打印认知结构，逐层构建却始终保持整体一致性。</p>

  <p>站在认知革命的门槛上，我们需要重新理解学习的本质。知识获取不是信息的简单堆砌，而是认知结构的递归升级。当我们将每个知识节点都锻造成坚实的认知基元，就能在思维空间实现真正的维度跃迁。这种递归式认知进化，终将带领我们突破智能边界，见证思维宇宙的奇点时刻。</p>
</blockquote>

<h1 id="gpt---45">GPT - 4.5</h1>

<blockquote>
  <p>学习递归的过程让我意识到为什么学习对很多人来说如此困难，也让我进一步理解了成绩表现不佳背后的原因。</p>

  <p>首先，我们必须承认一个基本问题：人类是否能够学习任何内容？我个人相信大脑具备这样的能力，相信神经网络能够通过不断训练和刺激逐渐掌握知识。然而，即便学习时间充足，某些阶段的知识却依然难以理解，这背后往往是因为之前的基础知识并没有真正掌握透彻。</p>

  <p>然而，这里还存在另一个重要因素：硬件的不同，或者我们常规理解中的智力差异。每个人大脑中神经元连接的效率，即所谓的“全链路激活层”，确实存在差别。这导致了不同人的学习速度存在客观上的差异。这种差异本身是真实存在的事实。有些人学得更快，有些人则相对慢一些。当人们开始将自己与他人比较，并暗示自己能力不足时，这种差距便会逐渐扩大。此外，知识没有被分解成足够小的知识单元（chunks），也进一步加剧了学习困难。</p>

  <p>明确学习的目的至关重要。我认为最重要的是持续的正反馈。一个人可能短暂地欺骗自己一段时间，比如一个月，但绝不可能持续地自欺欺人十年之久。因此，诚实地追随内心真正的兴趣与价值观尤为重要。这实际上也是一种价值回归——回归到学习本质的乐趣与探索。</p>

  <p>以递归为例，递归最大的忌讳便是陷入细节，却忽略整体思维。可是现实的学习过程却经常与这种理念背道而驰。追求分数和表面成绩的过程中，往往偏离了对真理与知识本身的追求。真正的正反馈应该来源于自己对世界现象的深入探索和理解，而不是在相同时间内比别人学得更多或更快。然而，现行的学习模式与评估机制却经常以知识量和学习速度为衡量标准，这自然带来学习的痛苦与焦虑。</p>

  <p>我感觉学习的过程，就像不断地获得观察世界的工具。就好像一个天生视力不足、近视800度的人，通过不断调整镜片逐渐看清更远处的风景，视野变得越来越清晰，景深也逐渐增加。这种逐步清晰的过程本应是快乐且满足的。而考试或者测试，就像是观察世界中的一些特殊案例（corner cases），本质上是一种检验我们观察能力的方式。</p>

  <p>但令人奇怪的是，我们往往用一种截然相反的标准去评价——在特定的时间段内，谁观察得更多，掌握的知识更广。这种评价方法尽管表面上合理，但实际上却忽略了真正重要的事情：人们学习过程中自发的正反馈和内在的学习速度。不过如果评估的范围和规模足够大，确实能够从中挑选出那些本身就能获得正反馈、学习速度较快的人。</p>

  <p>最终，学习不应只是一场速度与数量的竞争，而更应该是一场逐渐拓宽视野、深入理解世界的旅程。理解并尊重学习的本质，才能真正享受学习的快乐与成长。</p>
</blockquote>

<h1 id="2025-04-27">2025-04-27</h1>

<p>好像也解决了那个所谓买菜为什么要数学的问题, 如果对探知的要求只有百元以内的菜价, 那么好像确实没有持续学习的必要了. 再引申开来一点的话, 如果课本里的知识没有在帮助解决现实中的问题，只提供难和奇怪的过程, 就很容易让人觉得它们抽象且难以消化。而且，我认为一部分学习带来的成就感来源于和他人的比较，一旦身边的同路人越来越少，或者遇到天赋更高的人，这种动力就会逐渐消失. 所以我感觉做事的时候更应该想清楚目的.</p>

<p>一点粗浅的感想罢了.</p>

<p>And我现在感觉读书还挺有趣的.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[Using LLMs to refine context through chaotic thinking, but I think GPT-4.5 (2025-04-22) is quite good.]]></summary></entry><entry><title type="html">Recursive problem and Thinking Process</title><link href="http://localhost:4000/recursive-problem/" rel="alternate" type="text/html" title="Recursive problem and Thinking Process" /><published>2025-04-22T00:00:00+08:00</published><updated>2025-04-22T00:00:00+08:00</updated><id>http://localhost:4000/recursive%20problem</id><content type="html" xml:base="http://localhost:4000/recursive-problem/"><![CDATA[<p>The article contains mistakes and misunderstandings, as it is a record of my own incorrect notes rather than a proper summary document.</p>

<h1 id="first-module-1---arrays-arraylists-recursion">First Module 1 - Arrays, ArrayLists, Recursion</h1>

<p>Given this recursive method and an input of n = 7, what will the output be? Please enter your answer as a Comma Separated List (e.g 1, 2, 3, 4)</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">public</span> <span class="n">void</span> <span class="n">recursiveMethod</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>  
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>  
        <span class="k">return</span><span class="p">;</span>  
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>  
        <span class="n">recursiveMethod</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>  
        <span class="n">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>  
    <span class="p">}</span>  
<span class="p">}</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Your</span> <span class="n">Answer</span><span class="p">:</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Correct</span> <span class="n">Answer</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span>  
</code></pre></div></div>

<p>The answer relies on a recognition that the output will come before the recursive call, and that the output after all recursive calls are made will output from smallest to largest instead of largest to smallest</p>

<h1 id="then-a-cmu-web-towers-of-hanoi">Then a CMU web, Towers of Hanoi</h1>

<p>In this puzzle, we have three pegs and several disks, initially stacked from largest to smallest on the left peg. (See the 6-disk picture below.) The rules are simple:</p>

<ol>
  <li>Our goal is to move the entire tower to the middle peg.</li>
  <li>We can only move one disk at a time.</li>
  <li>We can never place a larger disk on a smaller one.</li>
</ol>

<p><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk0.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk1.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk2.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk3.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk4.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/disk5.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/empty.gif" alt="" /><br />
<img src="https://www.cs.cmu.edu/~cburch/survey/recurse/basea.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/baseb.gif" alt="" /><img src="https://www.cs.cmu.edu/~cburch/survey/recurse/basec.gif" alt="" /></p>

<p>If JavaScript 1.2 is enabled on your browser, you can try it yourself. Just click on the disk you want to move, and then click on the peg you want to put it at. Although technically you are only allowed to move one disk at a time, the program will move several disks if it is necessary to complete the move.</p>

<p>We’ll answer both of these questions in sequence.</p>

<p>To describe how the monks should solve this puzzle, the concept of recursion will be useful. We look at that next.</p>

<p>Next: <a href="https://www.cs.cmu.edu/~cburch/survey/recurse/recursion.html">Recursion</a>.</p>

<h1 id="then-a-simple-leetcode-q-104-maximum-depth-of-binary-tree">Then a simple leetcode Q <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></h1>

<p><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a> eng ver</p>

<p>But most people did like this, correct, but…, not friendly for me at first</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">),</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">))</span>        
</code></pre></div></div>

<h1 id="then-two-prob">Then two prob</h1>

<h3 id="reverse-linked-list">Reverse Linked List</h3>
<p>https://neetcode.io/problems/reverse-a-linked-list
Not the normal Iteration</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reverseList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ListNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">head</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">head</span>
       	<span class="c1"># weird place
</span>        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">reverseList</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>
        
        <span class="n">head</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">head</span>
        <span class="n">head</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">node</span>
</code></pre></div></div>

<p>And <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a> again , simple question again
I think it is a good way to understand?</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
</span>
<span class="c1"># class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">maxDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

        <span class="c1"># I'm starting from the root node now
</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  <span class="c1"># if there is no root, there is no root node at all, so I should return the value 0
</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># OK, the logic now is that there is at least one root node. Now, based on the logic of the recursive function,
</span>
        <span class="c1"># we can know the depth of the left and right nodes starting from the root
</span>
        <span class="c1"># which is
</span>
        <span class="n">left_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>

        <span class="n">right_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># OK, now, we start to think, we have the depth of the root nodes root.left and root.right, now we want to add
</span>
        <span class="c1"># the depth of the root layer itself, so we need to add 1. At the same time, we want the maximum depth, so we have the max function
</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

</code></pre></div></div>

<h1 id="right-now-the-problems-are">Right now, the problems are</h1>
<ol>
  <li>Reinforce point</li>
  <li>Return type, and helper method (create a new helper method)</li>
</ol>

<h1 id="a-simple-leetcode-q">A simple Leetcode Q,</h1>
<p>The thinking flow of recursive Q in BST
<a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. Merge Two Binary Trees</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root1</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
            <span class="c1"># if two entering roots are None, direct return one of trees, 
</span>            <span class="c1"># return node2 # ? wired, wanna change [root1s] val, but it return a value, 
</span>
            <span class="k">if</span> <span class="n">node1</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">node2</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> 
            
            <span class="k">if</span> <span class="n">node1</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">node2</span><span class="p">.</span><span class="n">val</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node2</span><span class="p">:</span>
                <span class="k">return</span> 
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="n">node1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">TreeNode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">node2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">merge</span><span class="p">(</span><span class="n">node1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">node2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            
        <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">root1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">mergeTrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">root2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>

        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">):</span> <span class="c1"># -&gt; treeNode
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="n">root1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root2</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">root2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">root1</span>
            <span class="c1"># if root1 and root2 # adding value logic
</span>            
            <span class="n">root1</span><span class="p">.</span><span class="n">val</span> <span class="o">+=</span> <span class="n">root2</span><span class="p">.</span><span class="n">val</span>
            <span class="n">root1</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">root2</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">root1</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">root2</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">root1</span>
        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">root1</span><span class="p">,</span><span class="n">root2</span><span class="p">)</span>
        
</code></pre></div></div>
<h1 id="leetcode-450">Leetcode 450</h1>
<p><a href="https://leetcode.com/problems/delete-node-in-a-bst/">450. Delete Node in a BST</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
</span><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TreeNode</span><span class="p">]:</span>

        <span class="k">def</span> <span class="nf">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="n">val</span><span class="p">):</span> <span class="c1"># Unsure of the return type, changing the tree structure, so should the return type be treeNode?
</span>
        <span class="c1"># Or do I only need a single return, because I'm only changing the tree structure?  Confused
</span>
            <span class="c1"># no root , return None
</span>            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Confused here. The question says if found, delete it; if not found, return None or the original?
</span>
                <span class="c1"># I don't know whether to write return or return None, I can't convince myself.
</span>
            
            <span class="c1"># if node: ... so right now this place has a node, first one is root
</span>            <span class="c1"># from root perspective
</span>            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
                <span class="c1"># using successor, that is the minimum value of the right subtree.
</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">successorHelp</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                
                <span class="c1"># Oh, it can be using if statment here.
</span>                <span class="c1"># if node.right and not not node.left ....
</span>

            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span> <span class="c1"># node.left
</span>                <span class="n">temp</span> <span class="o">=</span> <span class="n">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">temp</span> <span class="c1">#?
</span>            <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">dfsFinder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span><span class="n">val</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">successorHelp</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="c1"># When calling itself, the input cannot be None, but I think it's okay to check?
</span>
			<span class="c1"># Wow, it seems that a check is necessary because of the recursive boundary problem, but can we directly check if it's a leaf node? No, what if there's only a left subtree and no right subtree?
</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span> <span class="c1"># I suddenly don't know what to return.  Returning None feels strange.
</span>
                
                <span class="c1"># It was written as None at the end, but after thinking about it, I don't think it will be called.
</span>
            <span class="c1"># .right once
</span>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
                
                <span class="c1"># delete that node
</span>                <span class="n">new_value</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">return</span> <span class="n">new_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            
            <span class="c1"># I think the above can be adjusted.  It's about `val` and an impossible `val`. If it's an impossible `val`, it means there's no right subtree starting from the node, so connect to the left subtree starting from the node, that is, `node = node.left`.
</span>
            
            
        
        
</code></pre></div></div>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[The article contains mistakes and misunderstandings, as it is a record of my own incorrect notes rather than a proper summary document.]]></summary></entry><entry><title type="html">2025-03-07-How I use LLMs by Andrej Karpathy 看后总结</title><link href="http://localhost:4000/How-I-use-LLMs-by-Andrej-Karpathy-%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93/" rel="alternate" type="text/html" title="2025-03-07-How I use LLMs by Andrej Karpathy 看后总结" /><published>2025-03-27T00:00:00+08:00</published><updated>2025-03-27T00:00:00+08:00</updated><id>http://localhost:4000/How%20I%20use%20LLMs%20by%20Andrej%20Karpathy%20%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/How-I-use-LLMs-by-Andrej-Karpathy-%E7%9C%8B%E5%90%8E%E6%80%BB%E7%BB%93/"><![CDATA[<p>https://www.youtube.com/watch?v=EWvNQjAaOHw</p>

<p>当然这个视频, 感觉是一个挺好的材料, 从一个很简单的角度切入, 快速判断什么任务可以实现
两个多小时的视频, 结果花了三天的时间还比较碎片的时间才看完, 之前通宵两天熬夜太狠了, 感觉看的时候一直没有很专注, 然后还没干什么事情, 笑死.
注: 
回到这个这个视频, 回顾的想, 这个视频的信息含量没有涉及什么复杂的步骤和内容, 更多的是一个科普向的视频, 或是一个操作演示一样. 当然打开之前我就知道, 干货应该不多, 肯定不如Let‘s build 那个系列, 我只是想比较一下我使用LLM和Andrej Karpathy使用LLM的区别. 接下来的步骤都是我看过之后一次性回忆的, order可能有问题, 然后一些sub subjects会有遗漏. 加上实在感觉我看完了不等于是会了, 我认为会了仍然还有大量可能的错误, 不如直接写下来. 相信即使是最简单的逻辑和常识也需要被整理. 花一点时间, 把要大量使用的工具理解清楚我觉得还是对我重要和有价值的.</p>

<h2 id="笼统介绍">笼统介绍</h2>

<p>一开始，Andrej Karpathy 提到，他几乎订阅了所有主流 LLM 模型的会员服务(2025 年 3 月) 接着，用了一个特别形象的比喻which is zip 文件，来形容大模型预训练后的状态。这个比喻很有意思，因为 zip 文件如果不解压，里面的内容是没法直接用的。换句话说，预训练后的模型并不像字典那样，能瞬间（O(1) 时间）找到你想要的东西, 所以模型不是pageRank那样的搜索? 
LLM good at writing. 然后，Karpathy 花了一些时间解释 token 的概念，简单了解一下非常有意义。
无论是文字、标点符号，还是输入输出，都会消耗 token。我们看到的是连贯的文章，但对模型来说，它处理的是一串 token。LLM 的输入是 token，输出也是 token，它的任务就是预测下一个可能的 token，一个接一个地生成文本。（这里我打个比方：假设人 A 对美国人 B 说中文，但 B 听不懂中文。于是，A 的中文被转换成了一串数字（比如 Unicode 编码），B 看到的是这串数字。虽然 B 不懂中文，但他已经通过学习知道这些数字之间的关系，通过不断的预测, 最后他也用一串数字来回应。最后，这串数字被解码成中文，A 听到了 B 的回复。）然后视频演示了下面这个开发者做的网站，它能展示输入输出时 token 的具体的展现：
https://tiktokenizer.vercel.app/</p>

<h2 id="继续讲了预训练和后训练">继续讲了预训练和后训练</h2>

<p>预训练很贵, 预训练使用大量的历史上的材料, 互联网上已经有的内容, 组成了一个由token之间的关系的size很大的zip文件. 但是这个zip文件是有损失和有概率 zip 文件. 是sequence of token.</p>

<p>后训练 much much cheaper. Using SFT（Supervised Fine-Tuning, 监督微调）、RLHF（Reinforcement Learning from Human Feedback, 人类反馈强化学习） 和 RL（Reinforcement Learning, 强化学习）on Conversations, 这里Andrej认为post train类似于角色扮演, 后训练的重点是调整模型的行为，而不是再教知识, 我感觉对于使用者来说了解到这里就OK了?
<strong>GPT讲,</strong> 换句话说，预训练教会了模型语言，而后训练教会了它如何像人一样“扮演”某种对话风格或人格。</p>
<h2 id="开始演示使用大模型">开始演示使用大模型</h2>
<p>展示了不同模型随便输入一个问题后, 显示了一些输出什么的. 这里我记得没什么好着重提及的, 可能Andrej使用了perplexity来使用deepseek的模型有点难评.</p>

<p>这里有一个细节, 我之前没有注意, 我之前以为perplexity这家公司没什么技术, 但是在演示中发现, perplexity搜索速度蛮快的, 这里有我不知道的点.</p>

<p>还有这里解释为什么会出现不正确输出的原因, 因为预测本身就不会是100%正确的, 很正常很自然. 
还讲了GPT模型不透明的情况, 比如虽然选了GPT-4o但是你怎么知道运行的是不是4o, 明确的提及了在用户没有登录的时候, GPT提供的是一个size非常小的模型.</p>
<h2 id="上下文搜索">上下文搜索</h2>
<p>现在的模型, 只要用过, 就会发现模型具有一定的上下文记忆能力，即它能够理解并引用同一对话中的先前输入和输出。此外，如果持续在同一对话中交流，token 消耗会非常快，这也意味着模型实际上是在不断地处理和整合之前的对话内容。每次新的输入都会与之前的输入输出结合.</p>

<p>看视频的时候直接跳过了, 但是这里有个疑问, 就是, 模型是怎么选择之前的记忆的呢? 首先这个window肯定有一个size, 如果已经输入的内容和输出的内容过长, 这个window肯定是装不下的, 但是抛弃之前的内容的策略是? 之前就知道会丢和能保存.</p>

<blockquote>
  <p><strong>问了GPT,</strong>  LLM 的上下文窗口(context window)是<strong>有限的</strong>，有一个固定的大小(如 4096、8192 或更大的 token 数), 当输入和输出的内容<strong>超出上下文窗口的容量</strong>时，模型必须决定如何<strong>舍弃部分旧内容</strong>。策略有, 滑动窗口（Sliding Window）, 基于重要性截取（Relevance-Based Pruning）, 层次化摘要（Hierarchical Summarization）, 基于提示（Prompt Engineering）</p>
</blockquote>

<p>OK, 策略这么多, 如何这里如何选择也是一个黑盒…</p>
<h2 id="不同模型的价格">不同模型的价格</h2>
<p>这里就是说一下不同模型的价格和提供的服务不同, 没有涉及到api.</p>

<h2 id="联网搜索--search">联网搜索 * Search</h2>
<p>为什么有联网搜索的功能? 本质上因为创建那个zip file的过程是一个由时间限制的东西, 决定使用23年4月为止的内容, 那么之后的内容当然涉及不到. 比如询问大模型一个今天的天气, 有点强模型所难了. 如果使用搜索改变了什么呢, 相当于爬虫爬取了网上搜索得到的内容, 作为输入, 那么这里有新的输入了, 这部分知识, 在输出回答的时候, 就可以回到诸如今天的天气和气温这类的问题.</p>

<h2 id="reasoning-model">Reasoning Model</h2>
<p>由GPT-o1开始, 强化学习来解决数学编码等逻辑问题, 这个思路被做出来了一个产品. 原理我不懂,  有空有必要了再学吧. 这里浅显的说法是, 对于数学推理、代码生成等任务，我们希望模型<strong>一步步地推理</strong>，而不是仅仅根据概率生成看起来正确的文本.</p>

<p>所以之前一个高中生的prompt让claude 3.5变reasoning model的新闻有点扯淡. 两个看似相似的输出, 输出的文本背后的逻辑都不一样.</p>
<h2 id="deepresearch">deepResearch</h2>
<p>有点感觉是一个set of reasoning model的组合, 忘了, 回去看的时候再补一下, 这里好像说到了现在grok和gpt都有这种能力, 挺有潜力的一个功能, 但是我目前没感觉特别厉害, 或者我没有使用场景. 我冲了20美元的GPT会员使用下来(可以用10次), 我用了两次, 我使用的情况是没跑出来什么特别有用的东西…</p>
<h2 id="llm-文件上传主要是pdf">LLM 文件上传(主要是pdf)</h2>
<p>这里在使用claude的时候, 提及了在pdf中的插图应该是不会被使用的. 识别的都是大量的文字, 应该也是类似于多模态调用OCR的能力? 虽然我事后搜索了一下Claude有识别读取pdf中图片的能力, 所以, 不知道是不是 Karpathy 讲错了还是在使用中没有发现对插图有识别和作为输入. 我在之前使用的时候没意识到这个细节, 但是我记得在只输入图片的情况下是可以识别的(which就是一张图中有示意图和文字解释或文字内容), 但是我记得之前输入一个graph, 让GPT判断后输出BFS或者DFS还是挺费劲的, 这里不知道是为什么. 感觉要了解图片是怎么被LLM读取的才可以搞明白.</p>

<p>这样就有一个疑问就是, 我希望LLM在处理图片输入的时候, 希望它在使用正确的信息, 这里在prompt的地方可以说一下, 提及一下就是, 让模型输出OCR后, 它看到了什么, 这样可以在输出OCR结果不对的情况下发现错误.</p>
<h2 id="code-interpreter容器-data-analy">Code interpreter(容器?) data analy</h2>
<p>LLM的代码能力非常好, 我猜测是因为代码有一条类似于flow的处理逻辑, 是不是非常容易被强化学习拟合啊? 就是, 输入的数据啊, 个数啊, 类型啊, 都是设计好的, hh无端猜测了. 
这里想到一个经典问题, 好像是9.9大还是9.11 大什么的,这里如果使用python解释器来输出结果应该是没问题的, 但是我记得有新闻是说, 这里GPT会比较的是圣经的章节, 所以 9section的第9 subsection当然小于9section的第11 subsection的, 这里想到这是一个简单的小计算过程, 如果在一个大型项目中, 使用LLM认为过于简单没有自动调用Code interpreter使用python输出来比较的话, 在这一步给出一个正确的答案会怎么办呢? 过程如果过于多, 还挺难定位这个问题的
在这里视频的最后写了一下直接使用GPT做data analysis其实网上有大量的资源, 不展开介绍.然后在演示的时候, GPT还出现了数据的错误. 我记得是一个最大值的数据点搞错了</p>
<h2 id="one-more-related-tool--claude-artifactsapps-diagrams">One more related tool , Claude Artifacts(apps, diagrams)</h2>

<p>这里Andrej Karpathy甚至生成了一个anki卡片的网页应用, 然后来检测从wiki上复制的亚当斯密的知识点, 神了, 反正我之前是没有这样使用过和没想过的. 有交互还有反馈.
然后在这个section, Karpathy介绍了一下用Claude生成mermaid流程图, 然后展示出来, 这个事情其实我在GPT3.5的时候就做过, 生成完code再粘贴到mermaid模拟器上, 在视频中看到Claude就是多了一个出完code的时候及时生成展示图片的功能, 好确实好, 但是没感觉多好,hhhhh, 可能就是有没有想到这样去用LLM来得到这个输出的区别. 我想想当时好像是软件工程的作业要画流程图, 我发现一个geek朋友非常喜欢用代码写那个软件的工程图, 我们大部分是用线上的画图软件自己画的, 我画了第一个图之后,感觉非常非常麻烦. 我没学过那个流程图的代码框架, 这时候想到why not 用GPT生成那个结构代码, 刚好typora也支持mermaid, 用代码写这种流程图完全不需要关注框图的间距, 箭头的粗细这种问题, 然后我就一直使用这样方法写这部分的任务. 后来的latex也是. 一次一次的任务然后习惯了使用md的语法, 最开始是发现gpt一直在使用这种格式的文本输出, 觉得挺轻便和美观的就在b站学了半小时之后写到了现在. 
这里我想到LLM直接跑D3.js还有Graphviz应该都蛮棒的
这里Andrej Karpathy的用法是, 使用mermaid梳理文本, 梳理人物关系网, 梳理故事发展过程, 这个用法我之前没想到过, 以后可以多加使用.</p>

<h2 id="我加的任务处理">(我加的)任务处理</h2>
<p>下次再说吧, 是Claude开发的一个工具.</p>
<h2 id="cursor">cursor</h2>
<p>之前看课代表立正的视频的时候, 里面一个视频讲, 对于自己的粉丝做了一个调查是, 认为过去一年ai没什么发展的和ai发展飞速的好像是一半一半, 但是认为过去一年ai发展快速的人中, 绝大部分的人是使用过cursor的, 
这里, 就是感觉, 虽然明面上说是整个文件都是一个上下文窗口中读入的, 但是项目一大, 应该仍然是会丢失的, 那么那些神奇的策略们的选择黑箱, 该如何选择, 这里的策略好像不可以被人为调控. 
Karpathy飞速的做了两个demo, 挺不错的. 有点神奇的是, 如果本地环境下, asset中没有一些文件, (视频中是一个点击的声音特效, 还是胜利音频特效来着), cursor居然会联网爬一个库下载下来, 我真是一脸正经, 之前一直以为是巧妇难为无米之炊的, 这还可以自己下一个文件过来? 但是转念一想, 好像这和运行一些项目要使用一些lib然后自动下了一些pip好像没什么不同, 然后又不觉得特别神奇了.</p>
<h2 id="使用声音输入--输出">使用声音输入 / 输出</h2>

<p>这里只是使用speech-to-text模型输入文本给GPT, 然后得到文本的返回, 没有使用下面的语音模型. 很多时候, 其实我们只需要一轮问答, 比如, 现在的Karpathy 在视频里面讲使用快捷键F5快速调用(类似于siri), 询问一个问题, 得到LLM的回复, Karpathy 说现在接近一半他都是在这个使用场景下使用的
我想了想, 确实比较方便, 打算下个礼拜在自己的电脑上整好这个操作.</p>
<h2 id="使用语音模型-伦理">使用语音模型, 伦理</h2>

<p>这里我记得使用grok可以沟通出一些怪怪的声音和对话内容, 是在使用GPT的语音对话无法实现的, 而且GPT语音还是拒绝回答一些类型的问题, “利用怪怪的声音快速说1-20”我记得视频里面好像说了这个例子.</p>
<h2 id="notebooklm">NotebookLM</h2>
<p>输入一些文件, pdf, 然后gemini出一个talk. 我之前有听说这个功能十分惊艳, 但是没引起重视, 或者觉得这个功能无法帮助到我. 
1, 是想不出这个功能的实用价值, 首先我不用播客类节目变现, 再是在油管和xhs加上一个B站这些视频流媒体平台提供给我的内容, 无论是否优质, 已经足够足够多了, 我现在的精力甚至是减弱这些平台给我的影响, 减少注意力分散, 我不应该去关注太多信息来源, 虽然很多优质的信息还是从这方面来的, 没办法无法隔离. 
2, OK回到这个NoteBook播客功能上, 还有一个原因就是语言(英语水平)还是存在问题, 虽然CS, 科技, 数码 or 摄影相关的英文内容我可以做到95%的时间follow上和听得懂, 但是非母语还是有问题就是, 感觉脑子在输入英语的时候有一层decoder一样, 还是要慢一些, 我脑子在输入英语的时候对专注要求更加高, 这样听这个英语博客还是挺累的, 中文还是我的舒适区无法改变了, 不然这篇文章我肯定是想用英文打出来的. 
OK, 所以这个应用就对我来说有点鸡肋, 我不需要使用这个function来获取信息, 加上流畅使用还是有语言门槛, 如果想快速了解某个领域的知识, 为什么不直接上网搜索一个general的介绍呢? 整10篇文章输入, 做一个博客有点奇怪. 或者说, 泛泛的去了解一个domain的知识这样做有点出力太多, 但是如果想认真学习一下, 这样做是远远不够的, 所以我困惑于对我自己的使用场景. 我感觉是不是deep research加上这个NotebookLLM podcast的功能是不是有使用价值一点, 其实我希望连选都不要选topic, 用一个推荐算法什么的, 网易云音乐式得生成高质量podcast如果有一个这样的产品我会愿意去用, 我连花时间喂Notebook的生成podcast的操作都懒.</p>

<p>然后Karpathy说, 整了一些podcast可以在开车路上听, 哈哈好吧, 碎片时间, 可惜我没有车.</p>

<h2 id="图片输入">图片输入</h2>
<ol>
  <li>
    <p>之前提到过, 图片输入往往有输入的错误, 这里Karpathy说他 使用方法是分成两步, 而不是直接让LLM输出结果, 比如使用prompt, <code class="language-plaintext highlighter-rouge">分成两步, 第一步输出OCR的输出结果, 第二步使用这些结果输出我想要的答案</code></p>
  </li>
  <li>
    <p>转成公式
simpleTex, Math Snipping Tool这种识别论文中的公式使用OCR的小而美的business应该都快寄了, 我真感觉用一个LLM的api再使用一个prompt做一个小应用就行, 用cursor做可能不用半小时.</p>
  </li>
</ol>

<p>突然有点好奇LLM的输入, 图片和文字的区别, 是直接图片使用分配给OCR的模型读取么</p>
<h2 id="chatgpt的个性化助手和应用市场-提示词">ChatGPT的个性化助手和应用市场, 提示词?</h2>
<p>这里涉及了好多Karpathy的个人信息啊哈哈哈哈, 看到网上的comment是他谈了一个韩国女友, 所以在各种姿势学习韩文. OK离开八卦的话是, LLM在翻译任务上简直是出人意料的好, 逻辑流畅舒适, 甚至可以输出一些引申的含义. 
还有我其实有个疑问是, 要不要使用xml类似的指令? 使用自然语言和xml语言有对文本读取来说有多大的差别, 如果有差别的话, 我自己感觉是各模型厂家在post train的时候调整的, 还有如果使用api去调用的话, 在code界面, 大家使用的都是xml的结构. 我自己感觉是有区别但是区别不大, 不然其中的一种方法会被大肆宣传的.
比如下面是我希望解释Leetcode问题时候的prompt</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;task&gt;</span>
编写一个解决这个问题的程序
<span class="nt">&lt;context&gt;</span>
我希望你像一个人类程序员一样思考这个问题。请展示完整的思考过程,包括:
- 初步理解问题时的想法
- 尝试解决时遇到的困惑
- 思路的演变和修正
- 为什么最终选择这个实现方案
<span class="nt">&lt;/context&gt;</span>

<span class="nt">&lt;format&gt;</span>
请用以下格式输出:
1. 初步分析
- 用简单的语言描述你对问题的第一理解
- 列出可能需要考虑的关键点

2. 解决方案构思
- 写下你能想到的几种方案
- 分析每种方案的优缺点
- 解释为什么选择或放弃某个方案

1. 代码实现
- 每写一个代码块前,先解释你准备做什么
- 用注释记录当时的思考
- 如果发现问题需要修改,说明原因
- 展示完整的思维过程,包括错误的尝试

2. 最终总结
- 回顾整个解决过程
- 指出关键的思考点
- 分享可能的改进方向

<span class="nt">&lt;style&gt;</span>
注释风格:
# 初步想法
# 发现问题
# 修正思路
# 实现原因
<span class="nt">&lt;/style&gt;</span>
</code></pre></div></div>

<p>另外一个疑问是在customize ChatGPT的时候 <code class="language-plaintext highlighter-rouge">What traits should ChatGPT have?</code> 和 <code class="language-plaintext highlighter-rouge">Anything else ChatGPT should know about you?</code> 在输入的时候到底有什么区别.</p>

<h2 id="演示了一些图片生成-视频生成">演示了一些图片生成, 视频生成</h2>

<p>Andrej Karpathy翻了一个twitter的po文, 我本人对这部分功能兴趣不大, 但是看的时候, Google 生成的视频非常真实, 感觉还挺厉害的.</p>

<h2 id="finally">Finally</h2>
<p>08-March-2025
本来想用20min写一点想法和总结就行, 但是居然写了快2个小时半才写了一半内容, 麻了, 太废了, 实在是太笨了, 效率太低了,打字速度也慢.  今天先不写了, 不然任务完不成了. 看了一眼左下角字数统计, 一边想, 一边整理两个小时写2100多字, 好像也不算是非常非常慢的整理速度, 好吧, 平衡了. 
09-March-2025
今天好像也是花了好久在写这个东西…</p>

<p>希望 llya 这位LLM真神可以在5年之内弄出一个更加逆天的模型.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[https://www.youtube.com/watch?v=EWvNQjAaOHw]]></summary></entry><entry><title type="html">Life goals before the age of 30 (in addition to finding a job)</title><link href="http://localhost:4000/Life-goals-at-30/" rel="alternate" type="text/html" title="Life goals before the age of 30 (in addition to finding a job)" /><published>2024-07-28T00:00:00+08:00</published><updated>2024-07-28T00:00:00+08:00</updated><id>http://localhost:4000/Life%20goals%20at%2030</id><content type="html" xml:base="http://localhost:4000/Life-goals-at-30/"><![CDATA[<p>:)</p>

<ol>
  <li>Suceived in GT in the QCF and CSE program(wanna dual degree)…</li>
  <li>Use the money which I earned to buy two leica cams (m1x, mp)</li>
  <li>Be proficient in using a sewing machine to make small bags and edc backpack design under your own understanding (difficult)</li>
  <li>Japanese level is equivalent to IELTS 5.5 in Eng(I think it is enough), and I can communicate with native jp people.  (difficult)</li>
  <li>Reasonable understanding of the process, materials, steps, installation and design of house decoration</li>
  <li>launched two self-developed independent apps, iOS / web OS</li>
</ol>

<p>时间很长却也很快.</p>

<p>感觉人还是要活的现实一点, 不要太有梦想, 做一些本身有实际价值事情, 而不是感动自己/他人的事情.</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[:)]]></summary></entry><entry><title type="html">签证准备材料list</title><link href="http://localhost:4000/visa-preparation/" rel="alternate" type="text/html" title="签证准备材料list" /><published>2024-07-11T00:00:00+08:00</published><updated>2024-07-11T00:00:00+08:00</updated><id>http://localhost:4000/visa-preparation</id><content type="html" xml:base="http://localhost:4000/visa-preparation/"><![CDATA[<p>记录签证准备材料的list</p>

<h3 id="美国签证准备材料-详细版本">美国签证准备材料 (详细版本)</h3>

<ul>
  <li>护照原件、旧护照原件（如有）</li>
  <li>签证预约确认页</li>
  <li>SEVIS FEE缴费收据</li>
  <li>DS160 表格确认页</li>
  <li>i20表格（签名）</li>
  <li>2张白底签证照(51mm*51mm)</li>
  <li>存款证明原件</li>
  <li>英文简历（研究生必须）</li>
  <li>学校录取信</li>
  <li>Study Plan （研究生必须）</li>
  <li>导师个人简历 （如有）</li>
  <li>个人论文（如有）没有</li>
  <li>自带包裏 透明没有拉链, 塑料A4纸夹片</li>
  <li>学校成绩单中英文版本</li>
  <li>在读证明中英文版本（如在读)</li>
  <li>毕业证/学位证中英文版本（如毕业）</li>
  <li>标化考试（如TOEFL、IELTS、GRE、GMAT、SAT 等）成绩单复印件或原件</li>
  <li>父母双方收入证明</li>
  <li>户口本/身份证</li>
  <li>房产、车产证明</li>
</ul>

<h3 id="美签学签证-简单版本">美签学签证-简单版本</h3>

<ol>
  <li><strong>护照</strong></li>
  <li><strong>身份证</strong></li>
  <li>DS-160（含照片和条码）</li>
  <li>签证预约信（含条码）</li>
  <li>SEVIS缴费证明</li>
  <li><strong>i-20表格</strong></li>
  <li>录取的offer</li>
  <li>个人简历</li>
  <li><strong>学习计划</strong>(study plan在美国大使馆官网可以下载)</li>
  <li>经济文件: 做i20时候的存款证明</li>
  <li>户口本</li>
  <li><strong>签证预约缴费单</strong></li>
  <li><strong>51*51 mm的签证照（两张）</strong></li>
</ol>

<p>加粗的部分是最后使用到的文件.</p>

<h3 id="日本签证">日本签证</h3>

<ul class="task-list">
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />1、彩色白底免冠证件照电子版;</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />2、护照首页（照片信息页）及末页（第46-47页）的清晰完整对开扫描件（护照剩余有效期需大于回程半年以上）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />3、户口本扫描件（除空白页都要）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />4、非上海领区户籍需额外提供居住证正反面扫描件/在职证明+6个月以上社保/ 在职证明+近1年内税单（上海市内居住证需额外提供验证页面截图电子版）；</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />5、结婚证、离婚证扫描件（如有）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />6、出生证扫描件（未成年必须提供）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />7、日本签证受理表（电脑编辑填写，必须填写完整）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />9、个人信息处理同意书（需填写好日期，姓名和手写签字，打印出来签字提供扫描件，一家人可以写在一起）</p>
  </li>
  <li class="task-list-item">
    <p><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />10、提供以上基本资料+经济材料（7选1）</p>
  </li>
</ul>

<p>温馨提示：领馆有权利让您补充材料，若被通知请及时配合提交；拿到签证之后再定机酒。</p>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[记录签证准备材料的list]]></summary></entry><entry><title type="html">Notes for ‘How To Read MTF Curves’ article</title><link href="http://localhost:4000/how-to-read-mtf-curves.md/" rel="alternate" type="text/html" title="Notes for ‘How To Read MTF Curves’ article" /><published>2024-06-18T00:00:00+08:00</published><updated>2024-06-18T00:00:00+08:00</updated><id>http://localhost:4000/how-to-read-mtf-curves.md</id><content type="html" xml:base="http://localhost:4000/how-to-read-mtf-curves.md/"><![CDATA[<p>文章翻译, 阅读, 解读MTF曲线, 笔记总结</p>
<h1 id="preface">Preface</h1>

<p>The following context and material are sourced from Dr. H.H. Nasse’s articles.  Many many thx for sharing and explain MTF in the preview articles.  However, I still had no understanding at all when I read those articles during my first year of bachelor studies. I will attempt to write this article in my own words without using any grammar or AI tools.  I have to say in some places, I will use some “direct copy” sentences. I don’t consider this as a form of academic plagiarism, as I am writing this post for learning in photography as an enthusiast.</p>

<p>I listed the all used article below. Again, I will use some images and words directly without any citations. If you have any concerns about this post, PLZ contact me at (notmyemailcode@gmail.com) for specific sections throughout the entire article. I will do it for you ASAP.</p>

<p>[1]<strong>Intro. (ZEISS page)</strong></p>

<p><a href="https://lenspire.zeiss.com/photo/en/article/measuring-lenses-objectively-why-do-we-need-mtf-curves-by-dr-hubert-nasse-part-1">https://lenspire.zeiss.com/photo/en/article/measuring-lenses-objectively-why-do-we-need-mtf-curves-by-dr-hubert-nasse-part-1</a></p>

<p>[2]<strong>How to Read MTF Curves</strong>(December 2008)</p>

<p><a href="http://lenspire.zeiss.com/photo/app/uploads/2018/04/Article-MTF-2008-EN.pdf">http://lenspire.zeiss.com/photo/app/uploads/2018/04/Article-MTF-2008-EN.pdf</a></p>

<p>[3]<strong>How to read MTF curves? Part II</strong>(March 2009)</p>

<p><a href="https://lenspire.zeiss.com/photo/app/uploads/2018/04/CLN_MTF_Kurven_2_en.pdf">https://lenspire.zeiss.com/photo/app/uploads/2018/04/CLN_MTF_Kurven_2_en.pdf</a></p>

<p>[4] 如何閱讀MTF(一), Weifu Lin 林渭富 <a href="https://medium.com/one-eyed-poet/">如何閱讀mtf-f85a60cf59c</a></p>

<p>(以上引用都没有被作者授权, 如有侵权, 本人会尽快删除, 文章承认前置的引用的文章的所有贡献.  本文章没有传播价值和商业价值, 是我看了引用的文章的笔记, 理解上的总结与整理 )</p>

<p>The main purpose for this article is helping me in realizing how designers made an excellent lens in the past and to understand which are favorable features for a good lens. And Iet me select suitable apertures not only by weather and sun</p>

<p>I  wanna finish this work in 2 days (2024.06.17-2024.06.18).  太难了, 最后看了一个礼拜才看了一半不到.</p>

<p>The final date for this article is 7.6</p>

<p>淦, 还是用中文写吧.</p>

<h1 id="start-here">START here</h1>

<p>photographers want to take a very natural-looking picture of a subject, the lens should be sharp, which means that the lens will reflect the correct image of the view. As you know, the light line can gather in a light point on the frame plane. The perfect lens needs to show this “point” in the image correctly, but the truth is that the lens cannot do that on every surface. In the article, the Dr. H.H. Nasse give the example pic below, I attached this image below.</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic1.png" alt="pic1" style="zoom:30%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a></p>

<p>this pic indicates 8 satuations in a size comparison, which all input a small white square light, but totally output different light results in cmos(tip: pic7 should be the perfect example)</p>

<h2 id="调制传递modulation-transfer">调制传递（Modulation Transfer）</h2>

<h3 id="sinusoidal-brightness-distribution">Sinusoidal brightness distribution</h3>

<p>下面是文章中第一次出现的需要解释的图</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic2.png" alt="pic2" style="zoom:43%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a> 。</p>

<p>在原文中, 作者提到 Since we are primarily interested in how extended objects are imaged, objects which, unlike stars, comprise an infinite number of points, we must find another way to quantitatively describe the image quality. 于是我们使用sinusoidal brightness distribution来量化. 正弦波是一个连续的、周期性的波形，它在数学上非常容易描述和分析.</p>

<p>如果把原始的光源场景想象成一个简单的正弦函数的话(sinusoidal brightness distribution是明亮和黑暗条纹的图案), 那么在比如说光线在经过镜头以后, 如果成像系统是完美的，我们应该得到一个清晰的、与原始正弦波相同的图像。也可以说, 使用正弦图像我可以得到一个稳定的结果进行分析. 这里的稳定不是指成像质量.</p>

<p>但是成像系统总是存在一些缺陷，玻璃的折射, 空气灰尘, 传感器的噪声. 实际得到的图像正弦波会与原始的场景的正弦波有所不同。 但是Several of its properties also remain stable or at least have nothing to do with imaging quality: The direction of the stripes does not change and the frequency – the number of stripes per unit length – only changes according to the imaging scale.</p>

<p>由于成像系统的缺陷, 光线不会完美地聚焦在它应该聚焦的地方。这就导致了所谓的“点扩散”. 也就是说, 某光线不仅照亮了应该照亮的区域, 也让周围应该是暗的区域发亮了.  这种光线的扩散效应改变了明暗条纹之间的亮度差异，使得图像的对比度降低。</p>

<p>回到需要解释的图,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic2.png" alt="pic2" style="zoom:43%;" /></p>

<p>黑色曲线代表了实际风景的正弦条纹的亮度分布(which means 原始的一个简单明暗分布), 而空心圆组成的image线条是实际成像后的结果图, 可以认为是照片的实际效果, 这里埋一个伏笔.</p>

<p>然后是红色点和红色线, 蓝色点和蓝色线, 这是一开始我没有理解的部分, 我以为有什么特殊含义, 但是, 其实这组Point Spread Profile说明了有一个点光源分别在成像的时候, 落在了某个地方对原始光线造成了影响, 点作为亮度最高的部分, 下面的曲线则代表了光源的Profile, 很好理解. 从最亮的地方, 逐渐减弱,这样.</p>

<p>于是定义来了,</p>

<p>1⃣️ the difference between bright and dark is referred to as “contrast”.</p>

<p>2⃣️ the difference between maximum and minimum for all sinusoidal, periodically changing quantities is called “modulation.”</p>

<p>那么这两个相似表述的区别是什么, GPT说, <strong>对比度</strong>通常通过比较图像中最亮和最暗部分的亮度来衡量。<strong>调制</strong>通过信号的最大值和最小值的差异来衡量，反映信号的幅度变化。OK还是没理解, 回到图.</p>

<p>如果我们使用对比度的相关概念来描述, 在一张高对比度的照片中，太阳的亮光和树影的黑暗之间的差异非常明显。而使用调制的逻辑是, 在一个<strong>调制较高</strong>的正弦波信号中，波峰的高度和波谷的深度之间的差异非常大。</p>

<p>我感觉这里光学的modulation和信号处理的modulation的差距有点大, 虽然学的不精, 但是依稀记得是改变载波信号的幅度/频率/相位来传递信息(AM,FM,PM), 好的按下不表.</p>

<p>在这里之前的伏笔来了, “对比度”指图像中明暗区域之间的差异, 但是在事实上, 是我们判断镜头分辨率的关键.</p>

<p>我们引出了</p>

<h2 id="调制传递函数mtf">调制传递函数（MTF）</h2>

<p>用来评估光学系统将物体上的调制传递到图像中的能力。通过比较图像的调制(图像)与物体的调制(图像)来计算，结果是一个介于0和1（或0%到100%）之间的数值。</p>

<p>在这里文章给出了一个列子,有点难理解的, The photographer is used to expressing bright-dark differences in aperture stops, which is also very reasonable as the perception of our eyes follows such logarithmic scales. But, what, for example, does a modulation transfer of 50% mean if our pattern of stripes consists of a difference of 6 aperture stops between the brightest and darkest points, i.e. a brightness ratio of $1 : 2^6  = 1 : 64 $ ? Is the difference in the image 3 aperture stops or $1:32$, which would correspond to 5 aperture stops? 神来一笔, 我们如何理解 <strong>modulation transfer of 50%</strong>, 调制传递率（Modulation Transfer）的50%并不是指整体画面会变暗50%。 Both would be wrong. In reality, we would then still have approximately 1.5 aperture stops in the above-mentioned case.</p>

<p>给出Contrast计算的公式
\(\text{Contrast} = \frac{\text{Maximum} - \text{Minimum}}{\text{Maximum} + \text{Minimum}}\)
我觉得还是挺容易理解的公式, 带入Contrast值=50%, 然后文章给出了例子, 没看懂从哪里来的, Therefore, in our example, the contrast of the object is 63 divided by 65, or approx. 哦, 就是突然给了两个值, Maximun-Minmun=63, Maximun+Minmun=65, 再63÷65≈0.97. 作为经过调制传递率为50%的成像，我的理解是满足上面那个公式上的定义, 然后MTF=50% 开始定义, 这时候文章下面有一个图我去比较了, 结果又理解错了. 正常的步骤是直接得出0.97的一半, 大约是0.48, 然后 (x-1)/(x+1)=0.48得到我们的估算值为 x≈2.846, 所以我们的档位从6掉到了2.846, 光量从64掉到了7.19004101289. 我在这里还是没有理解档位的问题…见下图</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic4.png" alt="howToReadMTFpic4" style="zoom:23%;" /></p>

<p>圖３：將反差對比的定義以正弦波圖形表示，兩者比値與測量位置情報共同構成MTF曲線。本圖經過翻譯及重繪。原始圖片來源 &amp; Credit：戶村賢一、〈MTF：MTF曲線から読み取るレンズ特性の正体〉、page 128、《ライカ通信》 Vol.1, 2000年4月。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic3.png" alt="pic3" style="zoom:30%;" /></p>

<p>原始圖片來源 &amp; Credit：Hubert H. Nasse, <em>How to Read MTF Curves, page 6,</em> <a href="https://lenspire.zeiss.com/photo/en/article/overview-of-zeiss-camera-lenses-technical-articles/">《LENSPIRE》</a> 。</p>

<p>为什么这么像PN结放大…</p>

<p>我感觉这个地方, 一开始也有理解错的地方, 我的疑惑点有这些</p>

<ol>
  <li>MTF在图像中, 在曲线上是一个固定的参数, 好像是不会变化的, 但是在调整光圈档位的时候, 传感器接收到的maximum和minimum的光会减少, 我感觉这个在光圈变化后会变化, 但是MTF没有变.</li>
  <li>如果研究的目标是Object, 那我感觉光圈变化不会影响MTF啊, 因为环境的maximum和minimum的光量不会变啊</li>
  <li>对档位的理解有点奇怪, 0,1,2,3,4,5档, 如果使用$2^n$ 来理解的话, 可能可以想通, 我之前一直没搞明白, 就是越调档, 光量越小, 结果更加好? 反正我觉得有点奇怪.</li>
  <li>这里档位, 有个点没有明白就是比如, object contract有10档, image contact只有最高有6档, 那么object contract的10档中的第6档和image contact的最高档第6档的光照亮度强度是一样的么</li>
  <li>横坐标从1开始的, 有点没理解</li>
</ol>

<p>OK我觉得这里的混淆, 主要是由于参照坐标系的混乱造成的.</p>

<p>那么这个图怎么看呢, 比如取最高点(MTF=97%进入平缓发展的点), 取(10,6)点为例, Object Contrast (Aperture Stops) = 10, Image Contrast (Aperture Stops) = 6, 使用contact的定义, 在 $2^n$带入6和10, 得到64和1024(最高亮度值), 他们的最低值都是1, 所以
\(\text{Object Contrast} = \frac{L_{\text{max, object}} - L_{\text{min, object}}}{L_{\text{max, object}} + L_{\text{min, object}}} = \frac{1024 - 1}{1024 + 1} = \frac{1023}{1025} \approx 0.9976\)
再得
\(\text{Image Contrast} = \frac{L_{\text{max, image}} - L_{\text{min, image}}}{L_{\text{max, image}} + L_{\text{min, image}}} = \frac{64 - 1}{64 + 1} = \frac{63}{65} \approx 0.9692\)
这里引出/使用计算mtf的公式
\(\text{MTF} = \frac{\text{Image Contrast}}{\text{Object Contrast}} = \frac{0.9692}{0.9976} \approx 0.97153167602\)
下面是作者对于这个图的简单总结, 一开始没懂怎么来的, 感觉还挺难理解的.</p>

<p>我们可以从三个方面来理解 MTF 曲线的特性：</p>

<ol>
  <li><strong>高 MTF 值的小差异在高物体对比度下特别显著</strong>：
    <ul>
      <li>当物体对比度很高时（例如光圈档位为 9 或 10），MTF 曲线的高值（例如 90% 或 97%）之间的细微差异对图像质量有很大影响。即使 MTF 仅从 90% 增加到 97%，在高对比度的物体下，这种小的差异也能显著提高图像的对比度。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.1.png" alt="howToReadMTFpic3.1" style="zoom:20%;" /></li>
    </ul>
  </li>
  <li><strong>弱的色调变化（小于一个光圈档位）不需要高 MTF 值</strong>：
    <ul>
      <li>当物体对比度较低（例如低于一个光圈档位时），高于 70-80% 的 MTF 值差异几乎没有实际意义。这意味着在低对比度场景中，即使 MTF 下降到 70-80%，也不会对图像质量造成明显影响。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.2.png" alt="howToReadMTFpic3.2" style="zoom:20%;" /></li>
    </ul>
  </li>
  <li><strong>非常低的 MTF 值下，物体对比度的高低几乎没有影响</strong>：
    <ul>
      <li>当 MTF 值非常低（例如低于 20%），无论物体的对比度多高，图像的对比度总是很低。这表明系统在低 MTF 下对比度还原能力很差，导致图像质量大幅下降。</li>
      <li><img src="../assets/images/howToReadMTF/howToReadMTFpic3.3.png" alt="howToReadMTFpic3.3" style="zoom:20%;" /></li>
    </ul>
  </li>
</ol>

<p>OK, 在看了这三个特征总结之后,  object光圈档位调整的含义和具体的光圈档位感觉可以澄清, 就是不同的光量, 如果两个contract都是处在Aperture stop=6的情况下的话, 他们的光量都是$2^6=64$, 也就是说是一样的. 我一直有一个错误的想法, 就是把一个环境和一个传感器上的光均匀切割, 然后分成不同的等份作为不同档位的错误理解.   调制传递函数（MTF）表示成像系统在不同空间频率下传递对比度的能力,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">这个位置的小节</span><span class="o">,</span> <span class="n">我觉得我从这段文本得到的新的认知是</span><span class="o">,</span> <span class="n">我在之前从来不知道</span><span class="o">,</span><span class="n">对比度</span><span class="o">,</span> <span class="n">明暗</span><span class="o">,</span><span class="n">对清晰度的影响</span><span class="o">,</span> <span class="n">或者说对比度在直接控制清晰度</span><span class="o">?</span> <span class="n">感觉这个说法有问题</span><span class="o">,</span> <span class="no">OK</span><span class="o">,</span> <span class="n">在对岸的一个作者的一篇文章上找到了答案</span><span class="o">.</span>
</code></pre></div></div>

<p>下面小结的内容来自Weifu Lin在Medium平台上的文章, 链接在 <a href="https://medium.com/one-eyed-poet/%E5%A6%82%E4%BD%95%E9%96%B1%E8%AE%80mtf-f85a60cf59c">如何閱讀MTF(一)</a> , 是作者结合蔡司的这篇文章和日本的一个作者的文章的翻译. 有两个图非常非常好, 指明了contract和Resolution的区别.</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic6.png" alt="howToReadMTFpic6" style="zoom:33%;" /></p>

<p>繪圖：Weifu Lin</p>

<p><strong>这里的内容是直接引用的[5].</strong> 兩種不同設計取向的鏡頭的比較。鏡頭B的解像力較高，但實際拍攝時，鏡頭A會給觀賞者「更銳利」的觀感。箭號位置所指的虛線，是人眼能分辨細節的最低臨界點。本圖經過翻譯、修訂以及重繪。原始圖片來源 &amp; Credit：戶村賢一、〈MTF：MTF曲線から読み取るレンズ特性の正体〉、page 129、《ライカ通信》 Vol.1, 2000年4月。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic7.png" alt="howToReadMTFpic7" style="zoom:25%;" /></p>

<p>到这一步的时候, 我有点没看懂…</p>

<h2 id="modulation-transfer-function-resolving-power">Modulation transfer function, resolving power</h2>

<p><em>It is obvious that one single stripe pattern is not sufficient to characterize the quality of a lens. A very coarse pattern with large separations between bright and dark stripes could, of course, also be imaged well by a lens with a relatively large point spread function. If we decrease the separation between the stripes, however, so that the separation between bright and dark approaches the size of the point spread, then a lot of light from the bright zone is radiated into the darker zones of the pattern and the image contrast becomes noticeably lower.</em> 我觉得可以理解成原来黑白粗线条的object contract比较高, 因为每个亮区和暗区之间的光线干扰较少. 但是在原本光照环境没有改变的情况下, 一些细小的线条远看是灰色, 导致亮区变暗，暗区变亮, 这会造成对比度的降低这样. 有一个形象的解释是, 写毛笔字, 尺寸比较大, 气势磅礴的字体可以使用大的毛笔, 但是涓涓小楷, 甚至在鼻烟壶里面写字, 这些艺术家为我需要更精细的书写工具. 菜刀如何雕刻核舟记?</p>

<p>为了比较不同精细度的条纹图案来研究镜头的成像能力(其实就是复杂环境)，我们使用调制传递函数（MTF）来量化. 而且, 为了研究镜头如何成像不同精细度的条纹图案，我们需要为每一个条纹图案确定一个调制传递。将这些调制传递值绘制为一个描述条纹图案精细度的参数的函数，这些值就形成了一条曲线，即调制传递函数(MTF)。</p>

<h3 id="我们如何量化条纹图案精细度">我们如何量化条纹图案精细度</h3>

<p><strong>条纹图案的精细度</strong>：通过计算图像中每毫米包含多少个条纹周期来测量。一个周期是两个亮条纹或两个暗条纹之间的距离，或由一个暗条纹和一个亮条纹组成的线对的距离。</p>

<p><strong>空间频率(Spacial frequency)</strong>：图像平面上每毫米的周期数称为空间频率，单位是每毫米线对数，简称为 lp/mm。</p>

<p>下面是文章中的一个图片例子,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p><strong>GPT</strong>对图注的解释如下</p>

<ul>
  <li><strong>Measurement Aperture 2</strong>: 测量是在光圈 f/2 下进行的。这意味着镜头的实际成像性能是通过在 f/2 的光圈下拍摄条纹图案来测量的。</li>
  <li><strong>Diffraction-limited Aperture 5.6</strong>: 理论上，光圈 f/5.6 是受衍射极限影响的最佳光圈。也就是说，在 f/5.6 光圈下，成像质量接近衍射极限，表现出最佳的清晰度和对比度。</li>
  <li><strong>Measurement Aperture 5.6</strong>: 测量是在光圈 f/5.6 下进行的。镜头的实际成像性能是通过在 f/5.6 的光圈下拍摄条纹图案来测量的。</li>
  <li><strong>Diffraction-limited Aperture 16</strong>: 理论上，光圈 f/16 是受衍射极限影响的最佳光圈。在 f/16 光圈下，成像质量接近衍射极限，但由于光圈较小，衍射效应变得显著，从而影响图像清晰度。</li>
</ul>

<p>For purposes of comparison the diffraction-limited transfer functions for f/5.6 and f/16 are also shown (solid line without circular dots). The diffraction-limited image is the best possible one.</p>

<h3 id="什么是diffraction-limited-衍射受限通常用于描述光学系统的成像性能">什么是Diffraction-limited, 衍射受限(通常用于描述光学系统的成像性能)</h3>

<p><strong>Diffraction-limited</strong> 是描述光学系统在没有像差和其他缺陷情况下，由于光的衍射效应所能达到的最佳成像质量。当光线通过光学系统（如镜头）时，会由于光的波动性而发生衍射，这种效应会限制系统的分辨能力. <strong>衍射</strong>：与光的波动性质有关，当光波遇到障碍物或狭缝时发生偏折. <font color="grey">看到这个地方的时候, 我不知道光的衍射是什么, 也不知道为什么会影响光学系统的能力, 但是这里的意思, 因为这个性质的存在, 有了极限, which is 图示中的黑色实线(接近直线).</font></p>

<p>OK, 换用新图, Winfu前辈做的图真的是好,</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBZzdqTab7E0UKD7T-GOuQ.png" style="zoom:35%;" /></p>

<p>下面是文章的内容的直接复制(没有换成简体中文)</p>

<p>為了作為比較，也標示了f 5.6（橄欖綠色虛線）以及f 16（灰藍色虛線）的繞射極限的轉換函數。達到繞射極限上限的影像是理論上的最佳影像品質，在圖表上呈現幾近完美的直線，下降率與空間頻率成比例。在到達<strong>極限頻率（limited frequency）</strong>時，MTF趨近於０，其頻率由<strong>光的波長</strong>與<strong>光圈値</strong>兩個因素決定。</p>

<font color="grey">这里又想补充一点就是, 突然想到, 超过了这个原来的黑色实线(新图的蓝绿虚线,也就是繞射極限), 就会因为衍射的问题, 让成像崩了, 这样?</font>

<p>現實中的鏡頭即使<strong>校正</strong>，仍帶有殘餘<strong>像差</strong>，因此MTF曲線一開始會快速下降，然後緩慢趨近於０。曲線明顯向下彎折，就像上面圖６中光圈為f 2的洋紅色曲線一樣；至於光圈縮至f5.6後的藍色曲線和理論最佳値的差距就相當接近了。</p>

<p>當MTF曲線降至０或低於一個臨界點（Threshold） — — 例如10％，<strong>其空間頻率即為光學鏡頭在空氣中的解像力</strong>，這意味著一旦超過臨界點，黑白條紋的明暗結構整體變成灰色而難以辨識，這又是另一個問題。</p>

<p>圖測量鏡頭在光圈f 2時的曲線，空間頻率到達120 lp/mm時，幾乎是一片平坦，即使空間頻率增加，反差對比也幾乎沒有變化，這樣的測量非常不精確，鏡頭解像力可能達到160 lp/mm以上，也可能只有120 lp/mm。</p>

<p>這樣的判準，並不適合用來評判一隻鏡頭的影像品質。此外，空間頻率與數位時代的影像感測器（image sensor）的「解析度」，兩者也不能混為一談。</p>

<h4 id="像差-aberration">像差 (Aberration)</h4>

<p>在低空间频率下，像差影响相对较小(<strong>为什么?</strong>), 随着空间频率的增加，像差的影响逐渐显现(我觉得是容易变灰, 高频下间隙太小的原因)</p>

<h4 id="像差的类型gpt生成">像差的类型(GPT生成)</h4>

<p><strong>球差（Spherical Aberration）</strong></p>

<ul>
  <li>发生在球面透镜中，中心和边缘的光线不能聚焦到同一点。</li>
  <li>导致图像中心和边缘的清晰度差异，影响整体锐度。</li>
</ul>

<p><strong>色差（Chromatic Aberration）</strong></p>

<ul>
  <li>由于不同波长的光在通过镜头时折射角度不同，导致不同颜色的光聚焦在不同位置。</li>
  <li>产生彩色边缘和色散现象，尤其在高对比度边缘处明显。</li>
</ul>

<p><strong>彗差（Coma）</strong></p>

<ul>
  <li>主要影响图像的边缘部分，使点光源呈现为彗星形状。</li>
  <li>影响图像边缘的锐度和对比度。</li>
</ul>

<p><strong>像散（Astigmatism）</strong></p>

<ul>
  <li>垂直和水平方向的光线不能同时聚焦在同一点。</li>
  <li>导致图像在某一方向模糊，影响细节表现。</li>
</ul>

<p><strong>场曲（Field Curvature）</strong></p>

<ul>
  <li>图像平面不是平坦的，而是弯曲的。</li>
  <li>中心清晰，边缘模糊或相反。</li>
</ul>

<p><strong>畸变（Distortion）</strong></p>

<ul>
  <li>图像几何形状变形，直线变弯曲。</li>
</ul>

<h4 id="其空间频率即为光学镜头在空气中的解像力">“其空间频率即为光学镜头在空气中的解像力”</h4>

<p>表示在MTF（调制传递函数）曲线下降到某个低阈值（例如10%）时，对应的空间频率就是这个镜头在空气中的解像力。换句话说，这个空间频率是镜头能够有效分辨的最高频率。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.1.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p>举个例子, 假设某个镜头的MTF曲线在30 lp/mm时降到10%，那么这个30 lp/mm就是这个镜头在空气中的解像力。也就是说，这个镜头能够分辨的最细微的细节是每毫米30对条纹。超过这个频率，图像细节将无法分辨，变成灰色或模糊。</p>

<p>下面是文章的内容的直接复制(没有换成简体中文)</p>

<p>測量鏡頭在光圈f2時的曲線，空間頻率到達120 lp/mm時，幾乎是一片平坦，即使空間頻率增加，反差對比也幾乎沒有變化，這樣的測量非常不精確，鏡頭解像力可能達到160 lp/mm以上，也可能只有120 lp/mm。</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic5.2.png" alt="howToReadMTFpic5" style="zoom:30%;" /></p>

<p>我怎么感觉文章里面没解释过下图</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6bFyZjRh3SFEGqeJubvrg.png" style="zoom:33%;" /></p>

<p>這樣的判準，並不適合用來評判一隻鏡頭的影像品質。此外，空間頻率與數位時代的影像感測器（image sensor）的「解析度」，兩者也不能混為一談。</p>

<p>這也是蔡司為何決定採用MTF來描述成像品質的原因之一。我們並不直接用眼睛觀察相機鏡頭成像，鏡頭後方總是需要一個媒介：傳統銀鹽底片、CCD、CMOS、掃描器、投影機……等等，有類比式的也有數位式的。</p>

<p>所有媒介（包括人的眼球在內）都有自身的影像特性，每一種影像特性也可以用一組轉換函數來分別描述。MTF的優勢在於：整體的光學成像鏈的MTF是（接近於所有）個別MTF的乘積。</p>

<p>Let us consider a few typical examples:</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic8.png" alt="howToReadMTFpic8" style="zoom:33%;" /></p>

<p>有两个图, 第二张没放, 这的意思感觉就是要注意镜头素质和传感器的素质.</p>

<p>Product of two modulation transfer functions: Very good 35mm format lens and color negative film. The product is always smaller than the smallest factor in the imaging chain.</p>

<p>In this case, the total modulation is essentially limited by the film. If one specifies a minimum of 10% modulation transfer, one must expect a resolving power of 80100lp/mm. If further elements such as projection optics or the eye are taken into account, the product is even slightly smaller.</p>

<h2 id="在评价光学系统性能时为什么通常不需要考虑非常高的空间频率">在评价光学系统性能时，为什么通常不需要考虑非常高的空间频率</h2>

<p><strong>理由</strong></p>

<p>在这里, 我们观察使用的是MTF product lens x film, which is 看到整体的光学系统对不同空间频率的响应, 乘积后MTF越小，表示系统在该空间频率下的表现越差。涉及更多的传递函数(MTF) 往往只会使乘积变小.</p>

<p><strong>数码传感器的空间频率限制和实际使用下的限制</strong></p>

<p>24百万像素的35毫米全画幅格式传感器和15百万像素的APS-C格式传感器，其奈奎斯特频率大约为90lp/mm, 这是如何计算出的</p>

<p>同时, 40lp/mm已经足以提供足够的细节和清晰度，超出这个范围的细节对于大多数实际用途来说并不显著, 我不知道为什么. 40lp/mm被认为是一个合理的上限，因为它既能够提供足够的图像细节，又不会受到高频混叠等问题的影响。</p>

<p><strong>Nyquist Frequency</strong></p>

<p>想起来在信号系统里面学过, Nyquist Frequency是采样率的一半, 只要离散系统的奈奎斯特频率高于被采样信号的最高频率或带宽，就可以避免混叠现象。对于CMOS传感器而言，它表示传感器能可靠捕捉到的最高空间频率。在图像处理中，采样频率是指传感器的像素密度。
\(f_{\text{Nyquist}} = \frac{1}{2} f_{\text{sampling}}\)</p>

<p><strong>90lp/mm（每毫米90对线对）</strong></p>

<p>每毫米有90对黑白线对</p>

<h2 id="edge-definition-image-contrast">Edge definition, image contrast</h2>

<p>以下繁体文字内容为直接复制[5].</p>

<p>但是，這些「數據變化」對實際影像品質而言有何意義？當我們談論「清晰銳利」、「明亮度」、「細節解析力」時，和這些數據之間有什麼關連？</p>

<p>我們拍攝的主體本身顯然不是正弦波。它們只能在實驗室中透過大量測試階段生成，使用其他目標對象進行測試，並以數學方式推導出正弦波的調變。</p>

<p>蔡司使用的是一種「明暗變化明顯的長方形黑白條紋圖案」的特製測試圖表，來評估相機鏡頭的有效解像力。</p>

<p>精細的，重複變化的圖案，僅僅只佔據我們的視覺功能中用來辨識影像品質的一小部分。重點是明暗不同亮度區域之間的邊界。因此，蔡司還必須研究MTF與邊界再現（reproduction）兩者的關係。說到這，我們不得不回到起點：點擴散函數。</p>

<p>然后在文章中就出现了4个图, which is由三并排图组而呈现的设计(有点绕口), 我一次性按顺序放在下面,</p>

<p>1⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.png" alt="howToReadMTFpic9.2" /></p>

<p>2⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.3.png" alt="howToReadMTFpic9.3" /></p>

<p>3⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.4.png" alt="howToReadMTFpic9.3" /></p>

<p>4⃣️</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.1.png" alt="howToReadMTFpic9.1" /></p>

<p>The following images show from left to right:</p>

<p><strong>Intensity profile of the point spread function</strong>, 也就是每个图中的第一个section, 这个是光的点扩散函数, which means  that 点光源/或者说一束光在通过镜头折射穿透后, 在传感器上的分散的切面, 我觉得可以理解成底部的位置就是传感器的感光位置, 以图1⃣️为例子, 这是一个很好的镜头成像, 非常清晰, 点光源只扩散到了-20µm和20µm之间,</p>

<p><strong>Intensity profile of two edge images</strong>, 对于这里的Edge profile我的理解是主要关注0µm处如何变化, 还是以图1⃣️为例, 发现在0µm初变化的非常快速, 这是一个好的镜头的表现.</p>

<p>The corresponding <strong>modulation transfer</strong> 这里是柱状体描述的MTF图示, 拜文章所赐, 文章会见到不同厂商各式各样的格式,方法和规格的MTF的图片. 还是以图1⃣️为例, 这是一个非常好的MTF小图, 不知读者有没有意识到, 从5Lp/mm开始接近100%的MTF率, 到80Lp/mm下仍然保持了接近于50%的MTF率. 原作者评价$\rightarrow$ The image of the edge is sharp. In the language of modulation transfer, this characteristic is recognized by the fact that all values at the important spatial frequencies are very high and do not decrease so strongly towards the higher frequencies.</p>

<p>For a lens with such imaging performance, the image quality achieved is usually limited by the sensor or by other factors such as focusing accuracy, camera movements etc. 好家伙, 镜头不会限制图像的表现, 差的结果是一些客观的因素.</p>

<p>下面是针对不同的图的结果分析</p>

<h4 id="pic-1">Pic 1</h4>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.1.png" alt="howToReadMTFpic9.2.1" style="zoom:33%;" /></p>

<p><strong>Intensity profile of the point spread function</strong> for Pic 1.1</p>

<p>这个图在之前解释过, 可以被考虑成是一个竖直光线照在传感元件上的横切面, 可以想象成一个千层蛋糕的切面. 同时也在之前提及过, 这个数据非常非常优秀,</p>

<p><img src="../assets/images/howToReadMTF/howToReadMTFpic9.2.2.png" alt="howToReadMTFpic9.2.2" style="zoom:33%;" /></p>

<p><strong>Intensity profile of two edge images</strong> for Pic 1.1</p>

<p>在之前的解释中, 没有被明确指出, 现在, 可以注意在新的图示中我划出来的红色竖线, 这表示明暗的交接线. 可以看到, lens有非常非常好的过度变化, 在经过0的时候瞬间过了,</p>

<p><strong>Modulation transfer</strong> MTF for Pic1.1</p>

<p>非常非常优秀的MTF曲线表示, 在5lp/mm情况下,  正常的随着条纹更加精细而不断下降的数值, 合理而正常.</p>

<h3 id="小注">小注</h3>

<p>本来是计划把4个表都解释一遍, 但是发现, 好像没有现实意义, 因为文章的意图是理解MTF曲线, 但是这种形式的MTF曲线已经不再使用. 但是在这个部分要指出的是, MTF测量表会不准, 显示 出错误的数据信息, 在文章中的例子就是, 比如现实图像在影射后, 在cmos上位移会没有显示清晰的图像, 但是位移的图像在某个Lp/mm的条纹下, 移动到了下一个位置, 导致图像没有变模糊, 仍然清晰. 虽然镜头的素质没有提高, 但是由于测试的是这种特殊的条纹, 让MTF的曲线的数据提高, 这是虚假的成绩. 这个现象在文章中被专门指出. 我在这里直接引用, <strong>But:</strong> There is no contrast at 40lp/mm! <font color="red">The curve of the modulation transfer can drop to zero and then increase again.</font>  This is then called “spurious resolution”, which is a somewhat unfortunate expression because the structure with 60lp/mm is reproduced with a clear resolution.</p>

<h2 id="文章中的第四种mtf曲线the-mtf-values-of-this-4th-type">文章中的第四种MTF曲线(The MTF values of this 4th type)</h2>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[文章翻译, 阅读, 解读MTF曲线, 笔记总结 Preface]]></summary></entry><entry><title type="html">Inner producted 一些问题</title><link href="http://localhost:4000/inner-producted/" rel="alternate" type="text/html" title="Inner producted 一些问题" /><published>2023-10-09T00:00:00+08:00</published><updated>2023-10-09T00:00:00+08:00</updated><id>http://localhost:4000/inner%20producted</id><content type="html" xml:base="http://localhost:4000/inner-producted/"><![CDATA[<p>A record of some simple ideas.</p>

<h2 id="vector-inner-product">vector inner product</h2>

<p><strong>向量的内积</strong></p>

<ul>
  <li>内积的定义:
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>设A和B为两个向量,它们的内积定义为A在B上的投影长度,用公式表示为&lt;A,B&gt; =</td>
              <td>A</td>
              <td> </td>
              <td>B</td>
              <td>cosθ,其中θ是两向量之间的角度。</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>
    <p>内积的几何意义:内积反映了两个向量间的相似程度,当两个向量方向相同时内积最大;when两向量垂直时内积为0。</p>
  </li>
  <li>
    <p>如何计算两个向量的内积:设两个n维向量为A=(a1,a2,…,an),B=(b1,b2,…,bn),则两向量的内积为&lt;A,B&gt; = a1b1 + a2b2 + … + anbn,即对应元素相乘并求和。</p>
  </li>
  <li>内积为何等于零:当两个向量垂直时,cosθ=0,从内积公式可知此时&lt;A,B&gt;=0。也就是说,内积等于零表示两个向量互相垂直。</li>
</ul>

<h2 id="matrix-inner-product">matrix inner product</h2>

<ul>
  <li>矩阵内积的定义:对于两个矩阵A和B,它们的内积定义为:&lt;A,B&gt; = tr(A^TB),即矩阵A与B转置矩阵的乘积的<strong>迹</strong>,什么是迹，就是从左到右的对角线。</li>
  <li>矩阵内积与迹的关系:矩阵内积用矩阵迹来表达,迹反映了矩阵的特征,内积刻画了两个矩阵间的相关性。</li>
  <li>如何计算两个矩阵的内积:对两个矩阵A和B,计算A^TB,然后求出其迹(对角元素之和)即可。</li>
  <li>矩阵内积的性质:
    <ul>
      <li>对称性 &lt;A,B&gt; = &lt;B,A&gt;</li>
      <li>双线性形式</li>
      <li>
        <table>
          <tbody>
            <tr>
              <td>范数不等式$</td>
              <td>&lt;A,B&gt;</td>
              <td>&lt;=</td>
              <td> </td>
              <td>A</td>
              <td> </td>
              <td>·</td>
              <td> </td>
              <td>B</td>
              <td> </td>
              <td>$ <font color="red">这啥</font></td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>matrix的变换。</li>
</ul>

<h2 id="fx-and-gx-inner-product">f(x) and g(x) inner product</h2>

<ul>
  <li>
    <p>函数内积的定义:对于区间[a,b]上的连续函数f(x)和g(x),它们的内积定义为\(\langle f, g\rangle=\int_a^b f(x) g(x) d x\)</p>
  </li>
  <li>
    <p>如何利用积分计算函数内积:将函数相乘后对区间[a,b]积分,即可计算内积。</p>
  </li>
  <li>
    <p>函数内积的双线性形式:满足α&lt;f,g&gt; = &lt;αf,g&gt; = &lt;f,αg&gt;</p>
  </li>
  <li>
    <p>函数内积与区间长度的关系:内积与区间长度成正比,因此也会normalize由 $\int ab$  改为 $\int \frac{ab}{L}$。</p>
  </li>
  <li>
    <p>函数内积的应用:反映函数间相关性,应用于信号处理、模式识别等领域。</p>
  </li>
</ul>

\[\langle f, g\rangle=\int_a^b f(x) g(x) d x\]

<p>or another choice</p>

\[\langle f, g\rangle=\frac{1}{b-a} \int_a^b f(x) g(x) d x\]

<p>第一种表示法:</p>

\[\langle f, g\rangle=\int_a^b f(x) g(x) dx\]

<p>直接对函数的乘积在区间[a,b]上进行积分即可得到内积。</p>

<p>第二种表示法:</p>

\[\langle f, g\rangle=\frac{1}{b-a}\int_a^b f(x) g(x) dx\]

<p>在积分中额外引入了比例系数$\frac{1}{b-a}$,目的是归一化区间[a,b]的长度,使得内积不直接依赖于区间长度。</p>

<h2 id="应用傅立叶级数">应用：傅立叶级数</h2>]]></content><author><name>Chia-ch&apos;i</name></author><summary type="html"><![CDATA[A record of some simple ideas.]]></summary></entry></feed>